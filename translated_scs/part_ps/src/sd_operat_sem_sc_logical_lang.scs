.system_element_6406
=> nrel_summary: [<p>Логические модели решения задач являются основой обработки знаний в интеллектуальных системах. В данной главе рассматривается интеграция различных моделей решения задач, в том числе принципы логического вывода, для решения задач на основе общей формальной модели.</p>]
(*
	<- lang_ru;;
	=> nrel_format: format_html;;
*);
=> nrel_inclusion: [*
	<- .system_element_3;
	-> rrel_key_sc_element: .system_element_6407;;

	.system_element_6407
	<- subject_domain;
	-> .system_element_330: 
		.system_element_6408
	;
	=> .system_element_1416: 
		.system_element_2529;
		.system_element_1105;
		.system_element_6409;
		.system_element_6399
	;
	=> .system_element_316: <
		.system_element_6410;
		.system_element_6411;
		.system_element_6412;
		.system_element_6413;
		.system_element_6414;
		.system_element_6415;
		.system_element_6416;
		.system_element_6417;
		.system_element_6418;
		.system_element_6419;
		.system_element_6420;
		.system_element_6421;
		.system_element_6422;
		.system_element_6423;
		.system_element_6424;
		.system_element_6425;
		.system_element_6426
	>;;

	.system_element_6427
	=> nrel_explanation: [<p>Логика решает задачи доказательства высказываний, аргументации того или иного высказывания, задачу генерации и опровержения гипотез. Некоторые гипотезы могут быть опровергнуты, однако извлекая причины того, почему гипотеза опровергнута, можно изменить посылку гипотезы так, чтобы создать новую гипотезу, которая впоследствии может стать теоремой.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_explanation: [<p>Логика не изучает то, как были получены знания, она позволяет представлять знания, а также из существующих знаний вывести новые (то есть из имеющихся формул логики вывести новые формулы этой же логики), установить правильность рассуждений.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);;

	.system_element_961
	=> nrel_note: [<p>Современная логика изучает <i>формальные языки</i>, служащие для выражения логических рассуждений.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);;

	.system_element_6408
	<= nrel_inclusion: .system_element_961;;

	.system_element_6428
	=> nrel_note: [<p>На данный момент реализовано много систем <i>логического вывода</i>, использующих известные правила прямого заключения и резолюции в различных видах логик.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> .system_element_4178: 
		[<p>Проблема совместимости систем логического вывода.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Проблема коллективного решения задач с использованием различных моделей решения задач.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*)
	;;

	.system_element_1260
	<= nrel_inclusion: .system_element_1175;
	=> nrel_explanation: [<p>Логическая модель решения задач может быть задана такими языками, как <i>Rule Interchange Format</i> (RIF), Semantic Web Rule Language (SWRL), <i>SHACL Rules</i> и <i>Notation3 Rules</i>, которые используются в <i>Semantic Web</i>.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> nrel_note: [<p>Языки RIF, SWRL, <i>SHACL Rules</i> и <i>Notation3 Rules</i> не предусматривают возможность представления формул в различных видах логик, поэтому при помощи них невозможно решить описанные проблемы систем логического вывода. Языки правил специально построены для вывода следствий. Синтаксис и семантика языков онтологий и языков правил довольно сильно отличаются, поэтому возникает вопрос, как их совмещать.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
		=> .system_element_785: .system_element_6429
		(*
			<=> nrel_semantic_equivalence: "file://images/sd_operat_sem_sc_logical_lang/swrl_example.png"
			(*
				<- concept_file;;
				=> nrel_format: format_png;;
			*);;
		*);;
	*);
	=> .system_element_35: .system_element_6410;
	=> nrel_note: [<p><i>Технология OSTIS</i> позволяет интегрировать любые принципы логического вывода для решения задач в интеллектуальных системах на основе общей формальной модели. Для того, чтобы использовать какую-либо новую или существующую модель, необходимо привести ее к предлагаемому формализму, что позволит интегрировать и синхронизировать ее с уже имеющимися в соответствующей <i>библиотеке многократно используемых компонентов ostis-систем</i>. Формализм <i>SC-кода</i> позволяет описывать широкий спектр понятий и отношений между ними, что делает его подходящим вариантом для реализации логического вывода в интеллектуальных компьютерных системах нового поколения. Кроме того, целесообразно воспользоваться принципом наследования, лежащим в основе иерархической структуризации баз знаний ostis-систем.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> .system_element_203: .system_element_6430
		(*
			=> nrel_inclusion: [*

				.system_element_1084
				=> .system_element_1523: 
					.system_element_6431;
					.system_element_6432
				;;

				.system_element_6431
				=> .system_element_1523: .system_element_6433
				(*
					=> .system_element_1523: .system_element_6434;;
				*);;

				.system_element_6435
				<= .system_element_1523: 
					.system_element_6431;
					.system_element_6432
				;;
			*];;
			=> nrel_note: [<p>Наследование предметных областей позволяет использовать описанные логики и их компоненты при описании любых логик. Базовые понятия позволяют разработчикам интеллектуальной системы добавлять новые логики. Для реализации конкретной логической модели решения задач необходимо создать предметную область, которая будет дочерней по отношению к <i>Предметной области логических моделей решения задач</i> и предметной области некоторого <i>логического языка</i>, например, языка логики высказываний, языка логики предикатов, языка нечеткой логики и других.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);;
	*);;

	.system_element_6436
	<- .system_element_6393;;

	.system_element_6437
	<= nrel_inclusion: .system_element_6438;
	=> nrel_note: [<p><i>база знаний</i> каждой <i>системы программирования Пролог</i> содержит информацию в виде предикатов. В логическом программировании, реализованном в <i>системе программирования Пролог</i>, используется только одно <i>правило вывода</i> --- правило резолюции. Задача пролог-программы заключается в том, чтобы доказать, является ли заданное целевое высказывание следствием из имеющихся формул и, если является, то каким образом был получен такой вывод. Когда пользователь задает вопрос <i>системе программирования Пролог</i>, система ищет соответствующие предикаты в базе знаний и, если они найдены, сравнивает их с заданными условиями. <i>система программирования Пролог</i> хорошо справляется с нетрудными задачами, однако ограничена лишь одним принципом логического вывода и не позволяет учитывать сложноструктурированные знания в различных видах логик.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);;

	.system_element_1084
	=> nrel_explanation: [<p><i>Предметная область логических формул, высказываний и формальных теорий</i> задает денотационную семантику логических формул, высказываний и формальных теорий и содержит формальную спецификацию понятий, необходимых для формирования логических формул и высказываний любых логик.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);;

	.system_element_6435
	=> nrel_note: [<p>Логические формулы и высказывания интерпретируется с помощью понятий, описанных в <i>Предметной области логических моделей решения задач</i>, включающую модель и реализацию абстрактных агентов, необходимых для решения логических задач.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	-> .system_element_6439: 
		.system_element_6440;
		.system_element_6441;
		.system_element_6442;
		.system_element_6443
	;;

	.system_element_6444
	<= .system_element_6445: .system_element_962;
	=> nrel_explanation: [<p><i><b>Язык SCL</b></i> -- подъязык <i>SC-кода</i> для записи логических утверждений. Над высказываниями <i>Языка SCL</i> можно проводить <i>логический вывод</i>.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> .system_element_35: .system_element_36;
	=> .system_element_35: .system_element_6411;;

	.system_element_6440
	=> nrel_idtf: [<p>вывод</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_note: [<p>Правильность умозаключений вводится и проверяется совершенно формально, без какой-либо связи с истинностью входящих в него посылок, то есть исключительно с точки зрения структуры рассуждения. С практической точки зрения самое важное свойство такой формальной правильности рассуждений заключается в следующем: если удалось доказать, пользуясь методами формальной логики, правильность рассуждения, и известно из опыта, что все используемые посылки истинны, то можно быть уверенным в истинности заключения. Истинность используемых посылок задается состоянием базы знаний.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> .system_element_35: .system_element_6412;
	=> nrel_note: [<p>Доказательство вывода формулы равносильно доказательству противоречивости вывода отрицания этой формулы. При использовании правила резолюции это особенно удобно использовать.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);;

	.system_element_6446
	=> nrel_note: [<p>Некоторые операции, необходимые в одной предметной области будут избыточными в другой. Например, в системе, решающей задачи по геометрии, химии и другим естественным наукам обоснованным будет использование дедуктивных методов вывода, поскольку решение задач в таких предметных областях основывается только на достоверных правилах. В системах же медицинской диагностики, к примеру, постоянно возникает ситуация, когда диагноз может быть поставлен только с некоторой долей уверенности и абсолютно достоверным ответ на поставленный вопрос быть не может. В связи с этим возникает необходимость использования различных <i>решателей задач</i> в различных системах, при этом их состав и возможности в конкретной системе определяется не только непосредственно разработчиком, а требует консультаций с экспертами в данной предметной области. Тем не менее основой для всех видов логик является классическая логика и наиболее общие ее методы распространяются на другие логики с некоторыми модификациями, уточнениями и ограничениями.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> .system_element_35: .system_element_6447;;
	*);;

	.system_element_1219
	=> nrel_inclusion: .system_element_6446
	(*
		=> nrel_explanation: [<p>Классический дедуктивный вывод является наиболее популярным при построении автоматических решателей задач, так как всегда дает достоверный результат. Дедуктивный вывод включает в себя прямой и обратный и логический вывод (принцип резолюции, процедуру Эрбрана и так далее), все виды силлогизмов и так далее.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
		=> .system_element_158: [<p>Всегда дает достоверный результат.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
		=> .system_element_237: [<p>Невозможность использования, когда отсутствуют достоверные знания.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
		=> .system_element_1196: 
			.system_element_6412;
			.system_element_6413
		;;
	*);
	=> nrel_inclusion: .system_element_6448
	(*
		=> .system_element_158: [<p>Предоставляет возможность в процессе решения использовать различные предположения, что делает его удобным для использования в слабоформализованных и трудноформализуемых предметных областях, например при построении систем медицинской диагностики.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
		=> .system_element_1196: 
			.system_element_6414;
			.system_element_6415
		;;
	*);
	=> nrel_inclusion: .system_element_6449
	(*
		=> nrel_note: [<p>Наилучшим считается такое объяснение, которое удовлетворяет специальным критериям, определяемым в зависимости от решаемой задачи и используемой формализации.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
		=> .system_element_1196: 
			.system_element_6416;
			.system_element_6417
		;;
	*);
	=> nrel_inclusion: .system_element_6450
	(*
		=> nrel_note: [<p>Импликативные высказывания могут рассматриваться как "если истинна посылка", то с некоторой вероятностью (часто или редко) истинно заключение, в отличие от классической логики, где зачастую используются статические предметные области и выражение "часто или редко" не применимо (корректно использовать только наречие "всегда").</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
		=> .system_element_1196: 
			.system_element_6418;
			.system_element_6419;
			.system_element_6420
		;;
	*);
	=> nrel_inclusion: .system_element_6451
	(*
		=> nrel_note: [<p>Вывод с умолчаниями применяется, в том числе, для того, чтобы оптимизировать процесс рассуждений, дополняя процесс достоверного вывода вероятностными предположениями в тех случаях, когда вероятность ошибки крайне мала.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
		=> .system_element_1196: 
			.system_element_6421;
			.system_element_6422
		;;
	*);
	=> nrel_inclusion: .system_element_6452
	(*
		=> nrel_note: [<p>Применение темпорального вывода является очень актуальным для нестатичных предметных областей, в которых истинность того или иного утверждения меняется со временем, что существенно влияет на ход решения какой-либо задачи. Следует отметить, что Язык SCL предоставляет все необходимые возможности для описания таких динамических предметных областей.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
		=> .system_element_1196: 
			.system_element_6423;
			.system_element_6424
		;;
	*);;

	knowledge_base
	=> nrel_explanation: [<p>База знаний интеллектуальной системы включает в себя как модель фактографических знаний о предметной области, для которой предназначена система, так и модель знаний, включающая в себя логические формулы об этой предметной области (аксиомы, теоремы и правила вывода).</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);;

	.system_element_6453
	=> nrel_idtf: [<p>scl-машина</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	<- .system_element_6454;
	<- .system_element_3064;
	=> nrel_note: [<p>Операции <i>scl-машины</i> соответствуют правилам <i>логического вывода</i>.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> .system_element_936: .system_element_6444;
	=> nrel_note: [<p>Семейство специализированных абстрактных графодинамических машин обработки знаний является формальным уточнением операционной семантики специализированных графовых языков представления знаний, каждому из которых соответствует одна или несколько абстрактных машин. Эти абстрактные машины соответствуют различным моделям решения задач, различным логикам, различным моделям правдоподобных рассуждений.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_note: [<p>Агент из семейства агентов логического вывода может представлять собой какое-либо правило вывода, которое можно применять для решения логической задачи. Кроме того, необходимы агенты для выполнения равносильных преобразований логической формулы (например, записать формулу эквиваленции как конъюнкцию двух дизъюнкций) и другие агенты, помогающие применять правила вывода на множестве формул языка логики.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> .system_element_35: .system_element_6425;;
	*);
	=> .system_element_35: .system_element_6411;;

	.system_element_6453
	=> nrel_abstract_sc_agent_decomposition: {
		.system_element_6455
		(*
			=> nrel_note: [<p>Задачей <i>Абстрактного sc-агента применения правила вывода</i> является применение заданного правила вывода с заданными логическими формулами.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
			=> .system_element_6457: .system_element_6456;;
			=> nrel_primary_initiation_condition: .system_element_6458;;
			=> .system_element_5490: <
				[<p>Проверка условия инициирования.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				[<p>Применение правила вывода.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
					=> nrel_explanation: [<p>Применение правила вывода заключается в проверке, существуют ли в sc-памяти структуры, соответствующие условию применения данного правила, и генерации sc-конструкций в соответствии с применяемым правилом.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;
				*)
			>;;
			=> nrel_note: [<p>В ходе работы агента автоматически выполняется процедура унификации: переменные соответствуют константам, константы соответствуют самим себе. Агент применения правила вывода зачастую используется в процессе работы агентов прямого логического вывода, обратного логического вывода и других агентов.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
			=> .system_element_785: .system_element_6459
			(*
				<=> nrel_semantic_equivalence: "file://images/sd_operat_sem_sc_logical_lang/Modus_ponens.png"
				(*
					<- concept_file;;
					=> nrel_format: format_png;;
				*);;
				=> nrel_note: [<p>Можно привести еще целый ряд высказываний, которые описывают общие свойства всевозможных формальных теорий, каждая из которых описывает ту или иную предметную область. Свойства всевозможных формальных теорий описываются в рамках специальной метатеории для которой совокупность всевозможных формальных теорий является описываемой предметной областью.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*);;
		*);
		.system_element_6460
		(*
			=> nrel_note: [<p>Задачей <i>Абстрактного sc-агента эквивалентных преобразований логической формулы</i> является применение некоторых правил, которые приводят логическую формулу в определенный вид.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
			=> .system_element_6457: .system_element_6461;;
			=> nrel_primary_initiation_condition: .system_element_6458;;
			=> .system_element_5490: <
				[<p>Проверка условия инициирования.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				[<p>Преобразование формулы из одной формы в другую.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
					=> nrel_note: [<p>При преобразовании никакие новые знания в sc-памяти с точки зрения исследуемой предметной области не генерируются.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;
				*)
			>;;
			=> nrel_note: [<p>Ответом данного агента является множество формул, эквивалентных по смыслу, но различных по форме представления. Такими формами могут быть, например, конъюнктивная нормальная форма или дизъюнктивная нормальная форма.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
			=> .system_element_3250: [<p>Логическая формула не всегда находится в той форме, которая доступна для применения того или иного правила вывода, однако может быть приведена к нужной форме</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);
		.system_element_6462
		(*
			=> nrel_note: [<p>Задачей <i>Абстрактного sc-агента прямого логического вывода</i> является генерации новых знаний на основе некоторых логических утверждений.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
			=> .system_element_6457: .system_element_6463;;
			=> nrel_primary_initiation_condition: .system_element_6458;;
			=> .system_element_5490: <
				[<p>Проверка условия инициирования.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				[<p>Процесс прямого логического вывода.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
					=> nrel_decomposition: {
						[<p>Применение правил вывода.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						[<p>Генерация новых знаний в sc-памяти.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						[<p>Проверка некоторого условия.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
							=> .system_element_203: [<p>Появление в sc-памяти sc-элементов из целевой sc-структуры.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*)
					};;
					=> .system_element_35: .system_element_6426;;
				*)
			>;;
			=> nrel_note: [<p>Входными аргументами такого агента является целевая структура, множество формул, которые используются в ходе вывода агентом применения правил вывода, множество правил вывода, входная структура и выходная структура. В результате выполнения агентом логического вывода действия, в sc-памяти формируется sc-структура, представляющая собой дерево решения. Это дерево состоит из последовательности узлов, представляющих собой примененные правила, которые привели к появлению в sc-памяти требуемых знаний. Такое дерево может быть пустым в случае, если требуемую структуру не удалось сгенерировать в ходе логического вывода.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
			=> .system_element_785: .system_element_6464
			(*
				<=> nrel_semantic_equivalence: "file://images/sd_operat_sem_sc_logical_lang/direct_inference_agent.png"
				(*
					<- concept_file;;
					=> nrel_format: format_png;;
				*);;
			*);;
		*);
		.system_element_6465
		(*
			=> nrel_note: [<p>Задачей <i>Абстрактного sc-агента обратного логического вывода</i> является проверка гипотез. Некоторые гипотезы могут быть опровергнуты, однако извлекая причины того, почему гипотеза опровергнута, можно изменить посылку гипотезы так, чтобы создать новую гипотезу, которая впоследствии может стать полезной теоремой.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
			=> .system_element_6457: .system_element_6466;;
			=> nrel_primary_initiation_condition: .system_element_6458;;
			=> .system_element_5490: <
				[<p>Проверка условия инициирования.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				[<p>Процесс обратного логического вывода.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
					=> nrel_explanation: [<p>Процесс <i>обратного логического вывода</i>, схож с процессом <i>прямого логического вывода</i> за исключением того, что поиск правил основывается не на посылках формул, а на их следствиях.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;
					=> .system_element_35: .system_element_6426;;
				*)
			>;;
			=> nrel_note: [<p>Ответом данного агента будет дерево вывода, которое показывает, с использованием каких правил можно доказать или опровергнуть выдвинутую гипотезу.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*)
	};
	-> .system_element_6467
	(*
		=> nrel_idtf: [<p>Реализация scl-машины</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
		=> .system_element_246: [<p>https://github.com/ostis-ai/scl-machine</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
	*);;

	.system_element_6460
	=> nrel_abstract_sc_agent_decomposition: {
		.system_element_6468;
		.system_element_6469;
		.system_element_6470;
		.system_element_6471;
		.system_element_6472;
		.system_element_6473;
		.system_element_6474;
		.system_element_6475;
		.system_element_6476;
		.system_element_6477;
		.system_element_6478;
		.system_element_6479
	};;

	.system_element_6480
	=> .system_element_158: [<p>Любая формула семантически эквивалентна некоторой формуле в конъюнктивной нормальной форме, в связи с этим иногда удобно применять правило резолюции.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_note: [<p>Используя законы Де Моргана можно получить формулы, пригодные для использования правила резолюции. С помощью правила резолюции можно эффективно доказывать формулы <i>Языка логики высказываний</i>.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> .system_element_237: [<p>Ничего принципиально нового правило резолюции не привносит, поскольку формула A ⇒ B  равносильно ¬ A  B и из выводимости A и A → B следует выводимость B.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> .system_element_203: [<p>Если в любых двух дизъюнктах C_1 и C_2 имеется пара формул A и ¬ A, то можно сформировать новый дизъюнкт из оставшихся частей изначальных дизъюнктов.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> .system_element_203: .system_element_6481
	(*
		<=> nrel_semantic_equivalence: "file://images/sd_operat_sem_sc_logical_lang/resolution.png"
		(*
			<- concept_file;;
			=> nrel_format: format_png;;
		*);;
	*);;

	.system_element_6453
	=> nrel_using_example: .system_element_6482
	(*
		=> .system_element_6484: .system_element_6483;;
		=> .system_element_785: .system_element_6485
		(*
			<=> nrel_semantic_equivalence: "file://images/sd_operat_sem_sc_logical_lang/resolution_formulas_example.png"
			(*
				<- concept_file;;
				=> nrel_format: format_png;;
			*);;
			=> nrel_note: [<p>Каждая неатомарная формула на рисунке принадлежит некоторой формальной теории, то есть считается истинной.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
			=> nrel_note: [<p>Структура A представляет собой атомарную логическую формулу, которая обозначает победу команды A, структура A' представляет формулу, обозначающую торжество города A'. Соответственно, то же самое для структур B и B'.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);;
		=> .system_element_3668: <
			[<p>Привести импликацию в конъюнктивную нормальную форму по формуле <i>Конъюнктивная нормальная форма для импликации</i> и эквиваленцию по определению.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
				=> .system_element_785: .system_element_6486
				(*
					<=> nrel_semantic_equivalence: "file://images/sd_operat_sem_sc_logical_lang/conjunction_implication_rule.png"
					(*
						<- concept_file;;
						=> nrel_format: format_png;;
					*);;
				*);;
			*);
			[<p>Применить отрицание к формуле, которую необходимо вывести (эквиваленция).</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
				=> .system_element_785: .system_element_6487
				(*
					<=> nrel_semantic_equivalence: "file://images/sd_operat_sem_sc_logical_lang/resolution_prepared_formulas_example.png"
					(*
						<- concept_file;;
						=> nrel_format: format_png;;
					*);;
				*);;
			*);
			[<p>Применяя правило резолюции для преобразованных формул получается пустой дизъюнкт, что говорит о противоречивости множества формул и доказывает формулу эквиваленции о том, что город B' торжествует тогда и только тогда, когда не будет торжествовать город A'.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*)
		>
		(*
			=> .system_element_785: .system_element_6488
			(*
				<=> nrel_semantic_equivalence: "file://images/sd_operat_sem_sc_logical_lang/resolution_inference.png"
				(*
					<- concept_file;;
					=> nrel_format: format_png;;
				*);;
			*);;
		*);;
	*);;
*];;
