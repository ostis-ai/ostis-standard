.system_element_5534
=> nrel_inclusion: [*

	.system_element_5790
	<- subject_domain;
	-> .system_element_1835: 
		action_in_sc_memory;
		abstract_sc_agent;
		sc_agent
	;
	-> .system_element_112: 
		abstract_sc_agent_is_not_implemented_on_the_scp_language;
		abstract_sc_agent_implemented_on_the_scp_language;
		.system_element_5791;
		non_atomic_abstract_sc_agent;
		atomic_abstract_sc_agent;
		platform_independent_abstract_sc_agent;
		platform_dependent_abstract_sc_agent;
		inside_abstract_sc_agent;
		effector_abstract_sc_agent;
		receptor_abstract_sc_agent;
		abstract_sc_agent_is_not_implemented_on_the_scp_language;
		abstract_sc_agent_implemented_on_the_scp_language;
		abstract_sc_agent_of_interpretation_of_scp_program;
		abstract_program_sc_agent;
		abstract_program_sc_agent_implemented_on_the_scp_language;
		abstract_sc_metaagent;
		sc_agent;
		active_sc_agent;
		.system_element_5792;
		lock_type;
		total_lock;
		lock_for_any_change;
		lock_for_deleting
	;
	-> .system_element_748: 
		nrel_abstract_sc_agent_decomposition;
		nrel_sc_agent_key_sc_elements;
		nrel_sc_agent_program;
		nrel_primary_initiation_condition;
		nrel_initiation_condition_and_result;
		nrel_lock
	;;

	.system_element_5793
	=> .system_element_196: 
		[<p>В основе решателя задач каждой <i>ostis-системы</i> лежит многоагентная система, агенты которой взаимодействуют между собой <u>только</u>(!) через общую для них <i>sc-память</i> посредством спецификации в этой памяти выполняемых ими <i>действий в sc-памяти</i>. При этом пользователи <i>ostis-системы</i> также считаются агентами этой системы. Кроме того, <i>sc-агенты</i> делятся на внутренние, рецепторные и эффекторные. Взаимодействие между агентами через общую <i>sc-память</i> сводится к следующим видам действий: К использованию общедоступной для соответствующей группы sc-агентов части хранимой базы знаний.
		<li> К формированию (генерации) новых фрагментов базы знаний и/или к корректировке (редактированию) каких-либо фрагментов доступной части базы знаний.
		<li> К интеграции (погружению) новых и/или обновленных фрагментов в состав доступной части базы знаний.Подчеркнем, что sc-агенты не общаются между собой напрямую путем отправки сообщений, как это делается в большинстве современных подходов к построению многоагентных систем. Кроме того, sc-агенты имеют доступ к общей для них базе знаний за счет чего гарантируется семантическая совместимость (взаимопонимание) между агентами, включая и пользователей ostis-систем.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Пользователь <i>ostis-системы</i> не может сам непосредственно выполнить какое-либо действие в <b>sc-памяти</b>, но он может средствами пользовательского интерфейса инициировать построение (генерацию, формирование в <i>sc-памяти</i>) <i>sc-текста</i>, являющегося спецификацией <i>действия в <b>sc-памяти</b></i>, выполняемого либо одним <i>атомарным sc-агентом</i> за один акт, либо одним <i>атомарным sc-агентом</i> за несколько актов, либо коллективом <i>sc-агентов</i> (<i>неатомарным sc-агентом</i>). В спецификации каждого такого <i>действия в sc-памяти</i>, инициированного пользователем, этот пользователь указывается как заказчик этого действия. Таким образом, пользователь <i>ostis-системы</i> дает поручения (задания, команды) <i>sc-агентам</i> этой системы на выполнение различных специфицируемых им действий в <i>sc-памяти</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Каждый <i>sc-агент</i>, выполняя некоторое <i>действие в sc-памяти</i>, должен помнить, что <i>sc-память</i>, над которой он работает, является общим ресурсом не только для него, но и для всех остальных <i><b>sc-агентов</b></i>, работающих над этой же <i>sc-памятью</i>. Поэтому <i>sc-агент</i> должен соблюдать определенную этику поведения в коллективе таких <i>sc-агентов</i>, которая должна минимизировать помехи, которые он создает другим <i>sc-агентам</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Деятельность каждого агента <i>ostis-системы</i> дискретна и представляет собой множество элементарных действий (актов). При этом при выполнении каждого акта агент может устанавливать блокировки нескольких типов на фрагменты базы знаний. Указанные блокировки позволяют запретить другим агентам изменять указанный фрагмент базы знаний или вообще сделать его невидимым для других агентов. Блокировки устанавливаются самим агентом при выполнении соответствующего акта и снимаются им же на последнем этапе выполнения этого акта или раньше, если это возможно.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Если некий <i>sc-агент</i> выполняет некоторое <i>действие в sc-памяти</i>, то он на время выполнения этого действия может: Запретить другим <i>sc-агентам</i> изменять состояние некоторых sc-элементов, хранимых в <i>sc-памяти</i> --- удалять их, изменять тип.
		<li> Запретить другим <i>sc-агентам</i> добавлять или удалять элементы некоторых множеств, обозначаемых соответствующими <i>sc-узлами</i>.
		<li> Запретить другим <i>sc-агентам</i> доступ на просмотр некоторых <i>sc-элементов</i>, то есть эти <i><b>sc-элементы</b></i> становятся полностью невидимыми (полностью заблокированными) для других <i>sc-агентов</i>, но только на время выполнения соответствующего действия.Указанные блокировки должны быть полностью сняты до завершения выполнения соответствующего действия. Подчеркнем, что в число <i>sc-элементов</i>, блокируемых на время выполнения некоторого действия, в основном входят атомарные и неатомарные связки, и не должны входить <i>sc-узлы</i>, обозначающие бесконечные классы каких-либо сущностей, и, тем более, sc-узлы, обозначающие различные понятия (ключевые классы различных предметных областей).Этичное (неэгоистичное) поведение <i>sc-агента</i>, касающееся блокировки <i>sc-элементов</i> (то есть ограничения к ним доступа другим <i>sc-агентам</i>) предполагает соблюдение следующих правил: Не следует блокировать больше <i>sc-элементов</i>, чем это необходимо для решения задачи.
		<li> Как только для какого-либо <i>sc-элемента</i> необходимость его блокировки отпадает до завершения выполнения соответствующего действия, этот <i>sc-элемент</i> желательно сразу деблокировать (снять блокировку).Для того, чтобы <i>sc-агент</i> имел возможность работы с каким-либо произвольным <i>sc-элементом</i>, он должен либо убедиться в том, что этот <i>sc-элемент</i> не входит во фрагмент базы знаний, входящий в <i>полную блокировку</i>, либо убедиться в том, что эта блокировка не установлена самим этим агентом.Особой группой полностью заблокированных <i>sc-элементов</i> (на время выполнения действия <i><b>sc-агентом</b></i>) являются вспомогательные <i>sc-элементы</i> (леса), создаваемые только на время выполнения этого действия. Эти sc-элементы в конце выполнения действия должны не деблокироваться, а удаляться.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Если <i>действие в sc-памяти</i>, выполняемое <i>sc-агентом</i>, завершилось (т.е. стало прошлой сущностью), то <i>sc-агент</i> оформляет результат этого <i>действия</i>, указывая (1) удаленные <i>sc-элементы</i> и (2) сгенерированные sc-элементы. Это необходимо, если по каким-либо причинам придется сделать откат этого <i>действия</i>, т.е возвратиться к состоянию базы знаний до выполнения указанного <i>действия</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*)
	;;

	.system_element_5794
	=> nrel_inclusion: [*

		action_in_sc_memory
		=> nrel_idtf: [<p>внутреннее действие ostis-системы</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>действие, выполняемое в sc-памяти</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>действие, выполняемое в абстрактной унифицированной семантической памяти</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>действие, выполняемое машиной обработки знаний ostis-системы</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>действие, выполняемое агентом или коллективом агентов ostis-системы</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>информационный процесс над базой знаний, хранимой в sc-памяти</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>процесс решения информационной задачи в sc-памяти</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		<= nrel_inclusion: process_in_sc_memory;
		=> nrel_explanation: [<p>Каждое <b><i>действие в sc-памяти</i></b> обозначает некоторое преобразование, выполняемое некоторым <i>sc-агентом</i> (или коллективом <i>sc-агентов</i>) и ориентированное на преобразование <i>sc-памяти</i>. Спецификация действия после его выполнения может быть включена в протокол решения некоторой задачи.Преобразование состояния базы знаний включает, в том числе и информационный поиск, предполагающий (1) локализацию в базе знаний ответа на запрос, явное выделение структуры ответа и (2) трансляцию ответа на некоторый внешний язык.Во множество <b><i>действий в sc-памяти</i></b> входят знаки действий самого различного рода, семантика каждого из которых зависит от конкретного контекста, т.е. ориентации действия на какие-либо конкретные объекты и принадлежности действия какому-либо конкретному классу действий.Следует четко отличать:
		<ul>
			<li> каждое конкретное <b><i>действие в sc-памяти</i></b>, представляющее собой некоторый переходный процесс, переводящий sc-память из одного состояния в другое;
			<li> каждый тип <b><i>действий в sc-памяти</i></b>, представляющий собой некоторый класс однотипных (в том или ином смысле) действий;
			<li> sc-узел, обозначающий некоторое конкретное <b><i>действие в sc-памяти</i></b>;
			<li> sc-узел, обозначающий структуру, которая является описанием, спецификацией, заданием, постановкой соответствующего действия.</li>
		<ul></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_inclusion: action_in_sc_memory_initiated_by_question;
		=> nrel_inclusion: .system_element_5795;
		=> nrel_inclusion: action_of_ostis_system_mode_setting;
		=> nrel_inclusion: action_of_editing_file_stored_in_sc_memory;
		=> nrel_inclusion: action_of_interpreting_program_stored_in_sc_memory;;

		action_in_sc_memory_initiated_by_question
		=> nrel_idtf: [<p>действие, направленное на формирование ответа на поставленный вопрос</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_inclusion: .system_element_5796;
		=> nrel_inclusion: .system_element_5797
		(*
			=> nrel_inclusion: act_verify_the_desired_structure
			(*
				=> nrel_inclusion: action_to_determine_truth_or_falsity_of_designated_logical_statement;;
				=> nrel_inclusion: action_to_determine_correctness_or_incorrectness_of_designated_structure;;
				=> nrel_inclusion: action_to_form_structure_describing_incorrectnesses_existing_in_designated_structure;;
			*);;
			=> nrel_inclusion: .system_element_5798
			(*
				=> nrel_inclusion: action_to_determine_positivity_or_negativity_of_designated_sc_arc_of_belonging_or_not_belonging;;
			*);;
			=> nrel_inclusion: action_to_form_semantic_neighborhood
			(*
				=> nrel_inclusion: action_to_form_full_semantic_neighborhood_of_designated_entity;;
				=> nrel_inclusion: action_to_form_basic_semantic_neighborhood_of_designated_entity;;
				=> nrel_inclusion: action_to_form_local_semantic_neighborhood_of_designated_entity;;
			*);;
			=> nrel_inclusion: action_to_form_structure_describing_connections_between_designated_entities
			(*
				=> nrel_inclusion: action_to_form_structure_describing_similarities_of_designated_entities;;
				=> nrel_inclusion: action_to_form_structure_describing_differences_of_designated_entities;;
			*);;
			=> nrel_inclusion: action_to_form_structure_describing_method_of_designated_task_solution;;
			=> nrel_inclusion: action_to_form_plan_of_answer_to_selected_question_generation;;
			=> nrel_inclusion: action_to_form_execution_history_of_designated_action;;
			=> nrel_inclusion: action_to_form_argumentation_of_designated_solution_correctness;;
			=> nrel_inclusion: action_to_verify_argumentation_of_designated_solution_correctness;;
			=> nrel_inclusion: action_aimed_at_determination_of_designated_entity_temporal_characteristics;;
			=> nrel_inclusion: action_aimed_at_determination_of_designated_entity_extensive_characteristics;;
		*);;

		action_of_kb_editing
		=> nrel_inclusion: .system_element_5799;
		=> nrel_inclusion: action_to_correct_mistakes_in_given_structure;
		=> nrel_inclusion: .system_element_5800;
		=> nrel_inclusion: question_merge_two_elements;
		=> nrel_inclusion: action_to_include_set
		(*
			=> nrel_idtf: [<p>сделать все элементы множества <b><i>Si</i></b> явно принадлежащими множеству <b><i>Sj</i></b>, то есть сгенерировать соответствующие sc-дуги принадлежности</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);
		=> nrel_inclusion: action_of_generation_sc_elements
		(*
			=> nrel_inclusion: action_of_generation_one_of_arguments_of_that_is_some_generalized_structure
			(*
				=> nrel_inclusion: .system_element_5801;;
			*);;
			=> nrel_inclusion: action_to_generate_sc_element_of_selected_type
			(*
				=> nrel_inclusion: action_to_generate_sc_connector_of_selected_type;;
				=> nrel_inclusion: action_to_generate_sc_node_of_selected_type;;
			*);;
			=> nrel_inclusion: action_to_generate_file_with_selected_content;;
			=> nrel_inclusion: .system_element_5802;;
		*);
		=> nrel_inclusion: action_to_renew_concepts
		(*
			=> nrel_idtf: [<p>действие. заменить неосновные понятия на их определения через основные понятия</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);
		=> nrel_inclusion: .system_element_5803
		(*
			=> nrel_inclusion: .system_element_5804
			(*
				=> nrel_inclusion: .system_element_5805;;
			*);;
			=> nrel_inclusion: action_to_integrate_selected_structure_into_current_state_of_kb;;
		*);
		=> nrel_inclusion: .system_element_5806
		(*
			=> nrel_inclusion: .system_element_5807;;
			=> nrel_inclusion: .system_element_5808;;
		*);
		=> nrel_inclusion: action_of_deleting_sc_elements
		(*
			=> nrel_inclusion: action_to_delete_selected_sc_elements
			(*
				=> nrel_inclusion: action_to_delete_sc_elements_that_are_contained_in_selected_structure_and_that_arent_keynodes_of_any_sc_agents;;
			*);;
		*);;

		question_merge_two_elements
		=> nrel_idtf: [<p>действие. совместить два указанных sc-элемента</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>действие. склеить два указанных sc-элемента</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_subdividing: {
			action_to_physically_identify_two_selected_sc_elements;
			action_to_logically_identify_two_selected_sc_elements
		};;

		question_merge_two_elements
		=> nrel_explanation: [<p>Каждое <b><i>действие. отождествить два указанных sc-элемента</i></b> может быть выполнено как <i>действие. физически отождествить два указанных sc-элемента</i> или <i>действие. логически отождествить два указанных sc-элемента</i>. В случае логического отождествления в протоколе деятельности агентов сохраняется само действие с его спецификацией, включающей обязательное указание того, какие элементы были сгенерированы, а какие удалены. В случае физического отождествления протокол действия не сохраняется.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		action_to_renew_concepts
		=> nrel_idtf: [<p>действие. заменить некоторое множество понятий на другое множество понятий</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_explanation: [<p>Каждое <b><i>действие. обновить понятия</i></b> обозначает переход от какой-то группы понятий, использовавшихся ранее, к другой группе понятий, которые будут использоваться вместо первых и станут <i>основными понятиями</i>. В общем случае <b><i>действие. обновить понятия</i></b> состоит из следующих этапов:
		<ul>
			<li> определить заменяемые понятия на основе заменяющих;
			<li> внести соответствующие изменения в программы sc-агентов, ключевыми узлами которых являются обновляемые понятия;
			<li> заменить все конструкции в базе знаний, содержащие заменяемые понятия, в соответствии с определениями этих понятий через заменяющие их понятия;
			<li> при необходимости, <i>sc-элементы</i>, обозначающие замененные таким образом понятия, могут быть полностью выведены из текущего состояния базы знаний.</li>
		<ul>Первым аргументом (входящим в знак <i>действия</i> под атрибутом <i>1'</i>) <b><i>действия. обновить понятия</i></b> является знак множества <i>sc-узлов</i>, обозначающих заменяемые понятия, вторым (входящим в знак <i>действия</i> под атрибутом <i>2'</i>) --- знак множества <i>sc-узлов</i>, обозначающих заменяющие понятия. В общем случае любое или оба этих множества могут быть <i>синглетонами</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		action_to_delete_selected_sc_elements
		=> nrel_subdividing: {
			action_to_physically_delete_selected_sc_elements;
			action_to_logically_delete_selected_sc_elements
		};
		=> nrel_explanation: [<p>Каждое <b><i>действие. удалить указанные sc-элементы</i></b> может быть выполнено как <i>действие. физически удалить указанные sc-элементы</i> или <i>действие. логически удалить указанные sc-элементы</i>. В случае логического удаления в протоколе деятельности агентов сохраняется само действие с его спецификацией, включающей обязательное указание того, какие элементы были удалены, т.е. по сути, элементы просто исключаются из текущего состояния базы знаний.В случае физического удаления протокол действия не сохраняется. В случае удаления какого-либо <i>sc-элемента</i>, инцидентные ему <i>связки</i>, в том числе <i>sc-коннекторы</i>, так же удаляются.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		action_to_integrate_selected_structure_into_current_state_of_kb
		=> nrel_explanation: [<p>Для того, чтобы выполнить <b><i>действие. интегрировать указанную структуру в текущее состояние базы знаний</i></b>, необходимо склеить <i>sc-элементы</i>, входящие в интегрируемую <i>структуру</i> с синонимичными им <i>sc-элементами</i>, входящими в текущее состояние базы знаний, заменить неиспользуемые (например, устаревшие) понятия, входящие в интегрируемую <i>структуру</i>, на используемые (т.е. заменить неиспользуемые понятия на их определения через используемые), явно включить все элементы интегрируемой <i>структуры</i> в число элементов утвержденной части базы знаний и явно включить все элементы интегрируемой <i>структуры</i> в число элементов одного из атомарных разделов утвержденной части базы знаний.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		action_of_interpreting_program_stored_in_sc_memory
		=> nrel_inclusion: question_scp_interpretation_request;;

		task_solved_in_sc_memory
		<= nrel_inclusion: task;
		=> nrel_idtf: [<p>спецификация действия, выполняемого в sc-памяти</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>структура, являющая описанием (постановкой, заданием) соответствующего действия в sc-памяти, которое обладает достаточной полнотой для выполения указанного действия</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>семантическая окрестность некоторого действия в sc-памяти, обеспечивающая достаточно полное задание этого действия</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		actions_class
		=> nrel_inclusion: .system_element_5809
		(*
			<= nrel_set_of_subsets: action_in_sc_memory;;
		*);
		=> nrel_subdividing: {
			.system_element_5810
			(*
				=> nrel_idtf: [<p>класс автономных действий</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*);
			.system_element_5811
			(*
				=> nrel_idtf: [<p>класс неавтономных действий</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*)
		};;

		.system_element_5810
		=> nrel_explanation: [<p>Каждое <i>действие</i>, принадлежащее некоторому конкретному <i>классу логически атомарных действий</i>, обладает двумя необходимыми свойствами:

		<ul>

			<li> Выполнение действия не зависит от того, является ли указанное действие частью декомпозиции более общего действия. При выполнении данного действия также не должен учитываться тот факт, что данное действие предшествует каким-либо другим действиям или следует за ними (что явно указывается при помощи отношения <i>последовательность действий*</i>).

			<li> Указанное действие должно представлять собой логически целостный акт преобразования, например, в семантической памяти. Такое действие по сути является транзакцией, т. е. результатом такого преобразования становится новое состояние преобразуемой системы, а выполняемое действие должно быть либо выполнено полностью, либо не выполнено совсем, частичное выполнение не допускается.</li>

		<ul>В то же время логическая атомарность не запрещает декомпозировать выполняемое действие на более частные, каждое из которых, в свою очередь, также будет являться логически атомарным.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_inclusion: .system_element_5812
		(*
			=> nrel_explanation: [<p>На логически атомарные действия предлагается делить всю деятельность, направленную на решение каких-либо задач ostis-системой. Соответственно <i>решатель задач ostis-системы</i> предлагается делить на компоненты, соответствующие таким <i>классам логически атомарных действий в sc-памяти</i>, что является основой для обеспечения его <i>модифицируемости</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);;
	*];;

	.system_element_5813
	=> nrel_inclusion: [*

		sc_agent
		=> nrel_idtf: [<p>единственный вид <i>субъектов</i>, выполняющих преобразования в <i><i>sc-памяти</i></i></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p><i>субъект</i>, способный выполнять <i>действия в sc-памяти</i>, принадлежащие некоторому определенному <i>классу логически атомарных действий</i></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_explanation: [<p>Логическая атомарность выполняемых sc-агентом действий предполагает, что каждый sc-агент реагирует на соответствующий ему класс ситуаций и/или событий, происходящих в sc-памяти, и осуществляет определенное преобразование sc-текста, находящегося в семантической окрестности обрабатываемой ситуации и/или события. При этом каждый sc-агент в общем случае не имеет информацию о том, какие еще sc-агенты в данный момент присутствуют в системе и осуществляет взаимодействие в другими sc-агентами исключительно посредством формирования некоторых конструкций (как правило  спецификаций действий) в общей sc-памяти. Таким сообщением может быть, например, вопрос, адресованный другим sc-агентам в системе (заранее не известно, каким конкретно), или ответ на поставленный другими sc-агентами вопрос (заранее не известно, каким конкретно). Таким образом, каждый sc-агент в каждый момент времени контролирует только фрагмент базы знаний в контексте решаемой данным агентом задачи, состояние всей остальной базы знаний в общем случае непредсказуемо для sc-агента.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		abstract_sc_agent
		=> nrel_note: [<p>Поскольку предполагается, что копии одного и того же <i>sc-агента</i> или функционально эквивалентные <i>sc-агенты</i> могут работать в разных ostis-системах, будучи при этом физически разными sc-агентами, то целесообразно рассматривать свойства и классификацию не sc-агентов, а классов функционально эквивалентных sc-агентов, которые будем называть <i>абстрактными sc-агентами</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_explanation: [<p>Под <b><i>абстрактным sc-агентом</i></b> понимается некоторый класс функционально эквивалентных <i>sc-агентов</i>, разные экземпляры (т.е. представители) которого могут быть реализованы по-разному. Каждый <b><i>абстрактный sc-агент</i></b> имеет соответствующую ему спецификацию. В спецификацию каждого <b><i>абстрактного sc-агента</i></b> входит:
		<ul>
			<li> указание ключевых <i>sc-элементов</i> этого <i>sc-агента</i>, т.е. тех <i>sc-элементов</i>, хранимых в <i>sc-памяти</i>, которые для данного <i>sc-агента</i> являются точками опоры;
			<li> формальное описание условий инициирования данного <i>sc-агента</i>, т.е. тех <i>ситуаций</i> в <i>sc-памяти</i>, которые инициируют деятельность данного <i>sc-агента</i>;
			<li> формальное описание первичного условия инициирования данного <i>sc-агента</i>, т.е. такой ситуации в <i>sc-памяти</i>, которая побуждает <i>sc-агента</i> перейти в активное состояние и начать проверку наличия своего полного условия инициирования (для <i>внутренних абстрактных sc-агентов</i>);
			<li> строгое, полное, однозначно понимаемое описание деятельности данного <i>sc-агента</i>, оформленное при помощи каких-либо понятных, общепринятых средств, не требующих специального изучения, например, на естественном языке;
			<li> описание результатов выполнения данного <i>sc-агента</i>.</li>
		<ul></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_subdividing: {
			non_atomic_abstract_sc_agent;
			atomic_abstract_sc_agent
		};
		=> nrel_subdividing: {
			inside_abstract_sc_agent;
			effector_abstract_sc_agent;
			receptor_abstract_sc_agent
		};
		=> nrel_subdividing: {
			abstract_sc_agent_is_not_implemented_on_the_scp_language;
			abstract_sc_agent_implemented_on_the_scp_language
		};
		=> nrel_subdividing: {
			abstract_sc_agent_of_interpretation_of_scp_program;
			abstract_program_sc_agent;
			abstract_sc_metaagent
		};
		=> nrel_subdividing: {
			platform_dependent_abstract_sc_agent
			(*
				=> nrel_inclusion: abstract_sc_agent_is_not_implemented_on_the_scp_language;;
			*);
			platform_independent_abstract_sc_agent
		};;

		abstract_sc_agent_is_not_implemented_on_the_scp_language
		=> nrel_idtf: [<p>абстрактный sc-агент, который не может быть реализован на платформенно-независимом уровне</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_subdividing: {
			effector_abstract_sc_agent;
			receptor_abstract_sc_agent;
			abstract_sc_agent_of_interpretation_of_scp_program
		};;

		abstract_sc_agent_implemented_on_the_scp_language
		=> nrel_idtf: [<p>абстрактный sc-агент, который может быть реализован на платформенно-независимом уровне</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_subdividing: {
			abstract_sc_metaagent;
			abstract_program_sc_agent_implemented_on_the_scp_language
		};;

		abstract_program_sc_agent
		=> nrel_subdividing: {
			effector_abstract_sc_agent;
			receptor_abstract_sc_agent;
			abstract_program_sc_agent_implemented_on_the_scp_language
		};;

		non_atomic_abstract_sc_agent
		=> nrel_explanation: [<p>Под <b><i>неатомарным абстрактным sc-агентом</i></b> понимается <i>абстрактный sc-агент</i>, который декомпозируется на коллектив более простых <i>абстрактных sc-агентов</i>, каждый из которых в свою очередь может быть как <i>атомарным абстрактным sc-агентом</i>, так и <b><i>неатомарным абстрактным sc-агентом</i></b>. При этом в каком-либо варианте <i>декомпозиции абстрактного sc-агента*</i> дочерний <b><i>неатомарный абстрактный sc-агент</i></b> может стать <i>атомарным абстрактным sc-агентом</i> и реализовываться соответствующим образом.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		atomic_abstract_sc_agent
		=> nrel_explanation: [<p>Под <b><i>атомарным абстрактным sc-агентом</i></b> понимается <i>абстрактный sc-агент</i>, для которого уточняется платформа его реализации, т.е. существует соответствующая связка отношения <i>программа sc-агента*</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_subdividing: {
			platform_independent_abstract_sc_agent;
			platform_dependent_abstract_sc_agent
		};;

		platform_independent_abstract_sc_agent
		=> nrel_explanation: [<p>К <b><i>платформенно-независимым абстрактным <b>sc-агентам</b></i></b> относят <i>атомарные абстрактные sc-агенты</i>, реализованные на базовом языке программирования Технологии OSTIS, т.е. на <i>Языке SCP</i>.При описании <b><i>платформенно-независимых абстрактных sc-агентов</i></b> под платформенной независимостью понимается платформенная независимость с точки зрения Технологии OSTIS, т.е реализация на специализированном языке программирования, ориентированном на обработку семантических сетей (<i>Языке SCP</i>), поскольку <i>атомарные sc-агенты</i>, реализованные на указанном языке могут свободно переноситься с одной платформы интерпретации <i>sc-моделей</i> на другую. При этом языки программирования, традиционно считающиеся платформенно-независимыми, в данном случае не могут считаться таковыми.Существуют <i>sc-агенты</i>, которые принципиально не могут быть реализованы на платформенно-независимом уровне, например, собственно <i>sc-агенты</i> интерпретации <i>sc-моделей</i> или рецепторные и эффекторные <i>sc-агенты</i>, обеспечивающие взаимодействие с внешней средой.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		platform_dependent_abstract_sc_agent
		=> nrel_explanation: [<p>К <b><i>платформенно-зависимым абстрактным sc-агентам</i></b> относят <i>атомарные абстрактные sc-агенты</i>, реализованные ниже уровня sc-моделей, т.е. не на <i>Языке SCP</i>, а на каком-либо другом языке описания программ.Существуют <i>sc-агенты</i>, которые принципиально должны быть реализованы на платформенно-зависимом уровне, например, собственно <i>sc-агенты</i> интерпретации <i>sc-моделей</i> или рецепторные и эффекторные <i>sc-агенты</i>, обеспечивающие взаимодействие с внешней средой.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		inside_abstract_sc_agent
		=> nrel_explanation: [<p>Каждый <b><i>внутренний абстрактный sc-агент</i></b> обозначает класс <i>sc-агентов</i>, которые реагируют на события в <i>sc-памяти</i> и осуществляют преобразования исключительно в рамках этой же <i>sc-памяти</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		effector_abstract_sc_agent
		=> nrel_explanation: [<p>Каждый <b><i>эффекторный абстрактный sc-агент</i></b> обозначает класс <i>sc-агентов</i>, которые реагируют на события в <i>sc-памяти</i> и осуществляют преобразования во внешней относительно данной <i>ostis-системы</i> среде.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		receptor_abstract_sc_agent
		=> nrel_explanation: [<p>Каждый <b><i>рецепторный абстрактный sc-агент</i></b> обозначает класс <i>sc-агентов</i>, которые реагируют на события во внешней относительно данной <i>ostis-системы</i> среде и осуществляют преобразования в памяти данной системы.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		abstract_sc_agent_is_not_implemented_on_the_scp_language
		=> nrel_explanation: [<p>Каждый <b><i>абстрактный sc-агент, не реализуемый на Языке SCP</i></b> должен быть реализован на уровне платформы интерпретации sc-моделей, в том числе, аппаратной. К таким <i>абстрактным sc-агентам</i> относятся абстрактные sc-агенты интерпретации scp-программ, а также эффекторные и рецепторные абстрактные sc-агенты.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		abstract_sc_agent_implemented_on_the_scp_language
		=> nrel_explanation: [<p>Каждый <b><i>абстрактный sc-агент, реализуемый на Языке SCP</i></b> может быть реализован на Языке SCP, то есть на платформенно-независимом уровне, но при необходимости может реализовываться и на уровне платформы, например, с целью повышения производительности.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		abstract_sc_agent_of_interpretation_of_scp_program
		=> nrel_explanation: [<p>К <b><i>абстрактным sc-агентам интерпретации scp-программ</i></b> относятся нереализуемые на платформенно-независимом уровне <i>абстрактные sc-агенты</i>, обеспечивающие интерпретацию <i>scp-программ</i> и <i>scp-метапрограмм</i>, в том числе создание <i>scp-процессов</i>, собственно интерпретацию <i>scp-операторов</i>, а также другие вспомогательные действия. По сути, агенты данного класса обеспечивают работу sc-агентов более высоких уровней (программных sc-агентов и sc-метаагентов), реализованных на Языке SCP, в частности, обеспечивают соблюдение указанными агентами общих принципов синхронизации.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		abstract_program_sc_agent
		=> nrel_explanation: [<p>К <b><i>абстрактным программным sc-агентам</i></b> относятся все <i>абстрактные sc-агенты</i>, обеспечивающие основной функционал системы, то есть ее возможность решать те или иные задачи. Агенты данного класса должны работать в соответствии с общими принципами синхронизации деятельности субъектов в sc-памяти.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		abstract_sc_metaagent
		=> nrel_explanation: [<p>Задачей <b><i>абстрактных sc-метаагентов</i></b> является координация деятельности <i>абстрактных программных sc-агентов</i>, в частности, решение проблемы взаимоблокировок. Агенты данного класса могут быть реализованы на Языке SCP, однако для синхронизации их деятельности используются другие принципы, соответственно, для реализации таких агентов требуется Язык SCP другого уровня, типология операторов которого полностью аналогична типологии scp-операторов, однако эти операторы имеют другую операционную семантику, учитывающую отличия в принципах синхронизации (работы с <i>блокировками*</i>). Программы такого языка будем называть <i>scp-метапрограммами</i>, соответствующие им <b><i>процессы в sc-памяти</i> ---  <i>scp-метапроцессами</i></b>, операторы  --- <i>scp-метаоператорами</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		nrel_abstract_sc_agent_decomposition
		<- decomposition_relation;
		=> nrel_explanation: [<p>Отношение <b><i>декомпозиции абстрактного sc-агента*</i></b> трактует <i>неатомарные абстрактные sc-агенты</i> как коллективы более простых <i>абстрактных sc-агентов</i>, взаимодействующих через <i>sc-память</i>.Другими словами, <b><i>декомпозиция абстрактного sc-агента*</i></b> на <i>абстрактные sc-агенты</i> более низкого уровня уточняет один из возможных подходов к реализации этого <i>абстрактного sc-агента</i> путем построения коллектива более простых <i>абстрактных sc-агентов</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		sc_agent
		=> nrel_idtf: [<p>агент над sc-памятью</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		<= nrel_inclusion: subject;
		=> nrel_set_of_subsets: abstract_sc_agent;
		=> nrel_explanation: [<p>Под <b><i>sc-агентом</i></b> понимается конкретный экземпляр (с теоретико-множественной точки зрения --- элемент) некоторого <i>атомарного абстрактного sc-агента</i>, работающий в какой-либо конкретной интеллектуальной системе.Таким образом, каждый <i>sc-агент</i> --- это субъект, способный выполнять некоторый класс однотипных действий либо только над <i>sc-памятью</i>, либо над sc-памятью и внешней средой (для эффекторных <i>sc-агентов</i>). Каждое такое действие инициируется либо состоянием или ситуацией в sc-памяти, либо состоянием или ситуацией во внешней среде (для рецепторных sc-агентов-датчиков),  соответствующей условию инициирования <i>атомарного абстрактного sc-агента</i>, экземпляром которого является заданный <i>sc-агент</i>. В данном случае можно провести аналогию между принципами объектно-ориентированного программирования, рассматривая <i>атомарный абстрактный sc-агент</i> как класс, а конкретный <i>sc-агент</i>  как экземпляр, конкретную имплементацию этого класса.Взаимодействие <i>sc-агентов</i> осуществляется только через <i>sc-память</i>. Как следствие, результатом работы любого <i>sc-агента</i> является некоторое изменение состояния <i>sc-памяти</i>, т.е. удаление либо генерация каких-либо <i>sc-элементов</i>.В общем случае один <i>sc-агент</i> может явно передать управление другому <i>sc-агенту</i>, если этот <i>sc-агент</i> априори известен. Для этого каждый <i>sc-агент</i> в <i>sc-памяти</i> имеет обозначающий его <i>sc-узел</i>, с которым можно связать конкретную ситуацию в текущем состоянии базы знаний, которую инициируемый <i>sc-агент</i> должен обработать.Однако далеко не всегда легко определить тот <i>sc-агент</i>, который должен принять управление от заданного <i>sc-агента</i>, в связи с чем описанная выше ситуация возникает крайне редко. Более того, иногда условие инициирования <i>sc-агента</i> является результатом деятельности непредсказуемой группы <i>sc-агентов</i>, равно как и одна и та же конструкция может являться условием инициирования целой группы <i>sc-агентов</i>.При этом общаются через <i>sc-память</i> не <i>программы sc-агентов*</i>, а сами описываемые данными программами <i>sc-агенты</i>.В процессе работы <i>sc-агент</i> может сам для себя порождать вспомогательные <i>sc-элементы</i>, которые сам же удаляет после завершения акта своей деятельности (это вспомогательные <i>структуры</i>, которые используются в качестве информационных лесов только в ходе выполнения соответствующего акта деятельности и после завершения этого акта удаляются).</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		active_sc_agent
		<= nrel_inclusion: sc_agent;
		=> nrel_explanation: [<p>Под <b><i>активным sc-агентом</i></b> понимается <i>sc-агент</i> ostis-системы, который реагирует на события, соответствующие его условию инициирования, и, как следствие, его <i>первичному условию инициирования*</i>. Не входящие во множество <b><i>активных sc-агентов</i></b> <i>sc-агенты</i> не реагируют ни на какие события в <i>sc-памяти</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		nrel_sc_agent_key_sc_elements
		=> nrel_explanation: [<p>Связки отношения <b><i>ключевые sc-элементы sc-агента*</i></b> связывают между собой <i>sc-узел</i>, обозначающий <i>абстрактный sc-агент</i> и <i>sc-узел</i>, обозначающий множество <i>sc-элементов</i>, которые являются ключевыми для данного <i>абстрактного sc-агента</i>, то данные <i>sc-элементы</i> явно упоминаются в рамках программ, реализующих данный <i>абстрактный sc-агент</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		nrel_sc_agent_program
		=> nrel_explanation: [<p>Связки отношения <b><i>программа sc-агента*</i></b> связывают между собой <i>sc-узел</i>, обозначающий <i>атомарный абстрактный sc-агент</i> и <i>sc-узел</i>, обозначающий множество программ, реализующих указанный <i>атомарный абстрактный sc-агент</i>. В случае <i>платформенно-независимого абстрактного sc-агента</i> каждая связка отношения <i>программа sc-агента*</i> связывает <i>sc-узел</i>, обозначающий указанный <i>абстрактный sc-агент</i> с множеством <i>scp-программ</i>, описывающих деятельность данного <i>абстрактного sc-агента</i>. Данное множество содержит одну <i>агентную scp-программу</i> и произвольное количество (может быть, и ни одной) <i>scp-программ</i>, которые необходимы для выполнения указанной <i>агентной scp-программы</i>.В случае <i>платформенно-зависимого абстрактного sc-агента</i> каждая связка отношения <i>программа <b>sc-агента*</b></i> связывает <i>sc-узел</i>, обозначающий указанный <i>абстрактный sc-агент</i> с множеством файлов, содержащих исходные тексты программы на некотором внешнем языке программирования, реализующей деятельность данного <i>абстрактного sc-агента</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		nrel_primary_initiation_condition
		=> nrel_explanation: [<p>Связки отношения <b><i>первичное условие инициирования*</i></b> связывают между собой <i>sc-узел</i>, обозначающий <i>абстрактный sc-агент</i> и бинарную ориентированную пару, описывающую первичное условие инициирования данного <i>абстрактного sc-агента</i>, т.е. такую спецификацию <i>ситуации</i> в <i>sc-памяти</i>, возникновение которой побуждает <i>sc-агента</i> перейти в активное состояние и начать проверку наличия своего полного условия инициирования.Первым компонентом данной ориентированной пары является знак некоторого класса <i>элементарных событий в sc-памяти*</i>, например, <i>событие добавления sc-дуги, выходящей из заданного sc-элемента*</i>.Вторым компонентом данной ориентированной пары является произвольный в общем случае <i>sc-элемент</i>, с которым непосредственно связан указанный тип события в <i>sc-памяти</i>, т.е., например, <i>sc-элемент</i>, из которого выходит либо в который входит генерируемая либо удаляемая <i>sc-дуга</i> либо <i>файл</i>, содержимое которого было изменено.После того, как в <i>sc-памяти</i> происходит некоторое событие, активизируются все <i>активные sc-агенты</i>, <b><i>первичное условие инициирования*</i></b> которых соответствует произошедшему событию.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		nrel_initiation_condition_and_result
		=> nrel_explanation: [<p>Связки отношения <b><i>условие инициирования и результат*</i></b> связывают между собой <i>sc-узел</i>, обозначающий <i>абстрактный sc-агент</i>, и бинарную ориентированную пару, связывающую условие инициирования данного <i>абстрактного sc-агента</i> и результаты выполнения данного экземпляров данного <i>sc-агента</i> в какой-либо конкретной системе.Указанную ориентированную пару можно рассматривать как логическую связку импликации, при этом на <i>sc-переменные</i>, присутствующие в обеих частях связки, неявно накладывается квантор всеобщности, на <i>sc-переменные</i>, присутствующие либо только в посылке, либо только в заключении неявно накладывается квантор существования.Первым компонентом указанной ориентированной пары является логическая формула, описывающая условие инициирования описываемого <i>абстрактного sc-агента</i>, то есть конструкции, наличие которой в <i>sc-памяти</i> побуждает <i>sc-агент</i> начать работу по изменению состояния <i>sc-памяти</i>. Данная логическая формула может быть как атомарной, так и неатомарной, в которой допускается использование любых связок логического языка.Вторым компонентом указанной ориентированной пары является логическая формула, описывающая возможные результаты выполнения описываемого абстрактного <i>sc-агента</i>, то есть описание произведенных им изменений состояния <i>sc-памяти</i>. Данная логическая формула может быть как атомарной, так и неатомарной, в которой допускается использование любых связок логического языка.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		.system_element_5792
		<= nrel_inclusion: semantic_neighborhood;
		=> nrel_explanation: [<p><b><i>описание поведения sc-агента</i></b> представляет собой <i>семантическую окрестность</i>, описывающую деятельность <i>sc-агента</i> до какой-либо степени детализации, однако такое описание должно быть строгим, полным и однозначно понимаемым. Как любая другая <i>семантическая окрестность</i>, <b><i>описание поведения sc-агента</i></b> может быть протранслировано на какие-либо понятные, общепринятые средства, не требующие специального изучения, например, на естественный язык.Описываемый <i>абстрактный sc-агент</i> входит в соответствующее <b><i>описание поведения sc-агента</i></b> под атрибутом <i>ключевой sc-элемент'</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
	*];;

	.system_element_5814
	=> nrel_inclusion: [*

		process_in_sc_memory
		=> nrel_note: [<p>Понятия <i>действие в sc-памяти</i> и <i>процесс в sc-памяти</i> (информационный процесс, выполняемый агентом в семантической памяти), являются синонимичными, поскольку все процессы, протекающие в sc-памяти, являюся осознанными и выполняются каким-либо sc-агентами. Тем не менее, когда идет речь о синхронизации выполнения каких-либо преобразований в памяти компьютерной системы, в литературе принято использовать именно термины <i>процесс</i>, взаимодействие процессов Dijkstra1972, Hoare1989, в связи с чем будем использовать этот термин при описании принципов синхронизации деятельности sc-агентов при выполнении ими параллельных процессов в sc-памяти.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_subdividing: {
			sc_memory_process_corresponding_platform_dependent_sc_agent;
			scp_process
		};
		=> nrel_subdividing: {
			.system_element_5815;
			scp_metaprocess
		};;

		sc_memory_process_corresponding_platform_dependent_sc_agent
		=> nrel_subdividing: {
			.system_element_5816;
			.system_element_5817
		};;

		nrel_lock
		<- binary_relation;
		=> nrel_explanation: [<p>Для синхронизации выполнения <i>процессов в sc-памяти</i> используется механизм блокировок. Отношение <b><i>блокировка*</i></b> связывает знаки <i>действий в sc-памяти</i> со знаками <i>структур</i> (ситуативных), которые содержат элементы, заблокированные на время выполнения данного действия или на какую-то часть этого периода. Каждая такая <i>структура</i> принадлежит какому-либо из <i>типов блокировки</i>.Первым компонентом связок отношения <b><i>блокировка*</i></b> является знак <i>действия в sc-памяти</i>, вторым  знак заблокированной <i>структуры</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> .system_element_253: "file://images/sd_agents/lock.png"
		(*
			<- concept_file;;
			=> nrel_format: format_png;;
		*);;

		lock_type
		=> nrel_explanation: [<p>Множество <b><i>тип блокировки</i></b> содержит все возможные классы блокировок, т.е. <i>структуры</i>, содержащие <i>sc-элементы</i>, заблокированные каким-либо <i>sc-агентом</i> на время выполнения им некоторого <i>действия в sc-памяти</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		-> total_lock;
		-> lock_for_any_change;
		-> lock_for_deleting;;

		total_lock
		=> nrel_explanation: [<p>Каждая <i>структура</i>, принадлежащая множеству <b><i>полная блокировка</i></b> содержит <i>sc-элементы</i>, просмотр и изменение (удаление, добавление инцидентных <i>sc-коннекторов</i>, удаление самих <i>sc-элементов</i>, изменение содержимого в  случае файла) которых запрещены всем <i>sc-агентам</i>, кроме собственно <i>sc-агента</i>, выполняющего соответствующее данной структуре <i>действие в sc-памяти</i>, связанное с ней отношением <i>блокировка*</i>.Для того, чтобы исключить возможность реализации <i>sc-агентов</i>, которые могут внести изменения в конструкции, описывающие блокировки других <i>sc-агентов</i>, все элементы этих конструкций, в том числе, сам знак <i>структуры</i>, содержащей заблокированные <i>sc-элементы</i> (принадлежащей как множеству <b><i>полная блокировка</i></b>, так и любому другому <i>типу блокировки</i>) и связки отношения <i>блокировка*</i>, связывающие эту <i>структуру</i> и конкретное <i>действие в sc-памяти</i>, добавляются в <b><i>полную блокировку</i></b>, соответствующую данному <i>действию в sc-памяти</i>. Таким образом, каждой <b><i>полной блокировке</i></b> соответствует петля принадлежности, связывающая ее знак с самим собой.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		lock_for_any_change
		=> nrel_explanation: [<p>Каждая <i>структура</i>, принадлежащая множеству <b><i>блокировка на любое изменение</i></b> содержит <i>sc-элементы</i>, изменение (физическое удаление, добавление инцидентных <i>sc-коннекторов</i>, физическое удаление самих <i><b>sc-элементов</b></i>, изменение содержимого в случае файл) которых запрещено всем <i>sc-агентам</i>, кроме собственно <i>sc-агента</i>, выполняющего соответствующее данной структуре <i>действие в sc-памяти</i>, связанное с ней отношением <i>блокировка*</i>. Однако не запрещен просмотр (чтение) этих <i>sc-элементов</i> любым <i>sc-агентом</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		lock_for_deleting
		=> nrel_explanation: [<p>Каждая <i>структура</i>, принадлежащая множеству <b><i>блокировка на удаление</i></b> содержит <i>sc-элементы</i>, удаление которых запрещено всем <i>sc-агентам</i>, кроме собственно <i>sc-агента</i>, выполняющего соответствующее данной структуре <i>действие в sc-памяти</i>, связанное с ней отношением <i>блокировка*</i>. Однако не запрещен просмотр (чтение) этих <i>sc-элементов</i> любым <i>sc-агентом</i>, добавление инцидентных sc-коннекторов.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		nrel_lock
		=> .system_element_1771: {
			[<p>В каждый момент времени одному процессу в sc-памяти может соответствовать только одна блокировка каждого типа.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>В каждый момент времени одному процессу в sc-памяти может соответствовать только одна блокировка, установленная на некоторый конкретный sc-элемент.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>При завершении выполнения любого процесса в sc-памяти все установленные им блокировки автоматически снимаются.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Для повышения эффективности работы системы в целом каждый процесс должен в каждый момент времени блокировать минимально необходимое множество sc-элементов, снимая блокировку с каждого sc-элемента сразу же, как это становится возможным (безопасным).</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>В случае когда в рамках <i>процесса в sc-памяти</i> явно выделяются более частные подпроцессы (при помощи отношений <i>темпоральная часть*, поддействие*, декомпозиция действия*</i> и т. д.), то каждый такой подпроцесс с точки зрения синхронизации выполнения рассматривается как самостоятельный процесс, которому в соответствие могт быть поставлены все необходимые блокировки.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
				=> nrel_detalization: 
					[<p>Все дочерние процессы в sc-памяти имеют доступ к блокировкам родительского процесса так же, как если бы это были блокировки соответствующие каждому из таких дочерних процессов.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>В свою очередь, родительский процесс не имеет какого-либо привилегированного доступа к sc-элементам, заблокированным дочерними процессами, и работает с ними так же, как любой другой процесс в sc-памяти. Исключение составляют sc-элементы, обозначающие сами дочерние процессы, поскольку родительский процесс должен иметь возможность управления дочерним, например, приостановки или прекращения их выполнения.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Все дочерние процессы по отношению друг к другу работают так же, как и по отношению к любым другим процессам.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>В случае, когда родительский процесс приостанавливает выполнение (становится <i>отложенным действием</i>), <u>все</u> его дочерние процессы также приостанавливают выполнение. В свою очередь, приостановка одного из дочерних процессов в общем случае не инициирует явно остановку всего родительского процесса и соответственно других дочерних.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*)
				;;
			*)
		};;

		total_lock
		=> .system_element_1771: {
			[<p>Если sc-элемент, инцидентный некоторому sc-коннектору, попадает в какую-либо полную блокировку, то сам этот sc-коннектор по умолчанию также считается заблокированным этой же блокировкой. Обратное в общем случае неверно, т. к. часть sc-коннекторов, инцидентных некоторому sc-элементу, может быть полностью заблокирована, при этом сам этот элемент заблокирован не будет. Такая ситуация типична, например, для sc-узлов, обозначающих классы понятий.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Каждый процесс в sc-памяти может свободно изменять или удалять любые sc-элементы, попадающие в полную блокировку, соответствующую этому процессу.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*)
		}
		(*
			=> nrel_note: [<p>Принципы работы с <i>полными блокировками</i>, с одной стороны, наиболее просты, поскольку все процессы, кроме установившего такую блокировку, не имеют доступа к заблокированным <b>sc-элементам</b> и конфликты возникнуть не могут. С другой стороны, частое использование блокировок такого типа может привести к тому, что система не сможет использовать в полной мере имеющиеся у нее знания и давать неполные или даже некорректные ответы на поставленные вопросы.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);;

		lock_for_any_change
		=> .system_element_1771: {
			[<p>На один и тот же sc-элемент в один момент времени может быть установлена только одна блокировка одного типа, но разные процессы могут одновременно установить на один и тот же элемент блокировки двух разных типов. Это касается случая, когда первый процесс установил на некоторый sc-элемент блокировку на удаление, а второй процесс затем устанавливает блокировку на любое изменение. В других случаях возникает конфликт блокировок.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Установка блокировки любого типа также считается изменением, таким образом, если на некоторый <b>sc-элемент</b> была установлена блокировка на любое изменение, то другой процесс не сможет установить на этот же sc-элемент блокировку любого типа, пока первый процесс не снимет свою.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Если блокировка на удаление устанавливается на некоторый sc-коннектор, то по умолчанию та же блокировка устанавливается на инцидентные этому sc-коннектору sc-элементы, поскольку удаление этих элементов приведет к удалению этого коннектора.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*)
		}
		(*
			<= .system_element_1771: lock_for_deleting;;
		*);;

		process_in_sc_memory
		=> nrel_idtf: [<p>действие в sc-памяти</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_subdividing: .system_element_5818
		(*
			<=> .system_element_200: {
				.system_element_5819;
				action_of_generation_sc_elements;
				action_of_deleting_sc_elements;
				.system_element_5820;
				.system_element_5821
			};;
		*);;

		.system_element_5822
		=> nrel_explanation: [<p>В некоторых случаях для того, чтобы обеспечить синхронизацию, необходимо объединять несколько элементарных действий над sc-памятью в одно неделимое действие (<i>транзакцию в sc-памяти</i>), для которого гарантируется, что ни один сторонний процесс не сможет прочитать или изменить участвующие в этом действии sc-элементы, пока действие не завершится. При этом, в отличие от ситуации с полной блокировкой, процесс, пытающийся получить доступ к таким элементам, не продолжает выполнение так, как если бы этих элементов просто не было в sc-памяти, а ожидает завершения транзакции, после чего может выполнять с данными элементами любые действия согласно общим принципам синхронизации процессов. Проблема обеспечения транзакций не может быть решена на уровне SC-кода и требует реализации таких неделимых действий на уровне <i>платформы интерпретации sc-моделей</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		.system_element_5819
		=> nrel_explanation: [<p>В случае осуществления поиска все найденные и сохраненные в рамках какого-либо процесса sc-элементы попадают в соответствующую данному процессу <i>блокировку на любое изменение</i>. Таким образом, гарантируется целостность фрагмента базы знаний, с которым работает некоторый процесс в sc-памяти. При этом поиск и автоматическая установка такой блокировки должны быть реализованы как <i>транзакция в sc-памяти</i>.Такой подход также позволяет избежать ситуации, когда один процесс заблокировал некоторый sc-элемент на любое изменение, а второй процесс пытается сгенерировать или удалить <i>sc-коннектор</i>, инцидентный данному <i>sc-элементу</i>. В таком случае второй процесс должен будет предварительно найти и заблокировать указанный <i>sc-элемент</i> на любое изменение, что вызовет конфликт блокировок (<i>взаимоблокировку*</i>).</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		action_of_generation_sc_elements
		=> nrel_explanation: [<p>В случае генерации любого sc-элемента в рамках некоторого процесса он автоматически попадает в полную блокировку, соответствующую данному процессу. При этом генерация и автоматическая установка такой блокировки должны быть реализованы как <i>транзакция в sc-памяти</i>. При необходимости сгенерированные элементы могут быть удалены (т. е. их временное существование вообще никак не отразится на деятельности других процессов) или разблокированы в случае, когда сгенерирована информация, которая может иметь некоторую ценность в дальнейшем.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		.system_element_5820
		=> nrel_explanation: [<p>В случае, если какой-либо процесс пытается установить блокировку любого типа на какой-либо sc-элемент, уже заблокированный каким-либо другим процессом, то, с одной стороны, блокировка не может быть установлена, пока другой процесс не разблокирует указанный sc-элемент; с другой стороны, для того чтобы обеспечить возможность поиска и устранения <i>взаимоблокировок</i>, необходимо явно указывать тот факт, что какой-либо процесс хочет получить доступ к какому-либо заблокированному другим процессом sc-элементу. Для того чтобы иметь возможность указать, какие процессы пытаются заблокировать уже заблокированный <i>sc-элемент</i>, предлагается наряду с отношением <i>блокировка*</i> использовать отношение <i>планируемая блокировка*</i>, полностью аналогичное отношению <i>блокировка*</i>.Описанный механизм регулирует также и процессы поиска, поскольку поиск и сохранение некоторого sc-элемента предполагает установку <i>блокировки на любое изменение</i>. Кроме того, следует учитывать, что на один sc-элемент <i>блокировка на любое изменение</i> может быть установлена после <i>блокировки на удаление</i>, соответствующей другому процессу. В этом случае использовать отношение <i>планируемые блокировки*</i> нет необходимости.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_note: [<p>Действие проверки наличия на некотором sc-элементе блокировки и в зависимости от результата проверки, установки блокировки или планируемой блокировки (с указанием приоритета при необходимости) должно быть реализовано как транзакция.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		.system_element_5823
		<= nrel_inclusion: nrel_lock;
		=> nrel_explanation: [<p>Процесс, которому в соответствие поставлена <i>планируемая блокировка*</i>, приостанавливает выполнение до тех пор, пока уже установленные блокировки не будут сняты, после чего <i>планируемая блокировка*</i> становится реальной <i>блокировкой*</i> и процесс продолжает выполнение в соответствии с общими правилами.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		.system_element_5824
		=> nrel_definitional_domain: .system_element_5823;
		=> nrel_explanation: [<p>В случае, когда на один и тот же sc-элемент планируют установить блокировку сразу несколько процессов, используется отношение <i>приоритет блокировки*</i>, связывающее между собой пары отношения <i>планируемая блокировка*</i>. Как правило, приоритет блокировки определяется тем, какой из процессов раньше попытался установить блокировку на рассматриваемый sc-элемент, хотя в общем случае приоритет может устанавливаться или меняться в зависимости от дополнительных критериев.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		action_of_deleting_sc_elements
		=> nrel_note: [<p>В случае попытки удаления некоторого sc-элемента некоторым процессом удаление может быть осуществлено только в случае, когда на данный sc-элемент не установлена (и не планируется) ни одна блокировка каким-либо другим процессом.В других случаях необходимо обеспечить корректное завершение выполнения всех процессов, работающих с данным sc-элементом, и только потом удалить его физически.Для реализации такой возможности каждому процессу в соответствие может быть поставлено множество удаляемых данным процессом sc-элементов.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_note: [<p>Действие проверки наличия блокировок или планируемых блокировок на удаляемый sc-элемент и, собственно, его удаление или добавление во множество удаляемых sc-элементов для соответствующего процесса должно быть реализовано как транзакция.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		.system_element_5825
		=> nrel_first_domain: process_in_sc_memory;
		=> nrel_explanation: [<p>Sc-элементы, попавшие во множество удаляемых sc-элементов некоторого процесса в sc-памяти, доступны процессам, уже установившим (или планирующим установить) на эти sc-элементы блокировки ранее (до попытки его удаления), а для всех остальных процессов эти sc-элементы уже считаются удаленными. Процесс, пытающийся удалить sc-элемент, приостанавливает свое выполнение до того момента, пока все заблокировавшие и планирующие заблокировать данный sc-элемент процессы не разблокируют его. В общем случае один sc-элемент может входить во множества удаляемых элементов одновременно для нескольких процессов, в этом случае все такие процессы одновременно продолжат выполнение после снятия с этого sc-элемента всех блокировок. Если удаление пытается осуществить один из процессов, уже установивший на указанный sc-элемент блокировку, то алгоритм действий остается прежним --- sc-элемент добавляется во множество удаляемых данным процессом sc-элементов и будет физически удален, как только все остальные процессы, установившие на данный sc-элемент блокировки, снимут их.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		.system_element_5821
		=> .system_element_5826: <
			[<p>Если на данный sc-элемент установлена одна или несколько <i>планируемых блокировок*</i>, то первая из них по приоритету (или единственная) становится <i>блокировкой*</i>, соответствующий ей процесс продолжает выполнение (становится настоящей сущностью).</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Связка отношения приоритет выполнения, соответствовавшая удаленной связке отношения <i>планируемая блокировка*</i> также удаляется, т. е. приоритет смещается на одну позицию.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Если <i>планируемых блокировок*</i>, установленных на данный sc-элемент, нет, но он попадает во множество удаляемых sc-элементов для одного или нескольких процессов, то рассматриваемый sc-элемент физически удаляется, а приостановленные до его удаления процессы продолжают свое выполнение (становятся настоящими сущностями).</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Если на данный sc-элемент не установлены планируемые блокировки, и он не входит во множество удаляемых для какого-либо процесса, то блокировка просто снимается без каких-либо дополнительных изменений.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*)
		>;;

		.system_element_5822
		=> nrel_subdividing: {
			.system_element_5827;
			.system_element_5828;
			.system_element_5829;
			.system_element_5830;
			.system_element_5831;
			.system_element_5832;
			.system_element_5833
		};;

		abstract_program_sc_agent
		=> nrel_note: [<p>При реализации <i>абстрактных программных sc-агентов</i> на <i>языке SCP</i>, соблюдение всех принципов синхронизации соответствующих этим sc-агентам процессов обеспечивается на уровне <i>sc-агентов интерпретации scp-программ</i>, т. е. средствами <i>платформы интерпретации sc-моделей</i>. При реализации <i>абстрактных программных sc-агентов</i> на уровне платформы, соблюдение всех принципов синхронизации возлагается, во-первых, непосредственно на разработчика агентов, во-вторых, --- на разработчика платформы. Так, например, платформа может предоставлять доступ к хранимым в sc-памяти элементам через некоторый программный интерфейс, уже учитывающий принципы работы с блокировками, что избавит разработчика агентов от необходимости учитывать все эти принципы вручную.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> .system_element_1771: {
			[<p>В результате появления в sc-памяти некоторой конструкции, удовлетворяющей условию инициирования какого-либо <i>абстрактного sc-агента</i>, реализованного при помощи <i>Языка SCP</i>, в <i>sc-памяти</i> генерируется и инициируется <i>scp-процесс</i>. В качестве шаблона для генерации используется <i>агентная scp-программа</i>, соответствующая данному <i>абстрактному sc-агенту</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Каждый такой <i>scp-процесс</i>, соответствующий некоторой <i>агентной <b>scp-программе</b></i>, может быть связан с набором структур, описывающих блокировки различных типов. Таким образом, синхронизация взаимодействия параллельно выполняемых <i>scp-процесcов</i> осуществляется так же, как и в случае любых других <i>действий в sc-памяти</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Несмотря на то что каждый <i>scp-оператор</i> представляет собой атомарное действие в sc-памяти, являющееся поддействием в рамках всего <i><b>scp-процесса</b></i>, блокировки, соответствующие одному оператору, не вводятся, чтобы избежать громоздкости и избытка дополнительных системных конструкций, создаваемых при выполнении некоторого <i>scp-процесса</i>. Вместо этого используются блокировки, общие для всего <i>scp-процесса</i>. Таким образом, <i>агенты интерпретации scp-программ</i> работают только с учетом блокировок, общих для всего интерпретируемого <i>scp-процесса</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Процессы, описывающие деятельность агентов интерпретации <i>scp-программ</i>, как правило, не создаются, следовательно, и не вводятся соответствующие им блокировки. Поскольку такие агенты работают с уникальным scp-процессом и их число ограничено и известно, то использование блокировок для их синхронизации не требуется.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>В случае приостановки <i>scp-процесса</i> (добавления его во множество <i>отложенных действий</i>) в соответствии с общими правилами синхронизации все его дочерние процессы также должны быть приостановлены. В связи с этим все <i>scp-операторы</i>, которые в этот момент являются <i>настоящими сущностями</i>, становятся <i>отложенными действиями</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Во избежание нежелательных изменений в самом теле <i>scp-процесса</i>, вся конструкция, сгенерированная на основе некоторой <i>scp-программы</i> (весь <i>sc-текст</i>, описывающий декомпозицию <i>scp-процесса</i> на <i>scp-операторы</i>), должна быть добавлена в <i>полную блокировку</i>, соответствующую данному <i>scp-процессу</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>При необходимости разблокировать или заблокировать некоторую конструкцию каким-либо типом блокировки используются соответствующие <i>scp-операторы</i> класса <i>scp-оператор управления блокировками</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>После завершения выполнения некоторого scp-процесса его текст, как правило, удаляется из <i>sc-памяти</i>, а все заблокированные конструкции освобождаются (разрушаются знаки структур, обозначавших блокировки).</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Как правило, частный <i>класс действий</i>, соответствующий конкретной <i>scp-программе</i>, явно не вводится, а используется более общий класс <i>scp-процесс</i>, за исключением тех случаев, когда введение специального <i>класса действий</i> необходимо по каким-либо другим соображениям.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*)
		};;

		nrel_lock
		=> nrel_note: [<p>В общем случае весь механизм блокировок может описываться как на уровне SC-кода (для повышения уровня платформенной независимости), так и при необходимости может быть реализован на уровне <i>платформы интерпретации sc-моделей</i>, например, для повышения производительности. Для этого каждому выполняемому в sc-памяти процессу на нижнем уровне может быть поставлена в соответствие некая уникальная таблица, в каждый момент времени содержащая перечень заблокированных элементов с указанием типа блокировки.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> .system_element_3429: <
			"file://images/sd_agents/plan_lock_1.png"
			(*
				<- concept_file;;
				=> nrel_format: format_png;;
				=> nrel_explanation: [<p>В данном примере <i>Процесс1</i> непосредственно работает с sc-элементом <i><b>e1</b></i>, <i>Процесс2</i> и <i>Процесс3</i> планируют установить блокировку на любое изменение и блокировку на удаление соответственно, причем <i>Процесс2</i> попытался установить свою блокировку раньше, чем <i>Процесс3</i>, поэтому согласно направлению связки отношения <i>приоритет блокировки*</i>, его блокировка будет установлена раньше. <i>Процесс4</i> и <i>Процесс5</i> ожидают снятия всех блокировок и планируемых блокировок, после чего <i><b>e1</b></i> будет удален и <i>Процесс1</i> и <i>Процесс2</i> продолжат свое выполнение. Никакие другие планируемые блокировки установлены быть уже не могут, поскольку <i><b>e1</b></i> попал во множество удаляемых sc-элементов как минимум одного процесса и, в соответствии с изложенными выше правилами, все остальные процессы кроме <i>Процесс1</i>-<i>Процесс5</i>, уже не смогут получить доступ к этому sc-элементу. Выполняемый процесс принадлежит множеству настоящая сущность, приостановленные --- множеству отложенное действие.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*);
			"file://images/sd_agents/plan_lock_2.png"
			(*
				<- concept_file;;
				=> nrel_format: format_png;;
				=> nrel_explanation: [<p>После того как <i>Процесс1</i> разблокировал sc-элемент <i><b>e1</b></i>, этот элемент будет заблокирован <i>Процессом2</i>, и <i>Процесс2</i> продолжит выполнение. <i>Планируемая блокировка*</i>, установленная <i>Процессом2</i>, становится обычной <i>блокировкой*</i>.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*);
			"file://images/sd_agents/plan_lock_3.png"
			(*
				<- concept_file;;
				=> nrel_format: format_png;;
				=> nrel_explanation: [<p>После того как <i>Процесс2</i> разблокировал sc-элемент <i><b>e1</b></i>, этот элемент будет заблокирован <i>Процессом3</i>, и <i>Процесс3</i> продолжит выполнение.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*);
			"file://images/sd_agents/plan_lock_4.png"
			(*
				<- concept_file;;
				=> nrel_format: format_png;;
				=> nrel_explanation: [<p>Когда все процессы снимут блокировки с sc-элемента <i><b>e1</b></i>, он может быть физически удален и <i>Процесс4</i> и <i>Процесс5</i> продолжат выполнение.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*)
		>;;

		.system_element_5834
		=> nrel_explanation: [<p>В зависимости от конкретных <i>типов блокировок</i>, установленных параллельно выполняемыми процессами на некоторые sc-элементы, и того, какие конкретно действия с этими <i>sc-элементами</i> предполагается выполнить, далее в рамках выполнения этих процессов возможны ситуации взаимоблокировки, когда каждый из указанных процессов будет ожидать снятия блокировки вторым процессом с нужного <i>sc-элемента</i>, не снимая при этом установленной им самим блокировки с <i>sc-элемента</i>, доступ к которому необходим второму процессу.В случае, когда хотя бы одна из блокировок является <i>полной блокировкой</i>, ситуация взаимоблокировки возникнуть не может, поскольку <i>sc-элементы</i>, попавшие в <i>полную блокировку</i> некоторого <i>scp-процесса</i>, не доступны другим <i>scp-процессам</i> даже для чтения и, таким образом, остальные <i>scp-процессы</i> будут работать так, как будто заблокированные <i>sc-элементы</i> просто отсутствуют в текущем состоянии <i>sc-памяти</i>.В случаях, когда ни одна из установленных блокировок не является <i>полной блокировкой</i>, возможно появление взаимоблокировок.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_note: [<p>Устранение <i>взаимоблокировки</i> невозможно без вмешательства специализированного <i>sc-метаагента</i>, который имеет право игнорировать блокировки, установленные другими процессами.В общем случае проблема конкретной взаимоблокировки может быть решена путем выполнения специализированным <i>sc-метаагентом</i> следующих шагов:
		<ul>
			<li> откат нескольких операций, выполненных одним из участвующих во взаимоблокировке процессов на столько шагов назад, насколько это необходимо для того, чтобы второй процесс получил доступ к необходимым <i>sc-элементам</i> и смог продолжить выполнение;
			<li> ожидание выполнения второго процесса вплоть до завершения или до снятия им всех блокировок с <i>sc-элементов</i>, доступ к которым необходимо получить первому процессу;
			<li> повторное выполнение в рамках первого процесса отмененных операций и продолжение его выполнения, но уже с учетом изменений в памяти, внесенных вторым процессом.</li>
		<ul></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;

		.system_element_5835
		=> nrel_explanation: [<p>Для <i>sc-метаагентов</i> все sc-элементы, в том числе описывающие блокировки, планируемые блокировки и т. д., полностью эквивалентны между собой с точки зрения доступа к ним, т. е. любой <i>sc-метаагент</i> имеет доступ к любым sc-элементам, даже попавшим в полную блокировку для какого-либо другого процесса. Это необходимо для того, чтобы <i>sc-метаагенты</i> смогли выявлять и устранять различные проблемы, например, описанную выше проблему взаимоблокировки.Таким образом, проблема синхронизации деятельности <i>sc-метаагентов</i> требует введения дополнительных правил.Указанную проблему разделим на две более частные:

		<ul>

			<li> обеспечение синхронизации деятельности <i>sc-метаагентов</i> между собой;

			<li> обеспечение синхронизации деятельности <i>sc-метаагентов</i> и <i>программных sc-агентов</i>.</li>

		<ul>Первую проблему предлагается решить за счет запрета параллельного выполнения <i>sc-метаагентов</i>. Таким образом, в каждый момент времени в рамках одной <i>ostis-системы</i> может существовать только один процесс, соответствующий <i>sc-метаагенту</i> и являющийся <i>настоящей сущностью</i>.Вторую проблему предлагается решить за счет введения дополнительных привилегий для <i>sc-метаагентов</i> при обращении к какому-либо sc-элементу. Для этого достаточно одного правила:Если некоторый sc-элемент стал использоваться в рамках процесса, соответствующего <i>sc-метаагенту</i> (например, стал элементом хотя бы одного scp-оператора, входящего в данный процесс), то все процессы, которым в соответствующие блокировки   попадает указанный sc-элемент, становятся отложенными действиями (приостанавливают выполнение). Как только указанный sc-элемент перестает использоваться в рамках процесса, соответствующего <i>sc-метаагенту</i>, все приостановленные по этой причине процессы продолжают выполнение.Рассмотренные ограничения не ухудшают производительность ostis-системы существенно, поскольку <i>sc-метаагенты</i> предназначены для решения достаточно узкого класса задач, которые, как показал опыт практической разработки прототипов различных <i>ostis-систем</i>, возникают достаточно редко.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_note: [<p>Стоит отметить, что возможна ситуация, при которой выполнение некоторого процесса в sc-памяти прервано по причине возникновения какой-либо ошибки. В таком случае существует вероятность того, что блокировка, установленная данным процессом не будет снята до тех пор, пока этого не сделает sc-метаагент, обнаруживший подобную ситуацию. Однако указанная проблема на уровне sc-модели может быть решена лишь частично. Для случаев, когда ошибка возникает при интерпретации scp-программы, проблема отслеживается scp-интепретатором и в памяти формируется соответствующая конструкция, сообщающая о проблеме sc-метаагенту. Случаи, когда возникла ошибка на уровне scp-интерпретатора или sc-хранилища, должны рассматриваться на уровне платформы интерпретации sc-моделей.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
	*];;
*];;
