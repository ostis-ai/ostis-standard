.segment_sem_comp_arch = [*
.system_element_4699
=> nrel_inclusion: [*

	.system_element_4691
	<= nrel_inclusion: .system_element_4700;
	=> nrel_idtf: [<p>associative semantic computer</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>sc-компьютер</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>аппаратно реализованный базовый интерпретатор семантических моделей (sc-моделей) компьютерных систем</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>аппаратно реализованная ostis-платформа</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>аппаратный вариант ostis-платформы</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>ассоциативный семантический компьютер, управляемый знаниями</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>компьютер с нелинейной структурно перестраиваемой (графодинамической) ассоциативной памятью, переработка информации в которой сводится не к изменению состояния элементов памяти, а к изменению конфигурации связей между ними</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>универсальный компьютер нового поколения, специально предназначенный для реализации семантически совместимых гибридных интеллектуальных компьютерных систем</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>универсальный компьютер нового поколения, ориентированный на аппаратную интерпретацию логико-семантических моделей интеллектуальных компьютерных систем</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>универсальный компьютер нового поколения, ориентированный на аппаратную интерпретацию ostis-систем</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>ostis-компьютер</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>компьютер для реализации ostis-систем</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>компьютер, управляемый знаниями, представленными в SC-коде</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>компьютер, ориентированный на обработку текстов SC-кода</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>компьютер, внутренним языком которого является SC-код</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>компьютер, осуществляющий реализацию sc-памяти и интерпретацию scp-программ</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>предлагаемый нами компьютер нового поколения, ориентированный на реализацию интеллектуальных компьютерных систем и использующий SC-код в качестве внутреннего языка</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> .system_element_3098: [<p>Повысить производительность компьютерных систем, основанных на знаниях, представленных в виде семантических сетей</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> .system_element_4701: .system_element_962;
	=> nrel_subdividing: {
		.system_element_4702
		(*
			=> nrel_idtf: [<p>sc-компьютер, обеспечивающий интепретацию scp-программ</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
			=> .system_element_4703: .system_element_4308;;
		*);
		.system_element_4704
		(*
			=> nrel_idtf: [<p>sc-компьютер, обеспечивающий интепретацию scp-программ</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
			=> .system_element_4703: .system_element_4705;;
		*)
	};;

	.system_element_4702
	=> nrel_idtf: [<p>минимальная конфигурация аппаратно реализованной ostis-платформы, в рамках которой обеспечивается интерпретация scp-программ</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_idtf: [<p>минимальная конфигурация аппаратно реализованной ostis-платформы, в рамках которой аппаратно реализуются только базовые sc-агенты</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_explanation: [<p>В рамках scp-компьютера аппаратно реализуется (1) sc-память, (2) базовые sc-агенты, обеспечивающие интерпретацию scp-программ, (3) элементарные рецепторные sc-агенты, (4) элементарные эффекторные sc-агенты</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);;

	.system_element_4691
	=> nrel_note: [<p>Для уточнения архитектуры <i>ассоциативных семантических компьютеров</i> необходимо уточнить:

	<ul>

		<li> Базовую структуру компьютера, и, в частности, его процессоро-памяти;

		<li> Алфавит элементов, хранимых в процессоро-памяти компьютера;

		<li> Систему команд, интерпретируемых компьютером;

		<li> Принципы управления процессом интерпретации указанных команд;

		<li> Систему микропрограмм, обеспечивающих реализацию принципов управления указанным процессом.</li>

	<ul></p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_note: [<p>Поскольку внутренним языком кодирования информации для <i>ассоциативного семантического компьютера</i> является SC-код, то алфавит элементов, хранимых в процессоро-памяти компьютера, совпадает с <i>Алфавитом SC-кода</i>. При этом алфавит физически кодируемых  синтаксических меток может быть расширен, например, из соображений производительности, по аналогии с тем, как это делается в программном варианте реализации <i>ostis-платформы</i>.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> .system_element_35: 
			.system_element_4706;
			.system_element_788
		;;
	*);
	=> nrel_note: [<p>В качестве системы команд для <i>ассоциативного семантического компьютера</i> предлагается <i>Язык SCP</i>. Таким образом, как уже сказано в указанном параграфе, <i>Язык SCP</i> представляет собой ассемблер для <i>ассоциативного семантического компьютера</i>.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> .system_element_35: .system_element_4707;;
	*);
	=> nrel_note: [<p>Для определения базовой структуры <i>ассоциативного семантического компьютера</i> уточним варианты такой структуры, предложенные в работах В.В. Голенкова и В.М. Кузьмицкого. В частности, в работе В.М. Кузьмицкого предложен переход от крупнозернистых архитектур графодинамических машин к мелкозернистым.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> .system_element_1: 
			.system_element_4692;
			.system_element_4693
		;;
	*);;

	.system_element_4708
	=> nrel_note: [<p>Модели крупнозернистых архитектур имеют в своем составе параллельно функционирующие модули, обладающие следующими свойствами:

	<ul>

		<li> Каждый модуль имеет строго фиксированное функциональное назначение в рамках архитектуры графодинамической машины в целом (так называемое глобальное функциональное назначение).

		<li> Каждый модуль имеет относительно большой объем памяти (количество элементов памяти много больше общего количества модулей).

		<li> Над памятью каждого типа модуля определен свой неэлементарный набор операций, выполняющих некоторые законченные преобразования над достаточно большими фрагментами памяти.</li>

	<ul></p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_note: [<p>Основным формальным отличием для моделей мелкозернистых архитектур выступает иное соотношение между общим количеством модулей и количеством элементов памяти каждого модуля (емкостью памяти модуля), которое стремится к единице, и уровнем сложности операций модели. Соответственно свойствами моделей мелкозернистых архитектур можно считать следующие:
	<ul>
		<li> Для каждого модуля по отдельности может не просматриваться его функциональное назначение в рамках графодинамической машины в целом. Вместе с тем каждый отдельный модуль в конкретный момент времени может иметь некоторое так называемое локальное функциональное назначение, соответствующее множество которых может уже рассматриваться как имеющее определенное так называемое глобальное функциональное назначение в рамках графодинамической машины в целом.
		<li> Объем (количество элементов) памяти каждого модуля минимален и стремится к единице. Как следствие, общее количество модулей сопоставимо с общим количеством элементов памяти всех модулей.
		<li> Для каждого модуля (в общем случае) набор операций, выполняемых над его памятью, элементарен и ограничен (конечен), так как воздействует лишь на один элемент (или лишь на несколько элементов) памяти и определяется очевидной ограниченностью (конечностью) семантики интерпретации содержимого элемента графовой памяти графодинамической машины.</li>
	<ul></p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> .system_element_1: .system_element_4693;;
	*);
	=> nrel_note: [<p>Целесообразность перехода от крупнозернистых архитектур к мелкозернистым обусловлена соответствующим увеличением степени потенциального параллелизма в процедурах переработки знаний.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);;

	.system_element_4691
	=> .system_element_4709: {
		.system_element_4710;
		.system_element_4711;
		.system_element_4712
	};;

	.system_element_4710
	=> nrel_note: [<p>Одним из логичных и наиболее простых с архитектурной точки зрения вариантов аппаратной реализации ostis-платформы является реализация средств хранения конструкций SC-кода и интерпретации scp-программ на аппаратном уровне по аналогии с тем, как это делается в программных вариантах ostis-платформы на базе современных компьютеров. В этом случае общая архитектура компьютера остается фон-Неймановской (с явным выделением отдельного процессорного модуля и отдельного модуля памяти).</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> .system_element_35: .system_element_4706;;
	*);
	=> .system_element_4713: {
		[<p>Модуль памяти (реализация <i>sc-памяти</i>) представляет собой множество ячеек, каждая из которых может хранить некоторый sc-элемент или может быть пустой. Каждая ячейка такой памяти имеет некоторый уникальный внутренний адрес, аналогичный адресу ячеек фон-Неймановской памяти. В то же время, при обработке информации, хранимой в такой памяти, на уровне языка команд (Языка SCP), в отличие от фон-Неймановской памяти адреса ячеек не учитываются, доступ к sc-элементам осуществляется исключительно по связям инцидентности между ними. Исключение составляют некоторые ключевые sc-элементы, набор которых оговаривается отдельно и доступ к которым осуществляется по какому-либо другому идентификатору, например, системному sc-идентификатору или основному sc-идентификатору для какого-либо внешнего языка, но не по адресу. Подразумевается, что если в ячейке хранится некоторый sc-элемент, то в ней хранится информация, характеризующая этот sc-элемент, а именно:
		<ul>
			<li> синтаксическая метка, задающая тип соответствующего sc-элемента;
			<li> содержимое внутреннего файл ostis-системы или ссылка на внешнюю файловую систему (если хранится внутренний файл ostis-системы);
			<li> перечень связей инцидентности данного sc-элемента с другими sc-элементами, что фактически означает хранение набора адресов ячеек памяти, соответствующих sc-элементам, инцидентным данному sc-элементу. Конкретный перечень типов хранимых связей может уточняться в зависимости от реализации. Например, по аналогии с тем, как это сделано в программном варианте реализации ostis-платформы, целесообразно хранить в ячейке памяти адрес ячейки, соответствующей первому sc-коннектору, инцидентному соответствующему sc-элементу соответствующим типом инцидентности, а в рамках ячейки, соответствующей данному sc-коннектору хранить адрес ячейки, соответствующей следующему sc-коннектору, инцидентного тому же sc-элементу тем же типом инцидентности и так далее. При таком подходе размер каждой ячейки памяти можно сделать фиксированным.
			<li> метка блокировки sc-элемента с указанием метки соответствующего процесса;
			<li> метка уровня доступа и любые другие метки при необходимости.</li>
		<ul></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Процессорный модуль реализует набор команд, соответствующих <i>атомарным типам scp-операторов</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Для связи с внешней средой вводится <i>терминальный модуль</i>, который в общем случае может быть реализован по разному и задачами которого являются:
		<ul>
			<li> подготовка (генерация) информации, поступающей из внешней среды для ее последующей ее загрузки в процессорный модуль и модуль памяти;
			<li> передача (использование, реализация) информации, подготовленной (полученной, представленной) в процессорном модуле и модуле памяти, во внешнюю среду.</li>
		<ul></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
			=> .system_element_1: 
				.system_element_4692;
				.system_element_4693
			;;
		*);
		[<p>Для хранения содержимых внутренних файлов ostis-системы большого размера может оказаться целесообразным иметь отдельную файловую память, построенную по фон-Неймановским принципам. Тогда в ячейках семантической памяти, соответствующих таким внутренним файлам ostis-системы, будет хранится не непосредственно их содержимое, а адрес этого файла на файловой памяти.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Для реализации принципов многоагентной обработки информации, предлагаемых в рамках Технологии OSTIS необходимо реализовать (например, в рамках терминального модуля) подсистему регистрации и обработки событий, которая позволит осуществлять инициирование sc-агентов при возникновении соответствующих событий в памяти.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
			=> .system_element_35: .system_element_4698;;
		*)
	};
	=> .system_element_2880: {
		[<p>Относительная простота и невысокая трудоемкость реализации по сравнению с разработкой полноценного варианта процессоро-памяти. В частности, при условии наличия стабильно работающего варианта программной реализации ostis-платформы, в котором хотя бы нижний уровень реализован на языках достаточно низкого уровня, таких как C, для упрощения процесса разработки аппаратной архитектуры возможно использование средств автоматизации перехода от программ на C к описанию на языках описания аппаратуры (HDL --- hardware description language, например, VSDL и Verilog), также известных как "C to HDL". Среди популярных средств и языков этого класса можно отметить LegUp, VHDPlus, SystemC, MyHDL для языка Python и множество других.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
			=> .system_element_1: 
				.system_element_4714;
				.system_element_4715;
				.system_element_4716;
				.system_element_4717
			;;
		*);
		[<p>Простота интеграции с современными компьютерными системами, в частности, можно рассматривать гибридный вариант, при котором <i>ассоциативный семантический компьютер</i> реализуется как отдельный подключаемый модуль для современного компьютера, предназначенный для повышения эффективности обработки sc-конструкций.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*)
	};
	=> .system_element_237: [<p>Очевидным ключевым недостатком такого варианта является его ориентация на фон-Неймановскую архитектуру со всеми ее недостатками. Кроме того, в таком варианте по умолчанию на аппаратном уровне не закладывается обеспечение параллельной обработки sc-конструкций. Указанный недостаток частично устраняется в варианте крупнозернистой архитектуры <i>ассоциативных семантических компьютеров</i>.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);;

	.system_element_4711
	=> .system_element_490: [<p>Целью перехода к крупнозернистой архитектуре <i>ассоциативных семантических компьютеров</i> является реализация на аппаратном уровне параллельной обработки sc-конструкций.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> .system_element_4713: {
		[<p><i>ассоциативный семантический компьютер</i> разделяется на несколько однотипных модулей, устроенных аналогично тому, как строится рассмотренный в предыдущем пункте вариант реализации ассоциативного семантического компьютера на базе фон-Неймановской архитектуры. Такие модули будем называть "комбинированными модулями", поскольку такой модуль имеет свой процессорный модуль и свой модуль памяти (накопительный модуль), отдельно выделяемых общих процессорных модулей не предполагается. Может существовать отдельный общий модуль памяти, в который при необходимости будет записываться информация, которая не поместилась в память конкретного комбинированного модуля.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>По-прежнему выделяется терминальный модуль, обеспечивающий связь системы комбинированных модулей с внешней средой.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Может отдельно выделяться модуль файловой памяти.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Число комбинированных модулей относительно невелико (2 --- 16), каждый модуль представляет собой достаточно мощное устройство (фактически --- отдельный <i>ассоциативный семантический компьютер</i>) и, соответственно, для решения задач некоторых классов может оказаться достаточно одного комбинированного модуля.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>В то же время в общем случае для решения задачи необходимо задействовать несколько комбинированных модулей. В этом случае обрабатываемая sc-конструкция распределяется между несколькими модулями, для чего создаются sc-узлы-копии, позволяющие обеспечить семантическую связь между фрагментами sc-конструкции, хранящимися в разных комбинированных модулях. Для записи таких конструкций было разработано расширение <i>SC-кода</i>, названное <i>SCD-кодом</i> (Semantic Code Distibuted), соответственно конструкции такого языка получили название <i>scd-конструкций</i>, их элементы --- <i>scd-элементов</i> (<i>scd-узлов</i>, <i>scd-дуг</i>).</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
			=> .system_element_1: 
				.system_element_4692;
				.system_element_4693
			;;
		*);
		[<p>Аналогично для обработки <i>scd-конструкций</i> было разработано расширение <i>Языка SCP</i>, названное <i>Языком SCPD</i>, учитывающее тот факт, что разные фрагменты обрабатываемой конструкции могут физически храниться в разных комбинированных модулях. При этом предполагается, что все элементы <i>scd-конструкции</i>, представляющей <i>scpd-программу</i> (программу <i>Языка SCPD</i>), должны быть расположены в памяти одного комбинированного модуля, но каждая <i>scpd-программа</i> может иметь несколько полных копий в разных комбинированных модулях.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Для синхронизации параллельных процессов обработки информации комбинированные модули обмениваются сообщениями, которые могут содержать как фрагменты обрабатываемых <i>scd-конструкций</i>, так и команды <i>Языка SCDP</i>. Соответственно <i>Язык SCPD</i> по сравнению с <i>Языком SCP</i> имеет дополнительные средства, поддерживающие распределенную переработку графовых конструкций:
		<ul>
			<li> В <i>Язык SCPD</i> встроены средства, позволяющие распознавать "свой" и "чужой" комбинированный модуль, для этого вводятся операторы работы с идентификаторами модулей;
			<li> Предусмотрена возможность создания копии <i>scd-элемента</i> в памяти другого модуля. Для этой цели вводится группа операторов работы с копиями: создание копии <i>scd-элемента</i> в указанном модуле, перенос связей элемента-оригинала на копию, склеивание копий элемента, поиск копии данного элемента в заданном модуле и так далее;
			<li> Предусматривается возможность явного удаленного вызова <i>scpd-программы</i> в указанном процессорном модуле. Для параллельного запуска одинаковых процессов, выполняющихся в разных процессорных модулях, предусмотрены операторы, запускающие программу на выполнение в модулях из указанного списка.
			<li> Имеются средства межпроцессной и внутрипроцессной синхронизации: операторы формирования сообщения, операторы ожидания сообщения, операторы перевода процесса в режим ожидания завершения выполнения распределенно выполняющихся операторов, операторы ожидания завершения выполнения всех распределенно выполняющихся операторов.</li>
		<ul></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
			=> .system_element_1: 
				.system_element_4692;
				.system_element_4693
			;;
		*);
		[<p>Для обмена сообщениями каждый комбинированный модуль имеет соответствующие подмодули, позволяющие отправлять и принимать сообщения, а также буфер сообщений для хранения очереди полученных сообщений, ожидающих обработки и сообщений, ожидающих отправки.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Для интерпретации <i>scpd-программ</i> разрабатывается семейство микропрограмм на языке, который в общем случае зависит от выбранных аппаратных компонентов, из которых строятся комбинированные модули.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*)
	};
	=> nrel_note: [<p>К описанному варианту реализации <i>ассоциативных семантических компьютеров</i> с крупнозернистой архитектурой относится и упомянутая ранее мультитранспьютерная реализация. В основу указанной реализация были положены ПК IBM PC 386 (486, Pentium) и 8 транспьютеров T805.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> .system_element_1: 
			.system_element_4718;
			.system_element_4692
		;;
	*);
	=> .system_element_213: .system_element_4719;
	=> .system_element_2133: [<p>Основным достоинством крупнозернистой архитектуры <i>ассоциативных семантических компьютеров</i> является ориентация на аппаратную поддержку параллельной обработки конструкций <i>SC-кода</i>.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> .system_element_139: {
		[<p>Каждый комбинированный модуль строится по принципам <i>машины фон-Неймана</i>, соответственно, ее недостатки в полной мере не устраняются.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Несмотря на сохранение общих принципов <i>SC-кода</i> и <i>Языка SCP</i>, распределенное хранение и обработка sc-конструкций требует разработки отдельных языковых средств, таких как <i>SCD-код</i> и <i>Язык SCPD</i>, и их поддержки на базе выбранной аппаратной архитектуры. Кроме того, как видно и рассмотренных выше принципов <i>Языка SCPD</i>, при разработке <i>scpd-программ</i> необходимо явно учитывать тот факт, что обработка выполняется распределенно.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*)
	};;

	.system_element_4720
	<=> nrel_semantic_equivalence: "file://Contents/part_platform/src/images/coarse-grained architecture.pdf"
	(*
		<- concept_file;;
		=> nrel_format: format_pdf;;
	*);
	=> nrel_note: [<p>На рисунке схематично показан такой вариант реализации на 8 транспьютерах, где каждый транспьютер одновременно выполняет роль узла коммутации (УК) и процессорного модуля (ПМ) или накопительного модуля (НМ). Вся система при этом взаимодействует с внешней средой посредством терминального модуля (ТМ).</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);;

	.system_element_4712
	=> nrel_note: [<p>Целесообразность перехода от крупнозернистых архитектур к мелкозернистым обусловлена  соответствующим увеличением степени потенциального параллелизма в процедурах переработки знаний. При этом максимально возможный параллелизм, очевидно, будет иметь место при предельной реализации мелкозернистых архитектур, в которых один структурный модуль процессоро-памяти будет соответствовать одному элементу памяти, то есть в нашем случае --- одному sc-элементу.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> .system_element_2130: {
		[<p>Процессоро-память <i>ассоциативного семантического компьютера</i> состоит из однотипных модулей, которые будем называть процессорными элементами sc-памяти или просто <i>процессорными элементами</i>. Каждый <i>процессорный элемент</i> соответствует одному sc-элементу (хранит один sc-элемент). При этом в каждый момент времени каждый <i>процессорный элемент</i> может быть пустым (не хранить никакой sc-элемент) или заполненным, то есть иметь взаимно однозначно соответствующий ему хранимый sc-элемент. На физическом уровне для описания этого факта вводится соответствующий признак, имеющим два значения. Таким образом, каждый <i>процессорный элемент</i> "отвечает" только за один sc-элемент и, в отличие от крупнозернистого варианта архитектуры <i>ассоциативного семантического компьютера</i>, <u>задача не может быть решена</u> <u>одним <i>процессорным элементом</i></u> и количество таких <i>процессорных элементов</i> достаточно велико (соответствует максимальному возможному числу sc-элементов, хранимых в базе знаний некоторой ostis-системы). Опыт разработки прикладных ostis-систем показывает, что в среднем число sc-элементов в базе знаний такой ostis-системы составляет от нескольких сотен тысяч до нескольких миллионов. Ситуация, когда в рамках процессоро-памяти необходимо представить sc-конструкцию, число элементов которой больше числа <i>процессорных элементов</i> на данный момент не рассматривается и требует дополнительного исследования.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Каждый <i>процессорный элемент</i> (по аналогии с ячейкой памяти в случае реализации <i>ассоциативного семантического компьютера</i> на фон-Неймановской архитектуре) имеет некоторый уникальный внутренний идентификатор --- <i><u>адрес</u> процессорного элемента</i>. Адреса <i>процессорных элементов</i>, в отличие от адресов ячеек фон-Неймановской памяти, <u>не обеспечивают непосредственный доступ</u> к <i>процессорным элементам</i>, а позволяют однозначно <u>идентифицировать</u> процессорный элемент при обмене сообщениями согласно рассмотренным принципам.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Каждый процессорный элемент имеет память, в которой хранится
		<ul>
			<li> синтаксическая метка, задающая тип соответствующего sc-элемента;
			<li> содержимое внутреннего файла ostis-системы или ссылка на внешнюю файловую систему (если данный процессорный элемент соответствует внутреннему файлу ostis-системы);
			<li> перечень логических связей данного процессорного элемента с другими, то есть перечень адресов процессорных элементов, связанных с данным процессорным элементом <i>логическими каналами связи</i> с указанием типа связи;
			<li> метка блокировки sc-элементов с указанием метки соответствующего процесса;
			<li> другие метки при необходимости (например, метки уровня доступа к хранимому sc-элементу);
			<li> волновые микропрограммы, выполняемые данным процессорным элементом в данный момент, и временные данные для этих микропрограмм, а также очередь микропрограмм при необходимости.</li>
		<ul></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Процессорные элементы связаны между собой двумя типами каналов связи --- <i>физическими каналами связи</i> и <i>логическими каналами связи</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
			=> nrel_note: 
				[<p>В общем случае число <i>физических каналов связи</i> у каждого <i>процессорного элемента</i> может быть произвольным, кроме того теоретически <i>физические каналы связи</i> между процессорными элементами могут перестраиваться (перекоммутироваться) с течением времени, например, с целью оптимизации времени передачи сообщений между процессорными элементами. Конфигурация <i>физических каналов связи</i> не учитывается на уровне логической обработки знаний, как на уровне Языка SCP, так и на уровне языка микропрограмм, обеспечивающих интерпретацию команд Языка SCP, то есть <i>scp-операторов</i>. Для упрощения в рамках данной работы будем рассматривать вариант физической реализации sc-памяти, в котором каждый процессорный элемент имеет фиксированное и одинаковое для всех процессорных элементов число <i>физических каналов связи</i> (N), при этом конфигурация таких каналов связи с течением времени не меняется. Очевидно, что минимальным значением N является 2, в этом случае мы получим линейную цепочку <i>процессорных элементов</i>. При N равном 4 мы получим двумерную "матрицу" <i>процессорных элементов</i>, При N равном 6 --- трехмерную "матрицу" <i>процессорных элементов</i> и так далее. Будем называть "смежными" <i>процессорные элементы</i>, непосредственно связанные <i>физическим каналом связи</i>.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				[<p>В таком случае можно сказать, что каждый процессорный элемент имеет свой "адрес" (уникальный идентификатор) в некотором многомерном пространстве, число измерений (признаков) которого определяется числом N <i>физических каналов связи</i>, связанных с одним <i>процессорным элементом</i>. В приведенных выше примерах размерность такого пространства равна N/2, что позволяет предположить, что число N целесообразно делать четным.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				[<p>Каждый <i>физический канал связи</i> и каждый <i>логический канал связи</i>, таким образом, задается парой <i>адресов процессорных элементов</i>.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				[<p><i>логические каналы связи</i> между процессорными элементами формируются динамически и соответствуют <i>связям инцидентности</i> между sc-элементами. Таким образом, <i>логические каналы связи</i> могут описывать два типа связей инцидентности --- <i>инцидентность обозначений sc-пар с их компонентами</i> и <i>инцидентность обозначений ориентированных sc-пар с их вторыми компонентами</i>. При этом конфигурация <i>логических каналов связи</i> в общем случае никак не связана с конфигурацией <i>физических каналов связи</i> --- инцидентные sc-элементы могут физически храниться в процессорных элементах, не являющихся смежными. В тоже время очевидно, что в общем случае некоторые <i>физические каналы связи</i> могут соответствовать логическим.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
					=> .system_element_35: .system_element_4706;;
				*);
				[<p>Кроме связей инцидентности <i>логические каналы связи</i> могут соответствовать и другим типам связей между sc-элементами, по аналогии с тем, как это сделано в программном варианте реализации ostis-платформы. Например, для упрощения реализации алгоритмов поиска в базе знаний и уменьшения объема памяти, которым должен обладать каждый <i>процессорный элемент</i>, целесообразно хранить в памяти процессорного элемента адрес только первого sc-коннектора, инцидентного соответствующему sc-элементу соответствующим типом инцидентности, а в рамках процессорного элемента, соответствующего данному sc-коннектору, адрес следующего sc-коннектора, инцидентного тому же sc-элементу тем же типом инцидентности и так далее. При таком подходе количество памяти процессорного элемента, хранящей логические связи между процессорными элементами, можно сделать фиксированным.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
					=> .system_element_35: .system_element_4706;;
				*)
			;;
		*);
		[<p>Каждый процессорный элемент может отправлять сообщения (микропрограммы) другим процессорным элементам и принимать сообщения от других процессорных элементов по <i>логическим каналам связи</i> и имеет соответствующие рецепторно-эффекторные подмодули. На физическом уровне передача сообщений осуществляется, в свою очередь, по <i>физическим каналам связи</i>, конфигурация которых, как было сказано выше, фиксируется и в общем случае не зависит от конфигурации логических каналов связи.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Таким образом, процессорные элементы формируют однородную процессоро-память, в которой нет отдельно выделяемых модулей, предназначенных только для хранения информации и отдельно выделяемых модулей, предназначенных только для ее обработки.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Для связи такой процессоро-памяти с внешней средой вводится <i>терминальный модуль</i>, который в общем случае может быть реализован по разному и задачами которого являются:
		<ul>
			<li> подготовка (генерация) информации, поступающей из внешней среды для ее последующей загрузки в процессорные модули;
			<li> передача (использование, реализация) информации, подготовленной (полученной, представленной) в процессорных модулях, во внешнюю среду.</li>
		<ul></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Для хранения содержимых внутренних файлов ostis-системы большого размера может оказаться целесообразным иметь отдельную файловую память, связанную с процессоро-памятью и построенную по традиционным фон-Неймановским принципам. Это обусловлено тем, что основная цель построения процессоро-памяти -- обеспечение как можно большей параллельности при обработке конструкций SC-кода, в случае же с хранением и обработкой содержимых внутренних файлов ostis-системы, которые по определению являются внешними по отношению к SC-коду информационными конструкциями, целесообразно использовать современные традиционные подходы.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*)
	};
	=> nrel_note: [<p>Перечисленные принципы позволяют сформулировать ключевую особенность обработки информации, хранимой в рамках такой процессоро-памяти. В отличие от архитектуры фон-Неймана (и других архитектур, разработанных примерно в то же время, например, Гарвардской архитектуры) и даже от <i>программного варианта ostis-платформы</i> в предлагаемой архитектуре процессоро-памяти <u>отсутствует общая память</u>, доступная для всех модулей, осуществляющих обработку информации. Благодаря этому значительно упрощается параллельная обработка информации, однако усложняется реализации набора микропрограмм интерпретации команд обработки информации в такой памяти, поскольку каждый процессорный элемент становится очень "близоруким" и "видит" только те процессорные элементы, которые связаны с ним <i>логическими каналами связи</i>.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_note: [<p>Язык описания микропрограмм интерпретации команд <i>ассоциативного семантического компьютера</i> не может быть построен как традиционный язык программирования, например, процедурного типа, поскольку все такие языки предполагают возможность непосредственного адресного или ассоциативного доступа к произвольным элементам памяти. Предлагаемый язык описания микропрограмм предлагается строить по принципам <i>волновых языков программирования</i> и инсерционного программирования.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> .system_element_1: 
			.system_element_4721;
			.system_element_4722;
			.system_element_4723;
			.system_element_4724
		;;
	*);;

	.system_element_4725
	=> nrel_note: [<p>В рамках такого языка микропрограмм выделяется два типа волн:

	<ul>

		<li> Волны, передаваемые только по <i>логическим каналам связи</i> (например, при поиске инцидентных sc-элементов).

		<li> Волны, передаваемые по всем каналам связи (например, при создании новых логических каналов связи, то есть при генерации новых sc-элементов).</li>

	<ul></p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);;

	.system_element_4712
	=> .system_element_4726: {
		[<p>Каждый <i>процессорный элемент</i> может интерпретировать некоторый ограниченный набор микропрограмм. С учетом того, что один процессорный элемент соответствует одному sc-элементу, то множество операций, связанных с преобразованием данного sc-элемента, очень ограничено (сгенерировать sc-элемент указанного типа, удалить sc-элемент, изменить содержимое sc-файла, установить или снять метку блокировки и так далее). Таким образом, важной задачей процессорного элемента будет формирование сообщений для других процессорных элементов и их отправка.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Каждый процессорный элемент может порождать и хранить в памяти временные данные для микропрограмм. Предполагается, что объем памяти, имеющейся в распоряжении процессорного элемента, достаточен для представления всех необходимых данных для возможного набора микропрограмм, поскольку такие микропрограммы достаточно просты (см. предыдущий принцип). В случае, если по каким-либо причинам переполнение все же происходит, то могут использоваться различные подходы.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
			=> .system_element_1: .system_element_4693;;
		*);
		[<p>Каждый процессорный элемент может сформировать микропрограмму и отправить ее в виде волнового сообщения для выполнения другими процессорными элементами. Передача сообщений происходит по физическим каналам связи. Поскольку конфигурация физических каналов связи в общем случае не связана конфигурацией логических каналов связи, то каждый процессорный элемент самостоятельно принимает решение о необходимости выполнения микропрограммы и передачи ее дальше. Здесь можно провести аналогию с волновым алгоритмом поиска пути в графе (вариант поиска в ширину).</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Часто процессорные элементы будут не выполнять микропрограмму, а передавать ее дальше, таким образом, сами процессорные элементы выполняют также и роль коммутационных элементов, при этом в общем случае каждый процессорный элемент может входить в произвольное число маршрутов при передаче сообщений по логическим каналам связи между процессорными элементами.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Как и в случае с крупнозернистой архитектурой, у каждого процессорного элемента есть очередь микропрограмм, подлежащих выполнению (входящих сообщений), и очередь микропрограмм, подлежащих отправке (выходящих сообщений). При этом в рамках каждого процессорного элемента также можно говорить о возможности параллельного выполнения каких-либо операций (например, формирование выходящих сообщений и обработку текущего хранимого sc-элемента).</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*)
	};;

	.system_element_4727
	=> nrel_inclusion: .system_element_4728
	(*
		=> nrel_note: [<p>
		<ul>
			<li> Выполнить указанное преобразование содержимого данного sc-узла;
			<li> Изменить метку типа sc-элемента (если такое изменение не противоречит <i>Синтаксису SC-кода</i>);
			<li> Заменить блокировку данного sc-элемента для указанного процесса (в том числе, снять метку);
			<li> Удалить sc-элемент.</li>
		<ul></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
	*);
	=> nrel_inclusion: .system_element_4729
	(*
		=> nrel_note: [<p>
		<ul>
			<li> Сгенерировать инцидентный sc-коннектор (и новый <i>логический канал связи</i>), возможно, вместе со смежным sc-элементом;
			<li> Сгенерировать оба или один sc-элемент, соединяемые данным sc-коннектором;
			<li> Найти все sc-коннекторы (то есть адреса соответствующих им процессорных элементов) указанного типа, инцидентные данному sc-элементу указанным типом инцидентности;
			<li> Найти sc-узлы, инцидентные данному sc-коннектору.</li>
		<ul></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
	*);
	=> nrel_inclusion: .system_element_4730
	(*
		=> nrel_note: [<p>
		<ul>
			<li> Переслать указанную микропрограмму для исполнения из данного процессорного элемента по всем <u>указанным</u> каналам (инцидентным sc-коннекторам указываемого типа) всем <u>смежным</u> sc-элементам указываемого типа;
			<li> Дождаться выполнения микропрограмм указанного типа, порожденных указанным процессорным элементом и результат их выполнения передать процессорному элементу, запросившему соответствующую информацию.</li>
		<ul></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
	*);
	=> nrel_note: [<p>Очевидно, что при решении конкретной задачи указанные микропрограммы могут комбинироваться в более сложные микропрограммы. Приведенная иерархия на данный момент не является полной и требует дальнейшего уточнения.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);;

	.system_element_4712
	=> .system_element_4732: .system_element_4731
	(*
		<=> .system_element_72: {
			[<p>Язык SCP, не зависящий от реализации ostis-платформы, на котором пишутся программы sc-агентов обработки знаний. Язык SCP является "водоразделом" между платформенно-зависимой частью и платформенно-независимой частью ostis-системы, таким образом, он является самым низкоуровневым языком среди всех возможных платформенно-независимых языков, и одновременно языком высокого уровня с точки зрения ostis-платформы.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Язык микропрограмм, которыми обмениваются процессорные элементы между собой, и которые исполняются этими процессорными элементами. Фактически на этом языке разрабатывается интерпретатор Языка SCP. Важно отметить, что язык микропрограмм ориентирован на передачу сообщений по <i>логическим каналам связи</i> и не учитывает конфигурацию <i>физических каналов связи</i>. Для этого вводится еще один язык более низкого уровня.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Язык для записи программ управления процессами обмена сообщениями (микропрограммами).</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
				=> nrel_note: [<p>Введение такого языка необходимо, поскольку, как было сказано, сам по себе язык микропрограмм не учитывает 
				<ul>
					<li> Конфигурацию физических каналов связи. Таким образом, при отправке сообщения по логическому каналу связи необходимо сформировать необходимое число сообщений в зависимости от числа имеющихся физических каналов связи, осуществить кодирование передаваемого сообщения для передачи по физическому каналу связи, передать сообщение с учетом того, что один и тот же физический канал связи может входить в общем случае в произвольное число маршрутов между процессорными элементами, осуществить декодирование сообщения на принимающем процессорном элементе. Все эти задачи требуют разработки соответствующих программ;
					<li> Организацию очереди входящих и выходящих сообщений внутри <i>процессорного элемента</i>, добавление сообщений в очередь, извлечение сообщений из очереди для выполнения и так далее.</li>
				<ul></p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*)
		};;
	*);
	=> .system_element_2880: {
		[<p>В рамках предложенной мелкозернистой архитектуры, в отличие от крупнозернистой, нет необходимости создания копий sc-элементов, и разработки специальных языков кодирования для полученных конструкций, таких как <i>SCD-код</i>, поскольку каждый процессорный элемент хранит один атомарный фрагмент всей хранимой sc-конструкции и число логических связей с другими процессорными элементами не ограничено.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Приведенная явно выделяемая иерархия языков программирования позволяет исключить на уровне разработки пользовательских программ (на <i>Языке SCP</i> и языков более высокого уровня на его основе) необходимость учитывать факт распределенного хранения sc-конструкций и вообще принципы организации ostis-платформы. Другими словами, не требуется разработка таких языков, как <i>Язык SCPD</i>.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		[<p>Расширяемость архитектуры позволяет легко наращивать число процессорных элементов без существенного снижения производительности, поскольку в предложенной архитектуре нет явно выделяемых процессорных модулей и накопительных модулей, соответственно исключается необходимость передачи информации между такими модулями, кроме того процессорный модуль перестает быть разделяемым ресурсом для большого числа одновременно выполняемых процессов. Все перечисленное позволит в конечном итоге решить проблему, известную как проблема "бутылочного горлышка" архитектуры фон-Неймана.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
			=> .system_element_1: .system_element_4733;;
		*);
		[<p>Ключевым достоинством предложенной мелкозернистой архитектуры является ее ориентация на максимально возможную поддержку параллельной обработки информации на аппаратном уровне и в конечном итоге возможность реализации <u>любых</u> моделей параллелизма с учетом решаемой задачи. В подтверждение данного тезиса можно привести теорию А-систем, описанную в работе В. Е. Котова и А. С. Нариньяни. По словам самих авторов, данное понятие стоит трактовать как универсальную модель для некоторого класса параллельных систем, которая требует уточнения в случае конкретных реализаций. В частности, в рамках данной теории выделяются процессорные элементы, активация/деактивация которых осуществляется посредством так называемой спусковой функции, принимающей значения 0 и 1. Понятно, что в конкретной реализации в качестве такой функции может быть использован любой признак, имеющий значения истина и ложь, указывающий на то, что тот или процессорный элемент должен быть активирован в следующий момент времени. Авторами показана возможность формализации на основе данной модели любых параллельных алгоритмов, рассмотрена возможность сведения таких алгоритмов к последовательным, варианты синхронизации в рамках такой модели.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
			=> .system_element_1: .system_element_4734;;
			=> nrel_note: [<p>Можно провести очевидную параллель между А-системами и предложенной мелкозернистой архитектурой <i>ассоциативных семантических компьютеров</i> с учетом наличия волнового языка микропрограммирования:
			<ul>
				<li> Процессорным элементам из теории А-систем соответствуют <i>процессорные элементы</i> процессоро-памяти;
				<li> В роли спусковых функций для процессорных элементов выступают микропрограммы, передаваемые волнами от одного процессорного элемента к другому и, соответственно, активизирующие деятельность процессорных элементов.</li>
			<ul>Стоит отметить, что несмотря на то, что рассмотренная работа по теории А-систем известна уже более полувека, авторам данной главы не удалось найти попытки реализовать идеи этой теории в аппаратном варианте. На наш взгляд, это обусловлено тем, что уровень развития микроэлектроники на тот момент не соответствовал необходимым для реализации теории А-систем требованиям.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*)
	};
	=> .system_element_237: [<p>Вместе с перечисленными достоинствами можно выделить ключевой недостаток предложенного мелкозернистого варианта архитектуры <i>ассоциативных семантических компьютеров</i>, который заключается в сильной зависимости быстродействия процессоро-памяти от времени передачи волновых микропрограмм от одного процессорного элемента к другому. При этом, поскольку на логическом уровне передача сообщений осуществляется по <i>логическим каналам связи</i>, а реально --- по <i>физическим каналам связи</i>, то быстродействие процессоро-памяти будет зависеть от того, насколько близко соответствует конфигурация <i>логических каналов связи</i> конфигурации <i>физических каналов связи</i>. Очевидно, что в общем случае взаимно однозначное соответствие этих конфигураций невозможно, поскольку число <i>физических каналов связи</i>, инцидентных заданному процессорному элементу, ограничено в отличие от числа <i>логических каналов связи</i>.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> .system_element_4735: {
			[<p>При записи ("укладке") sc-конструкции в процессоро-память (в особенности в случае достаточно больших sc-конструкций) можно учитывать <u>семантику</u> записываемых фрагментов, и записывать их таким образом, чтобы те sc-элементы, сообщение к которым будет передаваться от данного sc-элемента с большей вероятностью, находились физически ближе к данному sc-элементу. Так, например, можно учитывать денотационную семантику scp-операторов поиска, которые ориентированы на обработку <i>трехэлементных sc-конструкций</i> и <i>пятиэлементных sc-конструкций</i>, а также хранить sc-элементы, инцидентные заданному sc-коннектору по возможности ближе к нему.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Если число логических связей между элементами sc-конструкции не превышает числа доступных физических каналов связи процессорного элемента и sc-граф является планарным (хоть sc-граф не является классическим графом, можно говорить о его планарности по аналогии с планарностью классических графов), то возможна запись sc-конструкции в процессоро-память таким образом, чтобы конфигурация <i>логических каналов связи</i> взаимно однозначно соответствовала какому-то подмножеству физических каналов связи. Таким образом, актуальной является разработка алгоритмов оптимальной "укладки" sc-графов в процессоро-память для обеспечения последующей эффективности передачи сообщений между процессорными элементами.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Поскольку конфигурация <i>логических каналов связи</i> меняется в процессе обработки sc-конструкций, то целесообразно говорить также о разработке алгоритмов переразмещения ("дефрагментации") уже записанной в процессоро-память sc-конструкции с целью обеспечения последующей эффективности передачи сообщений. Такое переразмещение может выполняться, например, по расписанию в период, когда процессоро-память не используется для решения других задач.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Кроме того, при наличии аппаратной возможности может выполняться также перекоммутация <i>физических каналов связи</i> с целью приближения их конфигурации к конфигурации <i>логических каналов связи</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*)
		};;
	*);
	=> .system_element_203: [<p>Пример оптимального варианта записи простейшей пятиэлементной sc-конструкции в предлагаемую процессоро-память</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> .system_element_126: "file://Contents/part_platform/src/images/incidence example.pdf"
		(*
			<- concept_file;;
			=> nrel_format: format_pdf;;
			<- .system_element_143;;
			=> nrel_note: [<p>Граф инцидентности для <i>пятиэлементной sc-конструкции</i>, который позволяет свести sc-конструкцию к классическому графу с двумя типами связей. Для наглядности синтаксические типы соответствующих sc-элементов на рисунке не показаны.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);;
		=> .system_element_203: [<p>Пример соответствующей пятиэлементной sc-конструкции</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
			=> .system_element_126: "file://Contents/part_platform/src/images/computer graph1.png"
			(*
				<- concept_file;;
				=> nrel_format: format_png;;
			*);;
		*);;
		=> .system_element_203: [<p>Пример укладки sc-конструкции в процессоро-память</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
			=> .system_element_126: "file://Contents/part_platform/src/images/fine-grained architecture.pdf"
			(*
				<- concept_file;;
				=> nrel_format: format_pdf;;
			*);;
			=> nrel_note: [<p>На рисунке показан один из возможных оптимальных вариантов записи полученного графа инцидентности в процессоро-память. Пунктирными линиями показаны <i>физические каналы связи</i> между процессорными элементами, сплошными --- <i>физические каналы связи</i>, соответствующие <i>логическим каналам связи</i>. Отметим, что элемент <b><i>R1</i></b> целесообразно записать в <i>процессорный элемент</i>, соседний с <i>процессорным элементом</i>, хранящим элемент <b><i>e1</i></b> или элемент <b><i>e2</i></b>, как и показано на рисунке. Благодаря этому процессорные элементы, хранящие указанные sc-элементы, оказываются непосредственно связаны <i>физическим каналом связи</i>, что упрощает коммуникацию в случае рассылки сообщений по <i>физическим каналам связи</i> без учета <i>логических каналов связи</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);;
	*);;
*];
=> nrel_comment: [<p>Завершили "Сегмент. Архитектура ассоциативных семантических компьютеров для ostis-систем"</p>];;

*];;