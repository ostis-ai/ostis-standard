.system_element_4292
=> nrel_inclusion: [*
	=> .system_element_1416: 
		.system_element_4293;
		.system_element_1105
	;
	<- .system_element_3;
	-> rrel_key_sc_element: .system_element_4294;;

	.system_element_4294
	<- subject_domain;
	-> .system_element_6: 
		.system_element_299
	;
	-> .system_element_4295: 
		.system_element_407
	;;

	.system_element_4296
	=> nrel_inclusion: [*
		=> .system_element_172: [<p>Документация Программной платформы ostis-систем</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> .system_element_172: [<p>Документация Программного варианта реализации ostis-платформы</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>База знаний Программного варианта реализации ostis-платформы</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>Семейство sc-языков, описывающих реализацию компонентов, входящих в состав Программного варианта реализации ostis-платформы (в том числе их программных интерфейсов)</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>Подробная документация всех компонентов базового Программного варианта реализации ostis-платформы</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p><b>Это пример того, как надо описывать современные программные компьютерные системы</b></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		<- .system_element_4297;
		<= nrel_inclusion: metasystem_knowledge_base;
		=> nrel_authors: 
			.system_element_4293
		;
		=> .system_element_4298: [<p>Спецификация (документация) такого сложного программного объекта, как <i>Программная платформа ostis-систем</i>, может и должна быть представлена на <u>формальном</u> <i>языке представления знаний</i>, в данном случае на <i>SC-коде</i>, тексты которого она хранит и интерпретирует. В таком случае такой язык, который описывает <i>Программную платформу ostis-системы</i>, должен являться <i>подъязыком</i> <i>SC-кода</i>, то есть должен наследовать все свойства <i>Синтаксиса</i> и <i>Денотационной семантики SC-кода</i>. Такой способ представления спецификации <i>программных компьютерных систем</i> даёт <u>безусловно</u> сильные преимущества по сравнению с другими возможными вариантами представления спецификаций Dillon2008:
		<ul>
			<li> Язык, тексты которого система хранит и обрабатывает, и язык спецификации того, как система представляет тексты первого языка в памяти самой себя, являются подмножествами <u>одного и того же</u> языка. Это упрощает не только становление понимания разработчика, который разрабатывает сложную <i>программную компьютерную систему</i>, за счет того, что форма представления обрабатываемого этой системой языка и языка ее спецификации, <u>унифицирована</u>, но и позволяет открыть для этой системы новые функциональные возможности в <u>познании</u> самой себя. Таким образом, такой подход позволяет полностью реализовывать свойства <i>интеллектуальной компьютерной системы</i>, например, <i>рефлексивности</i>.
			<li> Нельзя проектировать и реализовывать <i>интеллектуальные компьютерные системы</i> на <i>программной компьютерной системе</i>, которая сама таковой не является. Представление спецификации системы в такой форме позволяет <u>существенно</u> повысить уровень ее <i>интеллекта</i> Zagorskiy2022b.
			<li> Нет необходимости в создании дополнительных средств для верификации и анализа работы всей системы, поскольку форма представления языка описания системы <u>унифицирована</u> с языком, тексты которого она хранит и интерпретирует. Это позволяет не только уменьшить количество используемых средств при проектировании и реализации такой программной системы, но и позволяет <u>унифицировать</u> информацию, хранимую в этой программной системе и описывающую эту программную систему, с целью использования этой информации в процессе эволюции её компонентов. При этом спецификация программной системы остаётся <i>платформенно-независимой</i>, поэтому при смене одного варианта реализации <i>ostis-платформы</i> на другой подход к описанию таких платформ остаётся <u>одним и тем же</u>.</li>
		<ul></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		-> rrel_key_sc_element: .system_element_4299
		(*
			=> .system_element_4300: {
				[<p>Вне зависимости от языка реализации каждого компонента <i>Программного варианта реализации ostis-платформы</i>, спецификация каждого компонента включает спецификацию, непосредственно описанную в <u>исходных файлах</u> самого компонента, описывающую программный интерфейс этого компонента, а также спецификацию как <u>части</u> базы знаний ostis-платформы, детально описывающую реализацию этого компонента, в том числе используемые алгоритмы.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				[<p><u>Каждый</u> компонент <i>Программного варианта реализации ostis-платформы</i> описывается средствами <i>Технологии OSTIS</i>, то есть на <i>SC-коде</i>, тексты которого она обрабатывает и хранит. Таким образом, это дает возможности платформе анализировать свое состояние и способствовать поддерживать свой жизненный цикл без участия ее разработчиков. <b><i>Программная платформа ostis-систем</i> выступает полноценным <u>субъектом</u></b>, принимающим непосредственное участие в собственной разработке.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				[<p><i>Спецификация Программного варианта реализации ostis-платформы</i> представляет собой <u><i>sc-язык</i></u>, то есть подъязык <i>SC-кода</i>, для которого уточнены <i>Cинтаксис</i> и <i>Денотационная семантика SC-кода</i>. Этот <i>sc-язык</i> можно представить в виде некоторого семейства более частных sc-языков. Такой подход позволяет без особых препятствий интегрировать описания различных компонентов, входящих в состав <i>Программного варианта реализации ostis-платформы</i>, поскольку вся <i>Спецификация Программного варианта реализации ostis-платформы</i> является ее базой знаний.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				[<p><u>Каждый</u> разработчик <i>Программного варианта реализации ostis-</i> <i>платформы</i> <u>заботится</u> о перманентной поддержки не только состояния ее компонентов, но и спецификации этих компонентов. <u>Гарантом</u> качественной <i>Спецификации Программного варианта реализации ostis-платформы</i> является ее <u>коллектив разработчиков</u>, способных не только понимать детали реализации <i>ostis-платформы</i>, но (!) и способствовать к созданию взаимовыгодного сотрудничества для достижения поставленных целей.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*)
			}
			(*
				=> nrel_note: [<p>Данные принципы можно использовать при описании любых (!) других <i>программных компьютерных систем</i>, в том числе тех <i>программных компьютерных систем</i>, которые не реализуются на данной <i>ostis-платформе</i>.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*);;
			=> .system_element_4301: {
				.system_element_4302;
				.system_element_4303;
				.system_element_4304;
				.system_element_4305;
				.system_element_4306;
				.system_element_4307
			}
			(*
				=> .system_element_348: [<p>Существует обширное множество различных решений в области автоматизации проектирования и разработки <i>программных компьютерных систем</i> (см. Iliadis2019), позволяющих решать задачи достаточно серьезного уровня. Однако ни одна из таких систем не способна обеспечить <i>платформенную независимость</i>, а значит и возможность к более легкой интеграции создаваемых <i>программных компьютерных систем</i>. Актуальность проблемы объясняется необходимостью создания <i>программных компьютерных систем нового поколения</i>, способных <u>быстро</u> и <u>качественно</u> решать <i>задачи</i> любого <i>вида деятельности</i>.Современные <i>программные компьютерные системы</i>, а также средства автоматизации проектирования и разработки таких систем, обладают рядом значительных недостатков: Проектируемые <i>программные компьютерные системы</i> в значительной степени остаются зависимыми от реализации конкретных платформ, на которых они проектируются, что, в свою очередь, приводит к существенным затратам на приведение в соответствие методов и средств проектирования систем в случае их перехода на новые платформы.
				<li> Проектирование и разработка конкретной <i>программной компьютерной системы</i> ведется при помощи разных методов и моделей проектирования <i>программных компьютерных систем</i>. Тем самым, описание целевого состояния системы и описание текущей реализации могут не соответствовать друг другу, а интеграция таких решений трудно достижима (cм. Sokolov2021).
				<li> Место спецификации <i>программных компьютерных систем</i> отводится на второй план, а иногда и вовсе не предусматривается проектом разработки конкретной компьютерной системы. Следовательно, увеличиваются затраты на поддержание процесса перманентного реинжиниринга таких систем (см. Dillon2007, Dillon2008).
				<li> При разработке современных <i>программных компьютерных систем</i> отсутствует понимание необходимости разработки и описания методов проектирования этих систем, в том числе описания процесса реализации, направлений использования и так далее. По этой причине новое поколение разработчиков <i>программных компьютерных систем</i> не использует уже имеющийся накопленный опыт, а изобретает одни и те же либо похожие решения.
				<li> Отсутствуют единые универсальные инструментальные средства разработки и реинжиниринга других систем, позволяющие не только автоматизировать их проектирование, но и свести к минимуму саму разработку за счет унификации моделей представления этих систем и наличия семантически мощной <i>комплексной библиотеки многократно используемых компонентов</i>.
				<li> Даже узкоспециализированные <i>программные компьютерные системы</i> должны обладать высоким <i>уровнем интеллекта</i> для расширения возможностей в решении более сложных задач. <i>программные компьютерные системы нового поколения</i> в отличие от современных <i>программных компьютерных систем</i>, должны оперировать <i>смыслом</i> того, что они знают и обрабатывают: они должны понимать друг друга, находить точки соприкосновения и образовывать коллективы для решения <i>задач</i> любого класса (см. Ouksel1999, Neiva2016, Lu2022).
				<li> Для эффективной реализации даже существующих моделей представления знаний и моделей решения трудно формализуемых задач современные компьютеры оказываются плохо приспособленными, что требует разработки принципиально новых платформ и компьютеров, обеспечивающих унификацию представления этих знаний (см. Hagoort2009, Siekmann1984).</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*);;
		*);;

		.system_element_407
		=> .system_element_172: [<p>Программный вариант реализации ostis-платформы</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>Программный вариант реализации базового интерпретатора sc-моделей ostis-систем на традиционных компьютерах</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>Базовая программная платформа для массового создания интеллектуальных компьютерных систем нового поколения</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>Программная реализация платформы интерпретации sc-моделей компьютерных систем</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>Предлагаемый нами программный вариант реализации ассоциативного семантического компьютера</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
			=> nrel_explanation: [<p>Одним из путей, позволяющих осуществлять апробацию, развитие, а в ряде случаев и внедрение новых моделей и технологий вне зависимости от наличия соответствующих аппаратных средств является разработка программных моделей этих аппаратных средств, которые были бы функционально эквивалентны этим аппаратным средствам, но при этом интерпретировались на базе традиционной аппаратной архитектуры (в данной работе традиционной архитектурой будем считать архитектуру фон Неймана, как доминирующую в настоящее время). Очевидно, что производительность таких программных моделей в общем случае будет ниже, чем самих аппаратных решений, однако в большинстве случаев она оказывается достаточной для того, чтобы развивать соответствующую технологию параллельно с разработкой аппаратных средств и осуществления постепенного перевода уже работающих систем с программной модели на аппаратные средства.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);
		=> nrel_idtf: [<p>Реализация sc-машины</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_idtf: [<p>sc-machine</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		<- .system_element_4308;
		<- .system_element_4309
		(*
			=> nrel_idtf: [<p>вариант реализации платформы интерпретации sc-моделей компьютерных систем, предполагающий взаимодействие пользователей с системой <u>посредством</u> сети Интернет</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);
		<- .system_element_4310;
		<- .system_element_294;
		<- .system_element_244;
		<- .system_element_287;
		<- .system_element_290;
		=> .system_element_246: [<p>https://github.com/ostis-ai/sc-machine</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> nrel_authors: 
			.system_element_4293;
			.system_element_4311
		;
		=> .system_element_4312: {
			.system_element_4313;
			.system_element_4314;
			.system_element_4315;
			.system_element_245
		};
		=> .system_element_130: {
			.system_element_4313
		};
		=> .system_element_2811: [<p>Поскольку sc-тексты представляют собой семантические сети, то есть, по сути, графовые конструкции определенного вида, то на нижнем уровне задача разработки программного варианта реализации платформы интерпретации sc-моделей сводится к разработке средств хранения и обработки таких графовых конструкций.К настоящему времени разработано большое количество простейших моделей представления графовых конструкций в линейной памяти, таких как матрицы смежности, списки смежности и другие (Diskrete_Math). Однако, при разработке сложных систем как правило приходится использовать более эффективные модели, как с точки зрения объема информации, требуемого для представления, так и с точки зрения эффективности обработки графовых конструкций, хранимых в той или иной форме. К наиболее распространенным программным средствам, ориентированным на хранение и обработку графовых конструкций относятся графовые СУБД (Neo4j Neo4j, ArangoDB ArangoDB, OrientDB OrientDB, Grakn Grakn и др.), а также так называемые rdf-хранилища (Virtuoso Virtuoso, Sesame Sesame и др.), предназначенные для хранения конструкций, представленных в модели RDF. Для доступа к информации, хранимой в рамках таких средств, могут использоваться как языки, реализуемые в рамках конкретного средства (например, язык Cypher в Neo4j), так и языки, являющиеся стандартами для большого числа систем такого класса (например, SPARQL для rdf-хранилищ).Популярность и развитость такого рода средств приводит к тому, что на первый взгляд целесообразным и эффективным кажется вариант реализации <i>программного варианта реализации платформы интерпретации sc-моделей</i> на базе одного из таких средств. Однако, существует ряд причин, по которым было принято решение о реализации <i>программного варианта реализации платформы интерпретации sc-моделей</i> с нуля. К ним относятся следующие:
		<ul>
			<li> Для обеспечения эффективности хранения и обработки <i>информационных конструкций</i> определенного вида (в данном случае --- <i>sc-конструкций</i>), должна учитываться специфика этих конструкций. В частности, описанные в работе Koronchik2013a эксперименты показали значительный прирост эффективности собственного решения по сравнению с существующими на тот момент.   
			<li> В отличие от классических <i>графовых конструкций</i>, где <i>дуга</i> или <i>ребро</i> могут быть инцидентны только <i>узлу</i> <i>графа</i> (это справедливо и для <i>rdf-графов</i>) в <i>SC-коде</i> вполне типичной является ситуация, когда <i>sc-коннектор</i> инцидентен другому <i>sc-коннектору</i> или даже двум <i>sc-коннекторам</i> Ivashenko2022. В связи с этим существующие средства хранения <i>графовых конструкций</i> не позволяют в явном виде хранить <i>sc-конструкции</i> (<i>sc-графы</i>). Данная проблема также решаема при переходе от <i>неориентированного графа</i> к <i>орграфу</i> Ivashenko2015.
			<li> В основе обработки информации в рамках <i>Технологии OSTIS</i> лежит <i>многоагентный подход</i> Shunkevich2022, в рамках которого агенты обработки информации, хранимой в sc-памяти (sc-агенты) реагируют на события, происходящие в sc-памяти и обмениваются информацией посредством спецификации выполняемых ими действий в sc-памяти Shunkevich2018. В связи с этим одной из важнейших задач является реализация в рамках <i>Программного варианта реализации ostis-платформы</i> возможности подписки на события, происходящие в программной модели sc-памяти, которая на данный момент практически не поддерживается в рамках современных средств хранения и обработки графовых конструкций.
			<li> <i>SC-код</i> позволяет описывать также внешние <i>информационные конструкции</i> любого рода (изображения, текстовые файла, аудио- и видеофайлы и так далее Ivashenko2022, которые формально трактуются как содержимое <i>sc-элементов</i>, являющихся знаками <i>внешних файлов ostis-системы</i>. Таким образом, компонентом <i>Программного варианта ostis-платформы</i> должна быть реализация файловой памяти, которая позволяет хранить указанные конструкции в каких-либо общепринятых форматах. Реализация такого компонента в рамках современных средств хранения и обработки <i>графовых конструкций</i> также не всегда представляется возможной.</li>
		<ul>По совокупности перечисленных причин было принято решение о реализации <i>программного варианта реализации платформы интерпретации sc-моделей</i> "с нуля" с учетом особенностей хранения и обработки информации в рамках Технологии OSTIS.</p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);
		=> .system_element_4316: {
			[<p>Текущая <i>Программная платформа ostis-систем</i> является <u>web-ориентированным</u>, поэтому с этой точки зрения каждая <b>ostis-система</b> представляет собой web-сайт, доступный онлайн посредством обычного браузера. Такой вариант реализации обладает очевидным преимуществом --- доступ к системе возможен из любой точки мира, где есть Интернет, при этом для работы с системой не требуется никакого специализированного программного обеспечения. С другой стороны, такой вариант реализации обеспечивает возможность параллельной работы нескольких пользователей с системой.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Реализация является <u><i>кроссплатформенной</i></u> и может быть собрана из исходных текстов в различных <i>операционных системах</i>. В то же время, взаимодействие клиентской и серверной части организовано таким образом, что <b>web-интерфейс</b> может быть легко заменен на настольный или мобильный интерфейс, как универсальный, так и специализированный.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Текущий вариант реализации ostis-платформы является <u>базовым</u>, то есть включает <i>Реализацию scp-интерпретатора</i>).</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p><u>Ядром</u> этой платформы является <i>Реализация sc-памяти</i>. Текущая <i>Реализация sc-памяти</i> <u>функционально полна</u>, то есть позволяет хранить <i>sc-конструкции</i>, с помощью которых описывается любая <i>sc-модель ostis-системы</i>, внешние <i>информационные конструкции</i>, не принадлежащие <i>SC-коду</i>, а также предоставлять различные уровни доступа для обработки этих конструкций. В контексте текущего <i>Программного варианта реализации ostis-платформы</i> <i>Реализация sc-памяти</i> включает <i>Реализацию файловой памяти</i>, предназначенной для хранения внешних <i>информационных конструкций</i>, не принадлежащих <i>SC-коду</i>, то есть содержимое <i>внутренних файлов ostis-системы</i>, но дополнительно описывающие, поясняющие и детализирующие <i>sc-конструкции</i> <i>sc-моделей ostis-систем</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			[<p>Текущая <i>Программная платформа ostis-систем</i> включает <i>Реализацию менеджера многократно используемых компонентов ostis-систем</i>. В первую очередь это связано с тем, что текущая <i>Реализация менеджера многократно используемых компонентов ostis-систем</i> использует <i>Реализацию sc-памяти ostis-платформы</i> для хранения и обработки спецификаций устанавливаемых компонентов вне зависимости от языка их реализации, а также является платформенно-зависимым многократно используемым компонентом ostis-систем.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*)
		};;

		.system_element_4317
		=> nrel_inclusion: [*
			=> nrel_idtf: [<p>Документация Реализации sc-памяти в Программной платформе ostis-систем</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			-> rrel_key_sc_element: .system_element_4318;
			=> nrel_authors: 
				.system_element_4293
			;;

			.system_element_4313
			=> nrel_idtf: [<p>Программный вариант реализации графодинамической ассоциативной памяти в Программной платформе ostis-систем</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			=> nrel_idtf: [<p>Программная модель семантической памяти, реализованная на основе традиционной линейной памяти и включающая средства хранения sc-конструкций и базовые средства для обработки доступа к этим конструкциям, в том числе удаленного доступа к ним посредством соответствующих сетевых языков (протоколов)</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			=> nrel_idtf: [<p>Предлагаемый нами вариант реализации графодинамической ассоциативной памяти для ostis-систем</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			<- .system_element_4319;
			<- .system_element_294;
			<- .system_element_244;
			<- .system_element_287;
			<- .system_element_290;
			=> .system_element_246: [<p>https://github.com/ostis-ai/sc-machine/tree/main/sc-memory</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			=> .system_element_130: {
				.system_element_4320;
				.system_element_4321
			};
			=> .system_element_4322: 
				.system_element_4323;
				.system_element_217
			;
			=> .system_element_936: .system_element_4324;
			=> nrel_authors: 
				.system_element_4293;
				.system_element_4311
			;
			<= .system_element_4325: sc_memory
			(*
				<= nrel_set_of_subsets: .system_element_4326
				(*
					=> nrel_idtf: [<p>страница sc-памяти</p>];;
					=> nrel_explanation: [<p>В рамках данного <i>Программного варианта реализации ostis-платформы</i> <i>sc-память</i> моделируется в виде набора <i>сегментов</i>, каждый из которых представляет собой фиксированного размера упорядоченную последовательность <i>элементов sc-памяти</i>, каждый из которых соответствует конкретному <i>sc-элементу</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;
					<= nrel_set_of_subsets: .system_element_4327
					(*
						=> nrel_explanation: [<p>В настоящее время каждый сегмент состоит из 2<sup>16</sup>-165535 <i>элементов sc-памяти</i>. Каждый сегмент состоит из набора структур данных, описывающих конкретные <i>sc-элементы</i> (элементов sc-памяти). Независимо от типа описываемого sc-элемента каждый <i>элемент sc-памяти</i> имеет фиксированный размер (в текущий момент --- 44 байт), что обеспечивает удобство их хранения. Таким образом, максимальный размер базы знаний в текущей программной модели sc-памяти может достигнуть 223 Гб (без учета содержимого <i>внутренних файлов ostis-системы</i>, хранимого в файловой памяти).</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;
					*);;
					=> nrel_note: [<p>Выделение <i>сегментов sc-памяти</i> позволяет, с одной стороны, упростить адресный доступ к <i>элементам sc-памяти</i>, с другой стороны --- реализовать возможность выгрузки части <i>sc-памяти</i> из <i>оперативной памяти</i> на <i>файловую систему</i> при необходимости. Во втором случае сегмент <i>sc-памяти</i> становится минимальной (атомарной) выгружаемой частью sc-памяти. Механизм выгрузки сегментов реализуется в соответствии с существующими принципами организации виртуальной памяти в современных <i>операционных системах</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;
					=> nrel_note: [<p>По умолчанию все сегменты физически располагаются в оперативной памяти, если объема памяти не хватает, то предусмотрен механизм выгрузки части сегментов на жесткий диск (механизм виртуальной памяти).</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;
				*);;
				=> nrel_note: [<p>Такую модель sc-памяти достаточно просто описывать на <i>sc-языке</i>, то есть на подъязыке <i>SC-кода</i>. Такой язык позволяет описывать то, как внутри sc-памяти <i>ostis-платформы</i> представляются тексты языка, на этом же языке. При этом соблюдается не только унификация представления информации, обрабатываемой <i>ostis-платформой</i>, и информации, описывающей саму <i>ostis-платформу</i>, но и даются возможности для расширения и использования языка в процессе эволюции <i>ostis-платформы</i> и ее компонентов, в том числе в процессе эволюции <i>Реализации sc-памяти</i>.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*);
			=> .system_element_4312: {
				.system_element_4328;
				.system_element_4329;
				.system_element_4330;
				.system_element_4331;
				.system_element_4332
			};
			=> nrel_note: [<p>Текущий вариант <i>Реализации sc-памяти</i> предполагает возможность сохранения состояния (слепка) <i>sc-памяти</i> на жесткий диск и последующей загрузки из ранее сохраненного состояния. Такая возможность необходима для перезапуска системы, в случае возможных сбоев, а также при работе с исходными текстами <i>базы знаний</i>, когда сборка из исходных текстов сводится к формированию слепка состояния памяти, который затем помещается в <i>Реализации sc-памяти</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			=> nrel_note: [<p>В общем случае <i>sc-память</i> может быть реализована по-разному. Так, например, другой вариант <i>sc-памяти ostis-платформы</i> можно реализовать при помощи программной реализации <i>Графовой СУБД Neo4j</i>. Отличие такого возможного варианта реализации <i>sc-памяти</i> от текущего состоит в том, что хранение <i>графовых конструкций</i> и управление потоком действий над ними должно осуществляться в большей мере средствами, предоставляемыми <i>Графовой СУБД Neo4j</i>, в то же время представление <i>графовых конструкций</i> должно реализовываться по-своему, поскольку зависит от <i>Cинтаксиса SC-кода</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;

			.system_element_4333
			=> nrel_inclusion: [*
				=> nrel_idtf: [<p>Документация Метаязыка описания представления sc-конструкций в текущей Реализации sc-памяти Программной платформы ostis-систем</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				-> rrel_key_sc_element: .system_element_4334;
				=> nrel_authors: 
					.system_element_4293
				;
				=> .system_element_4298: [<p>В <i>общих принципах документирования Программной платформы ostis-систем</i> упоминалось об <i>sc-языках</i>, которые используются при описании компонентов текущего <i>Программного варианта реализации ostis-платформы</i>. Один из таких <i>sc-языков</i> описывает то, как <i>sc-конструкции</i> хранятся внутри <i>sc-памяти ostis-платформы</i>. Такой язык называется <b><i>Метаязыком описания представления sc-конструкций в текущей Реализации sc-памяти Программной платформы ostis-систем</i></b>, или, кратко, <i><b>SCin-кодом</b> (Semantic Сode interior)</i>. <i>sc-память</i> текстов <i>SC-кода</i> (как некоторую абстрактную модель, по которой можно реализовать <i>sc-память ostis-платформы</i>) можно рассматривать как подмножество <i>sc.in-текста</i>.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;

				.system_element_4324
				=> nrel_idtf: [<p>Semantic Code interior</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> nrel_idtf: [<p>Язык описания представления SC-кода внутри sc-памяти ostis-платформы</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> nrel_idtf: [<p>Метаязык описания представления sc-конструкций в текущей Реализации sc-памяти Программной платформы ostis-систем</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> .system_element_172: [<p>sc.in-текст</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
					<- .system_element_2012;;
				*);
				<- .system_element_2128;
				<- .system_element_4335;
				<- sc_lang;
				<= nrel_inclusion: .system_element_962;
				=> nrel_inclusion: sc_memory;
				=> nrel_authors: 
					.system_element_4293
				;;

				.system_element_265
				-> {
					.system_element_962
					(*
						=> nrel_idtf: [<p>Универсальный язык внутреннего смыслового представления знаний в памяти ostis-систем</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;
					*);
					.system_element_4324
					(*
						=> nrel_idtf: [<p>Метаязык описания представления SC-кода в sc-памяти ostis-платформы</p>];;
						<= nrel_inclusion: .system_element_962;;
					*)
				};;

				.system_element_4336
				=> nrel_inclusion: [*
					=> nrel_note: [<p>Одним из замечательных достоинств <i>SC-кода</i> является то, что синтаксис любого его <i>подъязыка</i> наследует свойства <i>Синтаксиса SC-кода</i>. То есть форма представления различных знаний, описываемых его подъязыками, остается одна и та же. В данном случае, <i>Синтаксис SCin-кода</i> не является исключением и уточняет семантику <i>Синтаксиса SC-кода</i>. При этом <i>Синтаксис SCin-кода</i>, как и синтаксис любого другого sc-языка, является частью <i>Денотационной семантики SCin-кода</i>. То есть <i>Синтаксис SCin-кода</i> описывает семантику того, как формируются sc.in-тексты при помощи <i>Синтаксических правил SCin-кода</i>. <b><i>Синтаксис SCin-кода</i></b> задается: (1) <i>Алфавитом SCin-кода</i>, (2) отношением инцидентности <i>sc-адрес элемента sc-памяти*</i>. <i>Алфавит SCin-кода^</i>, а также отношение инцидентности <i>sc-адрес элемента sc-памяти*</i> являются подмножествами <i>Алфавит SC-кода^</i> и отношений инцидентности <i>SC-кода</i> соответственно, при этом правила <i>Синтаксиса SCin-кода</i> включают правила <i>Синтаксиса SC-кода</i> и правила, которые уточняют нюансы <i>Синтаксиса SCin-кода</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4337
					=> nrel_idtf: [<p>синтаксический класс элемента sc-памяти</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_idtf: [<p>синтаксический тип элемента sc-памяти</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_idtf: [<p>Множество классов элементов sc-памяти</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_idtf: [<p>Множество типов элементов sc-памяти</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					<= .system_element_827: .system_element_4324;
					<=> .system_element_72: {
						.system_element_4338;
						.system_element_4339;
						.system_element_4340
						(*
							<- singletone;;
						*)
					};
					=> nrel_explanation: [<p><b><i>Алфавит SCin-кода^</i></b> состоит из трех синтаксически выделяемых классов элементов sc-памяти: <i>элемента sc-памяти, соответствующего sc-узлу</i>, <i>элемента sc-памяти, соответствующего sc-коннектору</i>, и <i>элемента sc-памяти, имеющего нулевой sc-адрес</i>. Такой алфавит не только позволяет задавать в <i>sc-памяти</i> минимальный набор объектов, с которым можно производить вычислительные операции, но и, при необходимости, удобен для расширения. Так, например, даннный алфавит языка можно расширить, добавив в него <i>элемент sc-памяти, соответствующий внутреннему файлу ostis-системы</i>, либо <i>элемент sc-памяти, соответствующий sc-ребру</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4327
					=> nrel_idtf: [<p>элемент sc-памяти, соответствующий sc-элементу</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_idtf: [<p>ячейка sc-памяти</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_idtf: [<p>образ sc-элемента в рамках sc-памяти</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_idtf: [<p>структура данных, каждый экземпляр которой в рамках sc-памяти соответствует одному sc-элементу</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_idtf: [<p>sc_element</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
						<- .system_element_4323;;
					*);
					<- sc_element;
					=> nrel_inclusion: sc_element;
					=> nrel_subdividing: .system_element_4337;;

					.system_element_4341
					=> nrel_idtf: [<p>адрес элемента sc-памяти, соответствующего заданному sc-элементу, в рамках текущего варианта реализации sc-памяти</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_idtf: [<p>sc_addr</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
						<- .system_element_4323;;
					*);
					=> nrel_idtf: [<p>scAddr</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
						<- .system_element_217;;
					*);
					=> nrel_explanation: [<p>Каждый элемент sc-хранилища в текущей реализации может быть однозначно задан его адресом (sc-адресом), состоящим из номера сегмента и номера <i>элемента sc-памяти</i> в рамках сегмента. Таким образом, <i>sc-адрес</i> служит уникальными координатами <i>элемента sc-памяти</i> в рамках <i>Реализации sc-памяти</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_note: [<p>sc-адрес никак не учитывается при обработке базы знаний на семантическом уровне и необходим только для обеспечения доступа к соответствующей структуре данных, хранящейся в линейной памяти на уровне <i>Реализации sc-памяти</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_note: [<p>В общем случае sc-адрес элемента sc-памяти, соответствующего заданному sc-элементу, может меняться, например, при пересборке базы знаний из исходных текстов и последующем перезапуске системы. При этом sc-адрес элемента sc-памяти, соответствующего заданному sc-элементу, непосредственно в процессе работы системы в текущей реализации меняться не может.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> .system_element_4342: 
						.system_element_4343;
						.system_element_4344
					;
					=> nrel_explanation: [<p>Для каждого <i>sc-адреса элемента sc-памяти</i> можно <i>взаимно однозначно</i> поставить в соответствие некоторый <i>хэш</i>, полученный в результате применения специальной <i>хэш-функции*</i> над этим <i>sc-адресом элемента sc-памяти</i>. <i>хэш</i> является <i>неотрицательным целым числом</i> и является результатом преобразования <i>номера sc-сегмента sc-памяти</i> <i>si</i>, в котором располагается <i>элемент sc-памяти</i>, и <i>номера</i> этого <i>элемента sc-памяти</i> <i>ei</i> <i>в рамках</i> этого <i>sc-сегмента</i> <i>si</i>. В рамках <i>sc-памяти</i> используется единственная <i>хеш-функция*</i> для получения <i>хеша sc-адреса элемента sc-памяти</i> и задается как f(si, ei) = si << 16 ∨ ei ∧ 0xffff, где операция << --- операция <i>битового сдвига влево*</i> левого аргумента на количество единиц, заданное правым аргументом, относительно этой операции, операция ∨ --- операция <i>битового сложения*</i>, операция ∧ --- операция <i>битового умножения*</i>, число 0xffff --- <i>Число 65535</i>, представленное в шестнадцатеричном виде и обозначающее максимальное количество элементов в одном <i>sc-сегменте sc-памяти</i>. Числовое выражение <i>sc-адреса</i> является <i>32-битовым целым числом</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_explanation: [<p>Отношение <b><i>sc-адрес элемента sc-памяти*</i></b> определяется как <i>взаимно однозначное соответствие</i>, первым компонентом каждой ориентированной пары которого является некоторый элемент sc-памяти, соответствующей некоторому sc-элементу, а вторым компонентом является sc-адрес этого <i>элемента sc-памяти</i>. То есть каждый <i>элемент sc-памяти</i> имеет уникальный <i>sc-адрес</i> как некоторый идентификатор, с помощью которого определяется уникальность <i>элемента sc-памяти</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4345
					=> nrel_idtf: [<p>класс всех синтаксических и семантических классов элементов sc-памяти</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_idtf: [<p>битовая маска, обозначающая синтаксический и семантический класс элемента sc-памяти</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_idtf: [<p>sc_type</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
						<- .system_element_4323;;
					*);
					=> nrel_idtf: [<p>scType</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
						<- .system_element_217;;
					*);
					=> nrel_subdividing: {
						.system_element_4346;
						.system_element_4347
					};
					<= .system_element_840: [<p>В рамках любой <i>реализации sc-памяти</i> должен существовать набор <i>синтаксических</i> и <i>семантических классов элементов sc-памяти^</i> (меток), которые:
					<ul>
						<li> задают тип элемента на уровне <i>ostis-платформы</i> и не имеют соответствующей <i>sc-дуги принадлежности</i> (а точнее --- <i>базовой sc-дуги</i>), явно хранимой в рамках sc-памяти (ее наличие подразумевается, однако она не хранится явно, поскольку это приведет к бесконечному увеличению числа элементов, которые необходимо хранить в <i>sc-памяти</i>);
						<li> могут быть представлены в виде параметров соответствующих <i>элементов sc-памяти</i>, то есть множеством таких элементов, каждый из которых имеет "метку", выраженную некоторым числовым значением;
						<li> могут уточнять <i>класс элементов sc-памяти</i> с той степенью детализации, которая необходима чтобы, например, при совершении операции поиска с помощью таких <i>классов элементов sc-памяти^</i> можно было легко определить класс конкретного из них.</li>
					<ul>С этой целью, в <i>SCin-коде</i> выделяется базовая <b><i>Cинтаксическая классификация элементов SCin-кода</i></b>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4348
					=> nrel_inclusion: [*

						.system_element_4327
						=> nrel_subdividing: {
							.system_element_4338
							(*
								<- .system_element_4346;;
							*);
							.system_element_4339
							(*
								<- .system_element_4346;;
							*);
							.system_element_4340
							(*
								<- .system_element_4346;;
							*)
						};;
					*];
					=> nrel_note: [<p>Для того чтобы представлять и хранить любые <i>sc-конструкции</i> достаточно иметь только два базовых <i>класса элементов sc-памяти</i> (<i>элемент sc-памяти, соответствующий sc-узлу</i>, и <i>элемент sc-памяти, соответствующий sc-коннектору</i>), при этом остальные <i>классы элементов sc-памяти</i> можно добавить в расширенной версии <i>SCin-кода</i> и тем самым дореализовать необходимую логику на уровне конкретной реализации <i>sc-памяти</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_note: [<p>Стоит отметить, что все <b><i>классы элементов sc-памяти^</i></b>, входящие в состав <i>Cинтаксической классификации элементов SCin-кода</i>, являются синтаксически выделяемыми <i>классами элементов SCin-кода</i>, то есть на уровне <i>Реализации sc-памяти</i> такие программные модели этих элементов представляются по-разному.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4349
					=> nrel_subdividing: {
						.system_element_4350;
						.system_element_4351;
						.system_element_4352
					};
					=> nrel_note: [<p>Несмотря на то, что отношение <i>sc-адрес элемента sc-памяти*</i> позволяет полностью описать связи <i>элементов sc-памяти</i>, для спецификации представления конструкций SC-кода внутри sc-памяти только одного отношения <i>sc-адрес элемента sc-памяти*</i> не всегда достаточно, чтобы полностью точно и ясно указывать связи между <i>элементами sc-памяти</i>, соответствующими <i>sc-элементам</i> этих конструкций. Поэтому на практике при описании представления <i>sc-конструкций</i> внутри <i>sc-памяти</i> необходимо использовать более частные отношения этого базового отношения, например, такие, как <i>sc-адрес элемента sc-памяти, соответствующего выходящему sc-коннектору из заданного sc-элемента*</i>, <i>sc-адрес элемента sc-памяти, соответствующего входящему sc-коннектору в заданный sc-элемент*</i> и <i>sc-адрес элемента sc-памяти, соответствующего инцидентному sc-элементу sc-коннектора*</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4350
					=> nrel_subdividing: {
						.system_element_4353;
						.system_element_4354;
						.system_element_4355
					};;

					.system_element_4351
					=> nrel_subdividing: {
						.system_element_4356;
						.system_element_4357;
						.system_element_4358
					};;

					.system_element_4352
					=> nrel_subdividing: {
						.system_element_4359;
						.system_element_4360
					};;

					.system_element_4336
					=> .system_element_2166: [<p>На синтаксические <i>конструкции SCin-кода</i>, кроме ограничения самого <i>SC-кода</i>, накладываются дополнительные ограничения:

					<ul>

						<li> Для каждого <i>элемента sc-памяти</i> взаимно однозначно ставится в соответствие <i>sc-адрес</i> этого <i>элемента sc-памяти</i>.

						<li> Для каждого <i>элемента sc-памяти, соответствующего sc-узлу</i>, существует одна и только одна пара отношения <i>sc-адрес элемента sc-памяти, соответствующего начальному выходящему sc-коннектору из заданного sc-элемента*</i> и одна и только одна пара отношения <i>sc-адрес элемента sc-памяти, соответствующего начальному входящему sc-коннектору в заданный sc-элемент*</i>.

						<li> Для каждого <i>элемента sc-памяти, соответствующего выходящему sc-коннектору из заданного sc-элемента</i> (<i>элемента sc-памяти, соответствующего входящему sc-коннектору в заданный sc-элемент</i>), существует не более чем одна пара отношения <i>sc-адрес элемента sc-памяти, соответствующего следующему выходящему sc-коннектору из заданного sc-элемента*</i> (<i>sc-адрес элемента sc-памяти, соответствующего следующему входящему sc-коннектору в заданный sc-элемент*</i>) и не более чем одна пара отношения <i>sc-адрес элемента sc-памяти, соответствующего предыдущему выходящему sc-коннектору из заданного sc-элемента*</i> (<i>sc-адрес элемента sc-памяти, соответствующего предыдущему входящему sc-коннектору в заданный sc-элемент*</i>).

						<li> Для каждого <i>элемента sc-памяти, соответствующего sc-коннектору</i>, который является вторым компонентом каждой пары отношения <i>sc-адрес элемента sc-памяти, соответствующего начальному выходящему sc-коннектору из заданного sc-элемента*</i> (<i>sc-адрес элемента sc-памяти, соответствующего начальному входящему sc-коннектору в заданный sc-элемент*</i>) существует только и только одна пара отношения <i>sc-адрес элемента sc-памяти, соответствующего следующему выходящему sc-коннектору из заданного sc-элемента*</i> (<i>sc-адрес элемента sc-памяти, соответствующего следующему входящему sc-коннектору в заданный sc-элемент*</i>).</li>

					<ul></p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;
				*];;

				.system_element_4361
				=> nrel_inclusion: [*
					=> nrel_note: [<p>Для каждого <i>класса sc-элементов</i> должна существовать программная модель <i>класса элементов sc-памяти^</i>, которая удовлетворяет всем перечисленным требованиям. Поэтому важно, чтобы <i>Алфавит SCin-кода</i> изначально был полон, чтобы погрузить не только <i>sc-конструкции</i> <i>Ядра SC-кода</i>, но и его расширенных версий. Для этого разработаны <b><i>семантические классы элементов sc-памяти^</i></b>, спецификация которых представляется в виде <b><i>Семантической классификации элементов SCin-кода</i></b>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4362
					=> nrel_inclusion: [*

						.system_element_4327
						=> nrel_subdividing: .system_element_4363
						(*
							<=> .system_element_72: {
								.system_element_4364
								(*
									<- .system_element_4347;;
								*);
								.system_element_4365
								(*
									<- .system_element_4347;;
								*);
								.system_element_4366
								(*
									<- .system_element_4347;;
								*)
							};;
						*);
						=> nrel_subdividing: .system_element_4367
						(*
							<=> .system_element_72: {
								.system_element_4368
								(*
									<- .system_element_4347;;
								*);
								.system_element_4369
								(*
									<- .system_element_4347;;
								*)
							};;
						*);
						=> nrel_subdividing: .system_element_4370
						(*
							=> nrel_idtf: [<p>класс уровня доступа к элементу sc-памяти</p>];;
							<=> .system_element_72: {
								.system_element_4371
								(*
									<- .system_element_4347;;
								*);
								.system_element_4372
								(*
									<- .system_element_4347;;
								*)
							};;
						*);
						=> nrel_inclusion: .system_element_4373;;

						.system_element_4374
						=> nrel_subdividing: .system_element_4375
						(*
							<=> .system_element_72: {
								.system_element_4376
								(*
									<- .system_element_4347;;
								*);
								.system_element_4377
								(*
									<- .system_element_4347;;
								*);
								.system_element_4378
								(*
									<- .system_element_4347;;
								*);
								.system_element_4379
								(*
									<- .system_element_4347;;
								*);
								.system_element_4380
								(*
									<- .system_element_4347;;
								*);
								.system_element_4381
								(*
									<- .system_element_4347;;
								*);
								.system_element_4382
								(*
									<- .system_element_4347;;
								*)
							};;
						*);
						=> nrel_subdividing: .system_element_4383
						(*
							<=> .system_element_72: {
								.system_element_4384
								(*
									<- .system_element_4347;;
								*);
								.system_element_4385
								(*
									<- .system_element_4347;;
								*)
							};;
						*);
						=> nrel_subdividing: .system_element_4386
						(*
							<=> .system_element_72: {
								.system_element_4387
								(*
									<- .system_element_4347;;
								*);
								.system_element_4388
								(*
									<- .system_element_4347;;
								*);
								.system_element_4389
								(*
									<- .system_element_4347;;
								*)
							};;
						*);;
					*];
					=> nrel_explanation: [<p>Все семантически и синтаксически выделяемые <i>классы элементов sc-памяти^</i>, а также всевозможные подклассы этих классов являются экземплярами (элементами) sc-класса. Все перечисленные классы на уровне программной <i>Реализации sc-памяти</i> выражаются в виде битов в битовой строке, описываемой в каждом <i>элементе sc-памяти</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_note: [<p>В текущий момент <i>sc-ребра</i> хранятся так же, как <i>sc-дуги</i>, то есть имеют начальный и конечный <i>sc-элементы</i>, отличие заключается только в <i>семантическом классе элемента sc-памяти^</i>. Это приводит к ряду неудобств при обработке, но <i>sc-ребра</i> используются в настоящее время достаточно редко.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_note: [<p><b><i>Спецификация SCin-кода</i></b> является объединением спецификацией его <i>элементов sc-памяти</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4390
					=> nrel_decomposition: {
						.system_element_4391;
						.system_element_4392
					};
					=> nrel_note: [<p>Каждый <i>элемент sc-памяти</i> описывается его синтаксическим типом (меткой), а также независимо от <i>класса элемента sc-памяти^</i> указывается <i>sc-адрес первого входящего в данный sc-элемент sc-коннектора</i> и <i>sc-адрес первого выходящего из данного sc-элемента sc-коннектора</i> (могут быть пустыми, если таких sc-коннекторов нет). Оставшиеся байты в зависимости от <i>класса элемента sc-памяти</i> (sc-узел или sc-коннектор) могут использоваться для хранения спецификации <i>элемента sc-памяти, соответствующего sc-коннектору</i>. Также <i>sc-адрес первой sc-дуги, выходящей из данного sc-элемента*</i> и <i>sc-адрес первой sc-дуги, входящей в данный sc-элемент*</i> в общем случае могут отсутствовать (быть нулевыми, "пустыми"), но размер <i>элемента sc-памяти</i> в байтах останется тем же.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4393
					=> nrel_inclusion: [*

						.system_element_4338
						=> .system_element_4342: 
							.system_element_4345;
							.system_element_4394;
							.system_element_4349;
							.system_element_4395;
							.system_element_4396
						;;
					*];;

					.system_element_4397
					=> nrel_inclusion: [*

						.system_element_4339
						=> .system_element_4342: 
							.system_element_4345;
							.system_element_4394;
							.system_element_4349;
							.system_element_4359;
							.system_element_4360;
							.system_element_4353;
							.system_element_4356;
							.system_element_4354;
							.system_element_4357;
							.system_element_4355;
							.system_element_4358
						;;
					*];
					=> nrel_note: [<p>В текущей <i>Реализации sc-памяти</i> <b><i>классы уровня доступа^</i></b> используются для того, чтобы обеспечить возможность ограничения доступа некоторых <i>процессов в sc-памяти</i> к некоторым <i>элементам sc-памяти</i>. Каждый <i>элемент sc-памяти</i> принадлежит одному из двух классов: классу <i>элементов sc-памяти, соответствующих sc-элементам, на которых разрешено право чтения</i> и классу <i>элементов sc-памяти, соответствующих sc-элементам, на которых разрешено право записи</i>, каждый из которых выражается <i>целым числом</i> от 0 до 255.Таким образом нулевое значение числовых выражений класса <i>элементов sc-памяти, соответствующих sc-элементам, на которых разрешено право чтения</i> и класса <i>элементов sc-памяти, соответствующих sc-элементам, на которых разрешено право записи</i> означает, что любой процесс может получить неограниченный доступ к данному <i>элементу sc-памяти</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;
				*];;

				.system_element_4398
				<=> nrel_semantic_equivalence: "file://images/sc_code_in_memory_representation.png"
				(*
					<- concept_file;;
					=> nrel_format: format_png;;
				*);
				=> nrel_explanation: [<p>На рисунке представлены пятиэлементная sc-конструкция (слева) и конструкция в sc-памяти, представленная на SCin-коде (справа). На рисунке изображен пример спецификации представления sc-конструкции в <i>sc-памяти ostis-платформы</i>. Здесь каждому sc-элементу заданной sc-конструкции ставится в соответствие sc-элемент, обозначающий элемент sc-памяти, соответствующий непосредственно этому sc-элементу. Для каждого sc-элемента, обозначающего элемент sc-памяти некоторого sc-элемента заданной sc-конструкции описываются связи между элементами sc-памяти, а также синтаксические и семантические классы этих элементов.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> .system_element_4399: [<p><u>Любой</u> <i>sc-конструкции</i> взаимно-однозначно соответствует <i>конструкция sc-памяти</i> <i>ostis-платформы</i>. Погрузка <i>sc-конструкции</i> в <i>sc-память ostis-платформы</i> означает трансляцию каждого sc-элемента этой <i>sc-конструкции</i> и связей инцидентности между этими sc-элементами в <i>sc-память ostis-платформы</i>, то есть трансляцию синтаксической структуры sc-конструкции в соответствующее представление внутри <i>памяти ostis-системы</i>. В общем случае, алгоритм погрузки любой произвольной sc-конструкции в <i>sc-память ostis-платформы</i> состоит из следующих этапов:
				<ul>
					<li> Выделение sc-узлов и их синтаксических и семантических классов в sc-конструкции и создание соответствующих элементов в sc-памяти ostis-платформы при помощи <i>Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-узлу</i>;
					<li> Выделение всех независимых sc-коннекторов и их синтаксических и семантических классов в sc-конструкции (то есть sc-коннекторов, у которых начальным и конечным sc-элементом не являются другие sc-коннекторы) между sc-узлами, для которых были созданы на шаге 1 соответствующие элементы в sc-памяти, и создание соответствующих элементов в sc-памяти ostis-платформы при помощи <i>Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-коннектору</i>;
					<li> Возврат в пункт 2, если остались нетранслированные в sc-память sc-коннекторы (то есть sc-коннекторы, для которых не были созданы соответствующие элементы в sc-памяти ostis-платформы);
					<li> Погрузка содержимого всех внутренних файлов ostis-системы в файловую память ostis-платформы (данный подпроцесс рассмотрен в <i></i>).</li>
				<ul></p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;

				.system_element_4324
				=> .system_element_2880: [<p>Описанная модель представления в текущей <i>Реализации sc-памяти в ostis-платформы</i> <i>синтаксических</i> и <i>семантических классов sc-элементов</i> в виде <i>синтаксических</i> и <i>семантических классов элементов sc-памяти^</i>, которые соответствуют первым, обладает рядом преимуществ:

				<ul>

					<li> <i>cинтаксические</i> и <i>семантические классы элементов sc-памяти^</i> могут <u>комбинироваться</u> между собой для получения более частных классов. С точки зрения программной реализации такая комбинация может быть представлена операцией <i>битовое сложение*</i> <i>классов элементов sc-памяти^</i> (здесь, в спецификации на <i>SC-коде</i> это можно сделать с помощью пересечения соответствующих классов). Так, например, <i>битовое сложение*</i> классов <i>элементов sc-памяти, соответствующих sc-узл</i>у и <i>sc-константе</i> в результате образуют новый <i>класс элементов sc-памяти^</i> --- <i>элемент sc-памяти, соответствующий константному sc-узлу</i>.

					<li> Числовые выражения некоторых классов могут совпадать. Это сделано для уменьшения размера <i>элемента sc-памяти</i> за счет уменьшения максимального размера числового выражения класса этих <i>элементов sc-памяти</i>. Конфликт в данном случае не возникает, поскольку такие классы не могут комбинироваться, например <i>элемент sc-памяти, соответствующий sc-узлу ролевого отношения</i> и <i>элемент sc-памяти, соответствующий sc-дуге нечеткой принадлежности</i>.

					<li> Важно отметить, что каждому из выделенных <i>классов элементов sc-памяти</i> (кроме классов, получаемых путем комбинации других классов) однозначно соответствует порядковый номер бита в линейной памяти, что можно заметить, глядя на соответствующие числовые выражения этих классов. Это означает, что классы элементов не включаются друг в друга (хоть в спецификации это и не так), например, указание принадлежности к классу <i>элементов sc-памяти, соответствующих sc-дуге позитивной принадлежности</i> не означает автоматическое указание принадлежности <i>элементов sc-памяти, соответствующих sc-дуге принадлежности</i>. На уровне реализации это позволяет сделать операции комбинирования и сравнения меток более эффективными.</li>

				<ul></p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*];;

			.system_element_4400
			=> nrel_inclusion: [*
				=> nrel_idtf: [<p>Документация Реализации файловой памяти в Программной платформе ostis-систем</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				-> rrel_key_sc_element: .system_element_4401;
				=> nrel_authors: 
					.system_element_4293
				;
				=> .system_element_4298: [<p><i>SC-код</i> является универсальным средством для представления любых видов знаний, <u>но</u> (!) не всегда есть необходимость погружать что-либо в <i>sc-память ostis-платформы</i>, по крайней мере, на ранних стадиях развития <i>ostis-платформы</i>. Это может быть объяснено и тем, что <i>информационные конструкции, не принадлежащие SC-коду</i>, достаточно сложны в понимании для неподготовленного <i>пользователя ostis-системы</i>. Для решения таких проблем на уровне <i>Алфавита SC-кода^</i> вводится дополнительный элемент --- <i>внутренний файл ostis-системы</i>. С помощью <i>внутренних файлов ostis-системы</i> можно представлять, хранить, обрабатывать и визуализировать <i>информационные конструкции, не принадлежащие SC-коду</i>.Поэтому при реализации <i>sc-памяти</i> необходимо учитывать необходимость хранения <i>информационных конструкций, не принадлежащих SC-коду</i>, с помощью <i>SC-кода</i>. Кроме собственно <i>sc-памяти</i> <i>Реализация sc-памяти</i> включает также <i>Реализацию файловой памяти ostis-платформы</i>, предназначенную для хранения содержимого <i>внутренних файлов ostis-систем</i>, то есть <i>внешние информационные конструкции</i> (линейные тексты, изображения, видео и так далее).За весь период развития <i>Программного варианта реализации ostis-платформы</i> было достаточно много попыток реализовать полно функциональную и быструю файловую память на базе популярных баз данных. Однако из всех этих решений не были учтены потенциальные проблемы при <i>Реализации информационно-поисковой подсистемы Программного варианта реализации ostis-платформы</i>. Сейчас <i>файловая память</i> реализована своими средствами, в качестве структур данных для хранения <i>информационных конструкций</i>, не принадлежащих <i>SC-коду</i>, используются префиксные деревья Bayer1977 и линейные списки.Выбор аргументируется тем, что:
				<ul>
					<li> префиксные структуры достаточно просты в понимании и минимальны в своем синтаксисе;
					<li> с помощью префиксных структур достаточно удобно хранить и обрабатывать связи типа "ключ-значение";
					<li> доступ к значению по ключу происходит в худшем случае за длину этого ключа Belazzougui2010;
					<li> за счет того, что префиксы склеиваются, выходит сильный выигрыш в использовании памяти.</li>
				<ul></p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;

				.system_element_4328
				<- .system_element_4402;
				<= .system_element_4325: .system_element_4403;
				<- .system_element_294;
				<- .system_element_286;
				<- .system_element_290;
				=> .system_element_130: {
					.system_element_4320
				};
				=> .system_element_246: .system_element_4404;
				=> .system_element_4405: 
					.system_element_4323
				;
				=> .system_element_936: 
					.system_element_4406
				;
				=> nrel_authors: 
					.system_element_4293
				;;

				.system_element_4407
				=> nrel_inclusion: [*
					=> nrel_idtf: [<p>Документация Метаязыка описания представления внешних информационных конструкций в текущей Реализации файловой памяти Программной платформы ostis-систем</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					-> rrel_key_sc_element: .system_element_4408;
					=> nrel_authors: 
						.system_element_4293
					;
					=> .system_element_4298: [<p>Для описания представления <i>информационных конструкций</i>, не принадлежащих <i>SC-коду</i>, внутри <i>файловой памяти ostis-платформы</i> также необходим <i>sc-язык</i>. Такой <i>sc-язык</i> называется <b><i>Метаязыком описания представления информационных конструкций, не принадлежащих SC-коду, в файловой памяти ostis-платформы</i></b>, или, кратко, <i><b>SCfin-кодом</b> (Semantic Сode file interior)</i>. <i>файловая память</i> текстов, не принадлежащих <i>SC-коду</i> (как абстрактную модель, по которой можно реализовывать соответствующую ей <i>файловую память ostis-платформы</i>), можно рассматривать как подмножество <i>sc.fin-текста</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4406
					=> nrel_idtf: [<p>Semantic Code file interior</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_idtf: [<p>Язык описания представления информационных конструкций, не принадлежащих SC-коду, внутри файловой памяти ostis-платформы</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_idtf: [<p>Метаязык описания представления информационных конструкций, не принадлежащих SC-коду, текущей Реализации файловой памяти Программной платформы ostis-систем</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> .system_element_172: [<p>sc.fin-текст</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
						<- .system_element_2012;;
					*);
					<- .system_element_2128;
					<- .system_element_4335;
					<- sc_lang;
					<= nrel_inclusion: .system_element_962;
					=> nrel_inclusion: .system_element_4403;
					=> nrel_authors: 
						.system_element_4293
					;;

					.system_element_4409
					=> nrel_inclusion: [*
						=> nrel_note: [<p><i>Синтаксис SCfin-кода</i> задается: (1) <i>Алфавитом SCfin-кода^</i>, (2) отношением порядка <i>последовательность в линейном тексте*</i>.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4410
						=> nrel_idtf: [<p>синтаксический тип элемента файловой памяти</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						=> nrel_idtf: [<p>Множество типов элементов файловой памяти</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= .system_element_827: .system_element_4406;
						<=> .system_element_72: {
							.system_element_4411
						};
						=> nrel_explanation: [<p><b><i>Алфавит SCfin-кода^</i></b> состоит из одного синтаксически выделяемого типа элементов файловой памяти --- <i>элемента файловой памяти, соответствующего подстроке текста линейного языка</i>.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4411
						<- sc_element;
						=> nrel_idtf: [<p>элемент файловой памяти ostis-платформы</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						=> nrel_idtf: [<p>ячейка файловой памяти ostis-платформы</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						=> nrel_idtf: [<p>образ подстроки информационной конструкции, не принадлежащей SC-коду, в рамках файловой памяти ostis-платформы</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4412
						=> nrel_explanation: [<p>Отношение <b><i>последовательности в линейном тексте*</i></b> определяется как бинарное ориентированное отношение порядка, компонентами каждой ориентированной пары которого являются элементы файловой памяти ostis-платформы, соответствующие некоторым подстрокам линейного текста, в результате конкатенации которых образуется подстрока, принадлежащая этому же линейному тексту.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;
					*];
					=> nrel_note: [<p><i>Синтаксис SCfin-кода</i> достаточно прост, поскольку информационные конструкции на нем задаются при помощи <i>Алфавита SCfin-кода^</i>, мощность которого равна 1, и единственного отношения инцидентности <i>последовательности в линейном тексте*</i>. Иерархии синтаксических элементов как таковые не выделяются, поскольку в этом нет необходимости.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4413
					=> nrel_inclusion: [*
						=> nrel_note: [<p>На уровне реализации важно выделить семантические классы <i>элементов файловой памяти, соответствующих подстроке текста линейного языка</i>, которые обозначают некоторую префиксную или постфиксную часть целой информационной конструкции.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4414
						=> nrel_inclusion: [*

							.system_element_4415
							=> nrel_subdividing: .system_element_4416
							(*
								<=> .system_element_72: {
									.system_element_4417;
									.system_element_4418
								};;
							*);;
						*];;
					*];
					=> nrel_note: [<p>На <i>SCfin-коде</i> достаточно просто задавать <i>информационные конструкции</i> любых линейных текстов. Однако с точки зрения реализуемой модели sc-памяти есть необходимость задавать не столько форму <i>информационных конструкций</i>, не принадлежащих <i>SC-коду</i>, внутри <i>файловой памяти ostis-платформы</i>, сколько связи между этими внутренними <i>файлами ostis-системы</i>, являющихся знаками <i>SC-кода</i>. Одновременно должны быть реализованы на уровне <i>sc-памяти</i> и <b><i>Метод получения файлов ostis-системы, которые содержат заданную внешнюю информационную конструкцию</i></b>, и <b><i>Метод получения внешних информационных конструкций из заданных файлов ostis-системы</i></b>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4419
					<=> nrel_semantic_equivalence: "file://images/file_in_memory_representation.png"
					(*
						<- concept_file;;
						=> nrel_format: format_png;;
					*);
					=> nrel_explanation: [<p>На рисунке показано представление <i>информационных конструкций, не принадлежащих SC-коду</i> и соответствия между файлами ostis-системы и информационными конструкциями. С помощью отношения <i>множество sc-адресов файлов ostis-системы по префиксам их содержимого*</i> задается бинарная ориентированная пара, первым компонентом которой является префиксная структура, элементами которой являются подстроки внешних информационных конструкций, а вторым компонентом --- множество соответствующих им sc-адресов файлов ostis-системы, а с помощью отношения <i>множество постфиксов содержимого файлов ostis-системы по их sc-адресам*</i> задается бинарная ориентированная пара, первым компонентом которой является префиксная структура, элементами которой являются подстроки sc-адресов файлов ostis-системы, представленных в строковом виде, а вторым компонентом --- множество соответствующих им постфиксов внешних информационных конструкций префиксной структуры, являющейся первым компонентом каждой пары отношения <i>множество sc-адресов файлов ostis-системы по префиксам их содержимого*</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;
				*];;

				.system_element_4328
				=> .system_element_2880: [<p>Используемая <i>Реализация файловой памяти ostis-платформы</i> полностью оправдывает себя при взаимодействии с системой. Благодаря использованию префиксных структур асимптотические сложности метода получения множества внешних информационных конструкций из заданных <i>файлов ostis-системы</i> и метода получения множества файлов ostis-системы по заданным <i>внешним информационным конструкциям</i> линейны, так как зависит от длины заданной строки и структуры префиксного дерева.Среди общих общих данной <i>Реализации файловой памяти ostis-платформы</i> можно выделить следующие:

				<ul>

					<li> <i>информационные конструкции</i>, не принадлежащие SC-коду, полностью хранятся на диске компьютерного устройства, на котором развернута платформа.

					<li> <i>Реализация файловой памяти ostis-платформы</i> позволяет <u>быстро</u> решать задачи поиска внешних информационных конструкций по их префиксным подстрокам, однако не позволяет быстро решать задачи поиска информационных конструкций по любой подстроке, даже для которого задан некоторый шаблон-образец.</li>

				<ul></p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*];;

			.system_element_4313
			=> .system_element_2880: [<p><i>Реализация sc-памяти</i> учитывает технические аспекты реализации современных <i>операционных систем</i>, что дает следующие достоинства:

			<ul>

				<li> Используемый подход адресации <i>sc-элементов</i> позволяет загружать сегменты с диска в память, а также выгружать их обратно на диск в любой момент и при этом данная операция не требует дополнительных преобразований. Все содержимое из <i>оперативной памяти</i> без изменений попадает на диск. Это дает возможность выгружать неиспользуемые сегменты на диск, что позволяет <i>sc-памяти</i> абстрагироваться от имеющихся ресурсов <i>оперативной памяти</i> и работать на любых ее объемах;

				<li> Максимальное количество хранимых <i>sc-элементов</i> можно увеличивать путем расширения <i>sc-адреса элемента sc-памяти</i>.</li>

			<ul>С точки зрения программной <i>Реализации sc-памяти</i>, структура данных для хранения <i>sc-узла</i> и <i>sc-коннектора</i> остается остается та же, но в ней меняется список полей (компонентов). Кроме того, как можно заметить каждый <i>элемент sc-памяти</i> (в том числе, <i>элемент sc-памяти, соответствующий sc-дуге</i>) не хранит список <i>sc-адресов</i> связанных с ним <i>элементов sc-памяти</i>, а хранит <i>sc-адреса</i> одного <i>выходящего</i> и одного <i>входящего элементов sc-памяти, соответствующих sc-коннекторам</i>, каждый из которых в свою очередь хранит <i>sc-адреса следующего</i> и <i>предыдущего элементов, соответствующих sc-коннекторам</i>, в списке выходящих и входящих <i>элементов sc-памяти.</i> Все перечисленное позволяет:

			<ul>

				<li> сделать размер такой структуры фиксированным (в настоящее время 36 байт) и не зависящим от <i>синтаксического класса</i> хранимого <i>элемента в sc-памяти^</i>;

				<li> с минимальными временными затратами добавлять и удалять инцидентные элементы в и из программной структуры <i>элемента sc-памяти</i> соответственно;

				<li> обеспечить возможность работы с sc-элементами без учета их синтаксического класса в случаях, когда это необходимо (например, при реализации поисковых запросов вида "Какие sc-элементы являются элементами данного множества", "Какие sc-элементы непосредственно связаны с данным sc-элементом" и так далее);

				<li> обеспечить возможность доступа к <i>элементу sc-памяти</i> за константное время;

				<li> обеспечить возможность помещения <i>элемента sc-памяти</i> в процессорный кэш, что в свою очередь, позволяет ускорить обработку <i>sc-конструкций</i>.</li>

			<ul></p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;

			.system_element_4420
			=> nrel_inclusion: [*
				=> nrel_idtf: [<p>Документация Программного интерфейса Реализации sc-памяти в Программной платформе ostis-систем</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				-> rrel_key_sc_element: .system_element_4331;
				=> nrel_authors: 
					.system_element_4293
				;
				=> nrel_explanation: [<p><i>SCin-кода</i> достаточно, чтобы представлять <i>sc-тексты</i> внутри <i>sc-памяти ostis-платформы</i>. Чтобы совершить трансляцию некоторого <i>sc-текста</i> в <i>sc-память ostis-платформы</i> необходимо использовать методы текущей <i>Реализации sc-памяти</i>. Описанные далее методы sc-памяти являются формальной спецификацией текущего <b><i>Программного интерфейса Реализации sc-памяти</i></b>, с помощью которых можно выполнять действия над <i>sc-памятью</i>.В текущей <i>Реализации sc-памяти</i> все программные методы реализованы на <i>языках представления методов</i> <i>C</i> и <i>С++</i>. Текущий <i>Программный интерфейс Реализации sc-памяти</i> содержит необходимый функционал не только для выполнения действий над <i>элементами sc-памяти</i>, но и --- над <i>элементами файловой памяти</i>. Данный <i>программный интерфейс</i> является <u>одним из языков текущего</u> <u><i>Программного варианта реализации ostis-платформы</i></u> для выполнения действий над sc-памятью и может быть использован для решения <i>задач</i> любой информационной сложности. Так, например, данный программный интерфейс используется в текущих <i>Сетевом интерфейсе Реализации sc-памяти</i>, <i>Реализации менеджера многократных используемых компонентов ostis-систем</i> и <i>Реализации интерпретатора логических моделей решения задач</i>, а также при реализации любых <i>платформенно-зависимых ostis-систем</i> любого назначения.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;

				.system_element_4331
				<= .system_element_4421: .system_element_4313;
				<- .system_element_4120;
				<- .system_element_294;
				<- .system_element_286;
				<- .system_element_290;
				=> .system_element_130: {
					.system_element_4320;
					.system_element_4422
				};
				=> .system_element_4423: 
					.system_element_4323;
					.system_element_217
				;
				=> .system_element_936: 
					.system_element_4324
				;
				=> nrel_authors: 
					.system_element_4293;
					.system_element_4311
				;
				=> nrel_inclusion: .system_element_4424
				(*
					=> nrel_idtf: [<p>Информационно-формирующие методы Реализации sc-памяти</p>];;
					=> nrel_idtf: [<p>Подсистема, являющаяся частью Реализации sc-памяти, которая позволяет создавать, изменять и удалять конструкции в sc-памяти</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;
					<= .system_element_4421: .system_element_4425
					(*
						<= nrel_inclusion: .system_element_4313;;
					*);;
				*);
				=> nrel_inclusion: .system_element_4426
				(*
					=> nrel_idtf: [<p>Информационно-поисковые методы Реализации sc-памяти</p>];;
					=> nrel_idtf: [<p>Подсистема, являющаяся частью Реализации sc-памяти, которая позволяет находить конструкции в sc-памяти</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;
					<= .system_element_4421: .system_element_4427
					(*
						<= nrel_inclusion: .system_element_4313;;
					*);;
				*);
				=> nrel_note: [<p>Логически текущий <i>Программный интерфейс Реализации sc-памяти</i> разделяется на два программных интерфейса: <b><i>Программный интерфейс информационно-формирующих методов Реализации sc-памяти</i></b> и <b><i>Программный интерфейс информационно-поисковых методов Реализации sc-памяти</i></b>. В первую очередь, такое разделение связано с тем, что реализация методов информационного поиска в текущей <i>Реализации sc-памяти</i> достаточна сложна и требует намного большего уточнения при описании этой реализации. Также это разделение <i>программного интерфейса</i> позволяет выделять и структурировать спецификацию методов <i>Программного интерфейса Реализации sc-памяти</i> таким образом, чтобы она оставалась однообразной, компактной и простой для внешнего пользователя. Как такового физического разделения в <i>Программном интерфейсе Реализации sc-памяти</i> не существует, все методы <i>Программного интерфейса Реализации sc-памяти</i> можно использовать одним и тем же программным образом и являются компонентами <b><i>Библиотеки многократно используемых компонентов Программного варианта реализации ostis-платформы</i></b>, то есть могут быть использованы при реализации других компонентов специального назначения.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;

				.system_element_4428
				=> nrel_inclusion: [*
					=> nrel_idtf: [<p>Документация Программного интерфейса информационно-формирующих методов Реализации sc-памяти в Программной платформе ostis-систем</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					-> rrel_key_sc_element: .system_element_4429;
					=> nrel_authors: 
						.system_element_4293
					;
					=> nrel_explanation: [<p>Базовыми методами в <i>Программном интерфейсе Реализации sc-памяти</i> являются методы, которые позволяют создавать <i>конструкции в sc-памяти</i>, изменять их, а также удалять эти конструкции из нее. Физически разделяются процессы создания <i>элемента sc-памяти, соответствующего sc-узлу</i>, и <i>элемента sc-памяти, соответствующего sc-коннектору</i>, поскольку соответствующие им <i>sc-элементы</i> являются синтаксически разными, а сами элементы имеют разные программные модели внутри <i>Реализации sc-памяти</i>. Однако процесс удаления этих элементов их sc-памяти никоим образом не отличается. Удаление элемента из sc-памяти предполагает физическое извлечение элемента из линейно-адресуемой <i>sc-памяти</i> и освобождение занимаемого места в <i>оперативной памяти</i> устройства.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4430
					=> nrel_inclusion: [*

						.system_element_4429
						-> .system_element_4431;
						-> .system_element_4432;
						-> .system_element_4433;
						-> .system_element_4434;
						-> .system_element_4435;;
					*];;

					.system_element_4431
					<- .system_element_141;
					=> .system_element_4436: [<p>scAddr scMemoryContext::CreateNode(scType const & type)</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
						<- .system_element_217;;
					*);
					=> .system_element_4437: <
						.system_element_4345
					>;
					=> .system_element_4438: 
						.system_element_4439
					;
					=> .system_element_4440: 
						.system_element_4441;
						.system_element_4442
					;;

					.system_element_4432
					<- .system_element_141;
					=> .system_element_4436: [<p>scAddr scMemoryContext::CreateConnector(scType const & type, scAddr const & begAddr, scAddr const & endAddr)</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
						<- .system_element_217;;
					*);
					=> .system_element_4437: <
						.system_element_4345;
						.system_element_4439;
						.system_element_4439
					>;
					=> .system_element_4438: 
						.system_element_4439
					;
					=> .system_element_4440: 
						.system_element_4443;
						.system_element_4441;
						.system_element_4442
					;
					=> nrel_explanation: [<p>При помощи <b><i>Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-узлу</i></b> и <b><i>Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-коннектору</i></b> можно создавать все программные элементы <i>Алфавита SCin-кода^</i>, соответствующие sc-элементам <i>Алфавита SC-кода^</i> в <i>sc-памяти ostis-платформы</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_explanation: [<p>Для создания <i>элемента в sc-памяти, соответствующего sc-узлу</i>, необходимо указать соответствующий <i>семантический класс элемента в sc-памяти^</i>, являющийся подклассом <i>класса элемента sc-памяти, соответствующего sc-узлу^</i> (см. <i></i>). А для создания <i>элемента в sc-памяти, соответствующего sc-коннектору</i>, кроме того, что необходимо указать соответствующий <i>семантический класс элемента в sc-памяти^</i>, являющийся подклассом <i>класса элемента sc-памяти, соответствующего sc-коннектору^</i> (см. <i></i>), также необходимо указать <i>sc-адреса</i> инцидентных ему <i>элементов sc-памяти</i>: <i>sc-адрес элемента sc-памяти</i>, из которого создаваемый коннектор должен выходить, и <i>sc-адрес элемента sc-памяти</i>, в который данный коннектор должен входить. Такими <i>элементами sc-памяти</i> могут выступать любые <i>элементы sc-памяти</i>, которые уже находятся в ней. При этом при помощи <i>Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-узлу</i> и <i>Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-коннектору</i> нельзя создавать <i>элементы sc-памяти, соответствующие sc-коннекторам</i>, и <i>элементы sc-памяти, соответствующие sc-узлам</i>, соответственно (см. <i></i>). Также не допускается применять <i>Метод создания элемента в sc-памяти, соответствующего некоторому sc-коннектору заданного класса</i> для <i>sc-адресов</i>, которые не являются <i>sc-адресами элементов в sc-памяти</i>. В случае некорректного использования одного из этих методов внешний пользователь метода получит <i>исключительную ситуацию</i> с описанием ошибки. При помощи <i>Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-узлу</i> можно создавать любые <i>элементы sc-памяти, соответствующие sc-узлам</i> или <i>файлам ostis-системы</i>, а при помощи <i>Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-коннектору</i> --- любые <i>элементы sc-памяти, соответствующие sc-коннекторам (sc-ребрам или sc-дугам)</i>.При помощи <b><i>Метода создания элемента в sc-памяти, соответствующего некоторому sc-узлу заданного класса</i></b> и <b><i>Метода создания элемента в sc-памяти, соответствующего некоторому sc-коннектору заданного класса</i></b> можно транслировать в sc-память sc-конструкции любой конфигурации. <i>Общее описание процесса и пример трансляции sc-текста в sc-память ostis-платформы</i> рассмотрены в <i></i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_note: [<p>При реализации прикладных <i>ostis-систем</i> очень часто необходимо создавать сложные <i>конструкции в sc-памяти</i>. Чтобы упростить разработку и сделать текст разрабатываемого метода, использующего <i>Программный интерфейс Реализации sc-памяти</i>, более простым и компактным можно использовать <i>Метод создания конструкции в sc-памяти, изоморфной данному графу-образцу</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4433
					<- .system_element_141;
					=> .system_element_4436: [<p>bool scMemoryContext::EraseElement(scAddr const & addr)</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
						<- .system_element_217;;
					*);
					=> .system_element_4437: <
						.system_element_4439
					>;
					=> .system_element_4438: 
						.system_element_4444
					;
					=> .system_element_4440: 
						.system_element_4443
					;
					=> nrel_explanation: [<p>Любой <i>элемент sc-памяти</i> может быть удален из нее. Для того, чтобы удалить заданный <i>элемент из sc-памяти</i> необходимо применить <b><i>Метод удаления элемента из sc-памяти</i></b> с указанным в качестве аргумента <i>sc-адресом</i> заданного <i>элемента sc-памяти</i>. Если заданный sc-адрес в действительности является <i>sc-адресом</i> некоторого <i>элемента sc-памяти</i>, то этот элемент будет удален из <i>sc-памяти</i>, а метод закончит работу с результатом логического значения <i>Истина</i>. Если указанный sc-адрес является <i>sc-адресом</i> некоторого <i>элемента sc-памяти, соответствующего некоторому sc-элементу</i>, из которого выходят или в который входят <i>элементы sc-памяти, соответствующие sc-коннекторам</i>, то из <i>sc-памяти</i> также будут эти <i>элементы sc-памяти, соответствующие sc-коннекторам</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_note: [<p>Стоит отметить, что <i>действие удаления элемента из sc-памяти</i> может привести к внештатным ситуациям в самой <i>ostis-платформе</i>. Поэтому кроме <i>Реализации sc-памяти</i> и <i>Программного интерфейса Реализации sc-памяти</i> должны быть реализованы средства верификации действий над <i>sc-памятью</i> (см. <i></i>).</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4434
					<- .system_element_141;
					=> .system_element_4436: [<p>bool scMemoryContext::SetElementSubtype(scAddr const & addr, scType const & type)</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
						<- .system_element_217;;
					*);
					=> .system_element_4437: <
						.system_element_4439;
						.system_element_4345
					>;
					=> .system_element_4438: 
						.system_element_4444
					;
					=> .system_element_4440: 
						.system_element_4443;
						.system_element_4445;
						.system_element_4446
					;
					=> nrel_explanation: [<p>На практике частой ситуацией бывает, что пользователю, разработчику или самой системе неизвестны все знания о создаваемом <i>элементе в sc-памяти</i> либо об элементах его <i>семантической окрестности</i>. Так, например, во время трансляции в <i>sc-память ostis-платформы</i> исходных файлов, реализованных на <i>внешних языках представления знаний</i>: <i>SCs-коде</i> или <i>SCg-коде</i> --- зачастую происходит уточнение классов уже созданных элементов sc-памяти. Такие действия над <i>элементами в sc-памяти ostis-платформы</i> можно осуществить при помощи <b><i>Метода уточнения класса элемента sc-памяти, соответствующего некоторому sc-элементу</i></b>. Для этого необходимо задать в качестве аргументов <i>sc-адрес элемента sc-памяти</i>, для которого необходимо уточнить класс, и сам <i>класс элемента sc-памяти^</i>. В случае успешного выполнения метода в результате пользователем этого метода будет получено логическое значение <i>Истина</i>. По правилам <i>Синтаксиса SC-кода</i> запрещается указывать несколько <i>синтаксических классов</i> для одного и того же <i>sc-элемента</i>, также как и запрещается уточнять класс <i>sc-элемента</i>, которые не могут быть указаны для <i>sc-элементов</i> с заданным <i>синтаксическим классом</i>. При попытке совершить такие действия над <i>элементом sc-памяти</i> результатом работы <i>Метода уточнения класса элемента sc-памяти, соответствующего некоторому sc-элементу</i> будет логическое значение <i>Ложь</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_note: [<p>Во всех методах, где используются классы обрабатываемых <i>элементов sc-памяти</i>, в качестве операций над классами используются операции <i>Булевой алгебры</i>: <i>битовое сложение*</i> (|), <i>битовое умножение*</i> (&) и <i>битовое отрицание*</i> (!). Так, при помощи операции <i>битового умножения*</i> можно определить: является ли заданный класс подклассом <i>класса</i> заданного <i>элемента sc-памяти^</i>, при помощи операции <i>битового умножения*</i> --- уточнять <i>класс</i> заданного <i>элемента sc-памяти^</i>, а при помощи операции <i>битового отрицания*</i> в комбинациях с первыми двумя операциями --- проверять корректность задаваемых <i>классов элементов sc-памяти^</i>. Так, например, <i>битовое сложение*</i> классов элементов sc-памяти, соответствующих <i>sc-коннектору</i> и sc-переменной в результате образуют новый <i>класс элементов sc-памяти^</i> --- <i>элемент sc-памяти, соответствующий константному sc-узлу</i>. Таким образом, в результате можно получать любые допустимые комбинации <i>классов элементов sc-памяти^</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4435
					<- .system_element_141;
					=> .system_element_4436: [<p>scType scMemoryContext::GetElementType(scAddr const & addr) const</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
						<- .system_element_217;;
					*);
					=> .system_element_4437: <
						.system_element_4341
					>;
					=> .system_element_4438: 
						.system_element_4345
					;
					=> .system_element_4440: 
						.system_element_4443
					;
					=> nrel_explanation: [<p>Чтобы получить <i>класс</i> заданного <i>элемента sc-памяти^</i> достаточно применить <b><i>Метод получения класса элемента sc-памяти, соответствующего некоторому sc-элементу</i></b>, задав в качестве аргумента sc-адрес заданного элемента sc-памяти. В последних двух методах не допускается использовать <i>sc-адреса</i>, которые не являются <i>sc-адресами элементов в sc-памяти</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;
				*];;

				.system_element_4447
				=> nrel_inclusion: [*
					=> nrel_idtf: [<p>Документация Программного интерфейса информационно-поисковых методов Реализации sc-памяти в Программной платформе ostis-систем</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_authors: 
						.system_element_4293
					;
					-> rrel_key_sc_element: .system_element_4448;
					=> nrel_explanation: [<p>В задачах, решаемых в прикладных ostis-системах, реализуемых на базе текущей <i>Программной платформы ostis-систем</i>, необходимо использовать механизмы поиска уже существующих элементов или <i>конструкций в sc-памяти</i>. Такие механизмы являются частью <b><i>Реализации информационно-поисковой подсистемы Реализации sc-памяти</i></b>, на базе которой можно реализовывать <i>информационные-поисковые подсистемы</i> для <i>платформенно-зависимых</i> и <i>платформенно-независимых ostis-систем</i>. Несмотря на сложность <i>информационного поиска</i>, текущая <i>Программная платформа ostis-систем</i> позволяет эффективно использовать реализуемые методы <i>информационного поиска</i> в задачах, решаемых прикладными ostis-системами. Данную подсистему нельзя реализовать независимо от реализации <i>ostis-платформы</i>, то есть ее нельзя сделать <i>платформенно-независимой</i>, поэтому необходимо разделять <i>Реализацию информационно-поисковой подсистемы Реализации sc-памяти</i> и <i>Реализацию информационно-поисковой подсистемы Метасистемы OSTIS</i>, которая реализуется на <i>Языке SCP</i> и независимо от текущего <i>Программного варианта реализации ostis-платформы</i> (см. <i></i>). Сам же <i>scp-интерпретатор</i> должен использовать информационно-поисковые методы <i>Реализации sc-памяти</i>, а <i>Язык SCP</i> --- предоставлять возможность навигироваться по <i>базе знаний</i> любой <i>ostis-системы</i> (см. <i></i>).</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4430
					=> nrel_inclusion: [*

						.system_element_4448
						-> .system_element_4449;
						-> .system_element_4450;
						-> .system_element_4451;
						-> .system_element_4452;
						-> .system_element_4453;;
					*];;

					.system_element_4449
					<- .system_element_141;
					=> .system_element_4436: [<p>template <typename ParamType1, typename ParamType2, typename ParamType3> std::shared_ptr<TIterator5<ParamType1, ParamType2, ParamType3>> Iterator3(ParamType1 const & param1, ParamType2 const & param2, ParamType3 const & param3)</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
						<- .system_element_217;;
					*);
					=> .system_element_4437: <
						.system_element_4454;
						.system_element_4454;
						.system_element_4454
					>;
					=> .system_element_4438: 
						.system_element_4455
					;
					=> .system_element_4440: 
						.system_element_4443
					;
					=> nrel_explanation: [<p>По правилам <i>Синтаксиса SC-кода</i> <i>sc-конструкции</i>, то есть конструкции, состоящие из <i>sc-элементов</i>, могут состоять из трех <i>sc-элементов</i>, пяти <i>sc-элементов</i>, семи sc-элементов и так далее (см. <i></i>). В <i>sc-памяти ostis-платформы</i> эквивалентом <i>sc-конструкции</i> является конструкция, состоящая из <i>элементов sc-памяти</i> (<b><i>конструкция в sc-памяти</i></b>). <b><i>Метод создания итератора поиска трехэлементных конструкций в sc-памяти</i></b> и <b><i>Метод создания итератора поиска пятиэлементных конструкций в sc-памяти</i></b> позволяют создавать итераторы поиска трех- и пяти- элементных <i>конструкций в sc-памяти ostis-платформы</i> соответственно. С помощью параметров данных методов можно создавать итераторы любой необходимой конфигурации для поиска <i>трех-</i> и <i>пяти- элементных sc-конструкций</i>. Так, например, если необходимо найти все <i>элементы sc-памяти, соответствующие sc-элементам</i>, которые принадлежат некоторому <i>sc-множеству</i>, для которого соответствует заданный <i>элемент sc-памяти</i>, то необходимо при помощи <i>Метода создания итератора поиска трехэлементных конструкций элементов в sc-памяти</i> создать итератор поиска, задав в качестве первого аргумента <i>элемент sc-памяти, соответствующий</i> заданному <i>sc-множеству</i>, а в качестве второго и третьего аргументов --- <i>класс элементов sc-памяти, соответствующих базовой sc-дуге^</i> и <i>класс элементов sc-памяти, соответствующих sc-элементам неуточненного класса^</i>, соответственно. Для поиска в <i>sc-памяти</i> более сложных конструкций, состоящих из семи и более элементов, необходимо комбинировать итераторы поиска трех- и пяти- элементных <i>конструкций в sc-памяти</i>, или использовать <b><i>Метод поиска конструкций в sc-памяти, изоморфных данному графу-образцу</i></b>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_explanation: [<p><i>программный интерфейс</i> этих <i>методов</i> ограничивается особенностями <i>языка представления методов</i> <i>C++</i>. Например, при помощи этих <i>методов</i> нельзя создать <i>итераторы</i>, задав в качестве аргументов только <i>классы элементов sc-памяти^</i>, по которым необходимо найти все <i>соответствующие конструкции в sc-памяти</i>, в которых <i>классы их элементов sc-памяти^</i> являются классами, заданными в качестве аргументов для указанных методов, как и впрочем нельзя указать что-то иное в качестве аргументов, кроме <i>sc-адреса</i> или <i>класса элемента sc-памяти^</i>. Попытка произвести что-то из перечисленного приведет к ошибке "склейки" интерфейса одного из указанных <i>методов</i>, указанного в заголовочном файле <i>С++</i>, с реализацией с заданными параметрами, указанной в исходном файле <i>С++</i>, поскольку компилятор <i>C++</i> не сможет найти реализацию для указанного <i>программного интерфейса</i>. Таким образом, согласно последней проблеме, параметрами <i>Метода создания итератора поиска трехэлементных конструкций в sc-памяти</i> и <i>Метода создания итератора поиска пятиэлементных конструкций в sc-памяти</i> могут быть <i>sc-адрес</i> и/или <i>класс элемента sc-памяти^</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4430
					=> nrel_inclusion: [*

						.system_element_4448
						=> nrel_inclusion: [*
							=> nrel_inclusion: .system_element_4456;;

							.system_element_4457
							=> nrel_idtf: [<p>sc-итератор</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);
							<= nrel_inclusion: .system_element_4458;
							=> nrel_idtf: [<p>scIterator</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
								<- .system_element_217;;
							*);
							=> nrel_explanation: [<p>С функциональной точки зрения <i>sc-итераторы</i> как часть <i>Реализации sc-памяти</i> представляют собой базовое средство доступа к конструкциям, хранимым в sc-памяти, которое позволяет осуществить чтение (просмотр) конструкций, изоморфных простейшим шаблонам --- <i>трехэлементным sc-конструкциям</i> и <i>пятиэлементным sc-конструкциям</i>.С точки зрения реализации <i>sc-итератор</i> представляет собой структуру данных, которая соответствует определенному дополнительно уточняемому классу sc-конструкций и позволяет при помощи соответствующего набора функций последовательно осуществлять просмотр всех sc-конструкций данного класса, представленных в текущем состоянии sc-памяти (итерацию по sc-конструкциям).Каждому классу <i>sc-итераторов</i> соответствует некоторый известный класс (шаблон, образец) <b>sc-конструкций</b>. При создании sc-итератора данный шаблон уточняется, то есть некоторым (как минимум одному) элементам шаблона ставится в соответствие конкретный заранее известный <i>sc-элемент</i> (отправная точка при поиске), а другим элементам шаблона (тем, которые нужно найти) ставится в соответствие некоторый тип sc-элемента из числа типов, соответствующих <i>меткам синтаксического типа sc-элемента</i>.Далее путем вызова соответствующей функции (или метода класса в ООП) осуществляется последовательный просмотр всех sc-конструкций, соответствующих полученному шаблону (с учетом указанных типов sc-элементов и заранее заданных известных sc-элементов), то есть <i>sc-итератор</i> последовательно "переключается" с одной конструкции на другую до тех пор, пока такие конструкции существуют. Проверка существования следующей конструкции проверяется непосредственно перед переключением. В общем случае конструкций, соответствующих указанному шаблону, может не существовать, в этом случае итерирование происходить не будет (будет 0 итераций).На каждой итерации в sc-итератор записываются sc-адреса sc-элементов, входящих в соответствующую sc-конструкцию, таким образом найденные элементы могут быть обработаны нужным образом в зависимости от задачи.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;

							.system_element_4459
							=> nrel_inclusion: [*
								<= .system_element_4421: .system_element_4457;;

								.system_element_4460
								<- .system_element_141;
								=> .system_element_4436: [<p>bool Next() const</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
									<- .system_element_217;;
								*);
								=> .system_element_4438: 
									.system_element_4444
								;;

								.system_element_4461
								<- .system_element_141;
								=> .system_element_4436: [<p>scAddr Get(size_t idx) const</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
									<- .system_element_217;;
								*);
								=> .system_element_4437: <
									.system_element_4462
								>;
								=> .system_element_4438: 
									.system_element_4439
								;
								=> .system_element_4440: 
									.system_element_4463
								;;
							*];
							=> nrel_explanation: [<p>Создаваемые при помощи данных <i>методов</i> <i>итераторы</i> также <i>имеют программный интерфейс</i>. Результатами обоих <i>методов</i> являются разные <i>итераторы</i>, но имеющие общий <i>программный интерфейс</i>. Такие <i>итераторы</i> позволяют работать с <i>конструкциями в sc-памяти</i> в тот же момент, когда они были найдены. При помощи <i>Метода перехода к следующей "подходящей" для заданного итератора конструкции в sc-памяти</i> <i>итератор</i> обновляет свое внутреннее состояние каждый раз, когда была найдена новая <i>конструкция в sc-памяти</i>. Под следующей "подходящей" для заданного итератора <i>конструкцией в sc-памяти</i> подразумевается <i>конструкция в sc-памяти</i>, элементы которой удовлетворяют конфигурации созданного <i>итератора поиска конструкций в sc-памяти</i> и которая не была найдена раннее. Результатом последнего <i>метода</i> является логическое значение <i>Истина</i>, если следующая "подходящая" для заданного <i>итератора</i> конструкция существует в <i>sc-памяти</i>. Если "подходящих" для этого <i>итератора</i> конструкций нет в <i>sc-памяти</i>, то результатом <i>Метода перехода к следующей подходящей для заданного итератора конструкции в sc-памяти</i> является логическое значение <i>Ложь</i>. Чтобы получить <i>sc-адрес</i> некоторого из элементов найденной <i>конструкции в sc-памяти</i> необходимо использовать <i>Метода доступа к sc-адресу элемента заданной конструкции в sc-памяти по номеру позиции этого элемента в заданной конструкции sc-памяти</i>, задав качестве аргумента целочисленное значение в виде номера позиции искомого элемента в этой конструкции. При этом нумерация позиций элементов в <i>конструкции sc-памяти</i> в текущей <i>Реализации sc-памяти</i> происходит начиная с нуля, а не с единицы, а порядок нумерации задается тем, какой порядок аргументов для создания <i>итератора</i> был использован. При попытке указать для данного метода номер позиции, по которому не существует позиции в данной конструкции, результатом этого метода будет <i>исключительная ситуация</i> о недопустимой позиции элемента в заданной <i>конструкции sc-памяти</i>. Таким образом, диапазон номеров позиции для <i>трехэлементных конструкций</i> ограничен от нуля до двух, а для пятиэлементных --- от нуля до четырех.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*];;
					*];;

					.system_element_4430
					=> nrel_inclusion: [*

						.system_element_4448
						=> nrel_inclusion: [*

							.system_element_4449
							=> nrel_inclusion: .system_element_4464
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4439;
									.system_element_4439;
									.system_element_4439
								>;;
							*);
							=> nrel_inclusion: .system_element_4465
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4439;
									.system_element_4345;
									.system_element_4345
								>;;
							*);
							=> nrel_inclusion: .system_element_4466
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4345;
									.system_element_4345;
									.system_element_4439
								>;;
							*);
							=> nrel_inclusion: .system_element_4467
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4439;
									.system_element_4345;
									.system_element_4439
								>;;
							*);
							=> nrel_inclusion: .system_element_4468
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4345;
									.system_element_4439;
									.system_element_4345
								>;;
							*);;
						*];
						=> nrel_explanation: [<p>Для <i>Метода создания итератора поиска трехэлементных конструкций в sc-памяти</i>, как и для <i>Метода создания итератора поиска пятиэлементных конструкций в sc-памяти</i> можно использовать различные комбинации параметров, кроме комбинаций, где все параметры являются классами <i>элементов sc-памяти</i>. Для простоты и компактности используемых терминов на уровне реализации методов создания итераторов поиска конструкций в sc-памяти вводятся дополнительные обозначения: символом "f" (от английского слова fixed) обозначается факт, что параметром заданного метода создания итератора поиска <i>конструкций в sc-памяти</i> указан <i>sc-адрес</i> некоторого <i>элемента sc-памяти</i>, а символом "a" (от английского слова assign) --- <i>класс элемента sc-памяти</i>^. Для <i>Метода создания итератора поиска трехэлементных конструкций в sc-памяти</i> правильным обозначением искомых конструкций будет комбинация символов "f" и "a" длиной в три символа, а для <i>Метода создания итератора поиска пятиэлементных конструкций в sc-памяти</i> --- комбинация символов "f" и "a" длиной в пять символов. В <i>Языке SCP</i> для указания признака заданности значения у переменной используются соответствующие ролевые отношения: для переменных класса "f" ---  <i>scp-операнд с заданным значением'</i>, для переменных класса "a" --- <i>scp-операнд со свободным значением'</i> (см. <i></i>).</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;
					*];;

					.system_element_4449
					=> nrel_explanation: [<p>Данные варианты реализации <i>Метода создания итератора поиска трехэлементных конструкций в sc-памяти</i> являются достаточными для решения любых поисково-навигационных задач. Возможны варианты реализации <b><i>Метода создания итератора поиска ffa-конструкций в sc-памяти</i></b> и <b><i>Метода создания итератора поиска aff-конструкций в sc-памяти</i></b>, но на практике нет необходимости искать третий элемент sc-памяти по известным элементу, соответствующему sc-коннектору, и элементу, соответствующему sc-элементу, из которого данный sc-коннектор выходит или в который данный sc-коннектор входит. Такую задачу можно решить, используя <b><i>Метод создания итератора поиска afa-конструкций в sc-памяти</i></b>. Впрочем, реализация <i>Метода создания итератора поиска пятиэлементных конструкций в sc-памяти</i> вовсе не обязательна, поскольку все задачи, решаемые при помощи данного метода, можно также решить при помощи <i>Метода создания итератора поиска трехэлементных конструкций в sc-памяти</i>, однако реализация <i>Метода создания итератора поиска пятиэлементных конструкций в sc-памяти</i> позволяет сделать текст создаваемого метода более компактным по сравнению с методом, в котором бы использовался <i>Метод создания итератора поиска трехэлементных конструкций в sc-памяти</i>. В качестве всех трех аргументов для <i>Метода создания итератора поиска трехэлементных конструкций в sc-памяти</i> могут быть указаны:

					<ul>

						<li> <i>sc-адреса элементов sc-памяти</i> (например, задача проверки инцидентности всех трех заданных элементов sc-памяти),

						<li> <i>sc-адрес элемента sc-памяти</i>, <i>класс элементов sc-памяти, соответствующих sc-коннекторам^</i>, которые выходят из заданного в качестве первого аргумента <i>элемента sc-памяти</i>, и <i>sc-адрес элемента sc-памяти</i>, соответствующего некоторому <i>sc-элементу</i>, в который искомые <i>sc-коннекторы</i> входят (например, задача поиска всех <i>элементов sc-памяти, соответствующих sc-коннекторам между sc-элементами</i>, для которых соответствуют заданные <i>элементы sc-памяти</i>),

						<li> <i>sc-адрес элемента sc-памяти</i>, <i>класс элементов sc-памяти, соответствующих sc-коннекторам^</i>, которые выходят из заданного в качестве первого аргумента <i>элемента sc-памяти</i>, и <i>класс элементов sc-памяти, соответствующих некоторым sc-элементам^</i>, в которые искомые <i>sc-коннекторы</i> входят (например, задача поиска всех <i>элементов sc-памяти</i>, <i>соответствующих sc-коннекторам</i>, выходящим из <i>sc-элемента</i>, для которого соответствует заданный в качестве первого аргумента <i>элемент sc-памяти</i>),

						<li> <i>класс sc-элементов sc-памяти^</i>, <i>класс элементов sc-памяти, соответствующих sc-коннекторам^</i>, которые выходят из заданных в качестве первого аргумента <i>элементов sc-памяти</i>, и <i>sc-адрес элемента sc-памяти, соответствующего некоторому sc-элементу</i>, в который искомые <i>sc-коннекторы</i> входят (например, задача поиска всех <i>элементов sc-памяти, соответствующих sc-коннекторам</i>, входящим в <i>sc-элемент</i>, для которого соответствует заданный в качестве третьего аргумента <i>элемент sc-памяти</i>),

						<li> <i>класс элементов sc-памяти^</i>, <i>sc-адрес элемента sc-памяти, соответствующий sc-коннектору</i>, который выходит из заданного в качестве первого аргумента <i>элемента sc-памяти</i>, и <i>класс элементов sc-памяти, соответствующих некоторому sc-элементу^</i>, в который искомый <i>sc-коннектор</i> входит (например, задача поиска <i>элементов sc-памяти, соответствующих sc-элементам</i>, один из которых является <i>sc-элементом</i>, из которого выходит <i>sc-коннектор</i>, для которого соответствует заданный <i>элемент sc-памяти</i>, а второй из которых является <i>sc-элементом</i>, в который входит этот <i>sc-коннектор</i>, для которого соответствует заданный <i>элемент sc-памяти</i>)

						<li> и так далее.</li>

					<ul></p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> .system_element_840: .system_element_4450;;

					.system_element_4450
					<- .system_element_141;
					=> .system_element_4436: [<p>template <typename ParamType1, typename ParamType2, typename ParamType3, typename ParamType4, typename ParamType5> std::shared_ptr<TIterator5<ParamType1, ParamType2, ParamType3, ParamType4, ParamType5>> Iterator5(ParamType1 const & param1, ParamType2 const & param2, ParamType3 const & param3, ParamType4 const & param4, ParamType5 const & param5)</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
						<- .system_element_217;;
					*);
					=> .system_element_4437: <
						.system_element_4454;
						.system_element_4454;
						.system_element_4454;
						.system_element_4454;
						.system_element_4454
					>;
					=> .system_element_4438: 
						.system_element_4469
					;
					=> .system_element_4440: 
						.system_element_4443
					;;

					.system_element_4430
					=> nrel_inclusion: [*

						.system_element_4448
						=> nrel_inclusion: [*

							.system_element_4470
							=> nrel_inclusion: .system_element_4471
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4439;
									.system_element_4439;
									.system_element_4439;
									.system_element_4439;
									.system_element_4439
								>;;
							*);
							=> nrel_inclusion: .system_element_4472
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4439;
									.system_element_4345;
									.system_element_4345;
									.system_element_4345;
									.system_element_4345
								>;;
							*);
							=> nrel_inclusion: .system_element_4473
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4345;
									.system_element_4345;
									.system_element_4345;
									.system_element_4345;
									.system_element_4439
								>;;
							*);
							=> nrel_inclusion: .system_element_4474
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4439;
									.system_element_4345;
									.system_element_4345;
									.system_element_4345;
									.system_element_4439
								>;;
							*);
							=> nrel_inclusion: .system_element_4475
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4439;
									.system_element_4345;
									.system_element_4439;
									.system_element_4345;
									.system_element_4439
								>;;
							*);
							=> nrel_inclusion: .system_element_4476
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4345;
									.system_element_4439;
									.system_element_4345;
									.system_element_4345;
									.system_element_4345
								>;;
							*);
							=> nrel_inclusion: .system_element_4477
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4345;
									.system_element_4345;
									.system_element_4345;
									.system_element_4439;
									.system_element_4345
								>;;
							*);
							=> nrel_inclusion: .system_element_4478
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4345;
									.system_element_4345;
									.system_element_4439;
									.system_element_4345;
									.system_element_4345
								>;;
							*);
							=> nrel_inclusion: .system_element_4479
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4345;
									.system_element_4439;
									.system_element_4345;
									.system_element_4345;
									.system_element_4439
								>;;
							*);
							=> nrel_inclusion: .system_element_4480
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4439;
									.system_element_4345;
									.system_element_4345;
									.system_element_4439;
									.system_element_4345
								>;;
							*);
							=> nrel_inclusion: .system_element_4481
							(*
								<- .system_element_141;;
								=> .system_element_4437: <
									.system_element_4345;
									.system_element_4439;
									.system_element_4345;
									.system_element_4439;
									.system_element_4345
								>;;
							*);
							=> nrel_explanation: [<p>В качестве всех пяти аргументов для <b><i>Метода создания итератора поиска пятиэлементных конструкций в sc-памяти</i></b> могут быть указаны и другие комбинации, не указанные в представленной классификации. Однако в этом нет необходимости, поскольку все задачи, решаемые с помощью таких <i>итераторов</i>, можно решить уже существующими <u><i>итераторами поиска пятиэлементных конструк-</i></u> <u><i>ций в sc-памяти</i></u>.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*];;
					*];;

					.system_element_4482
					=> nrel_inclusion: [*
						-> rrel_key_sc_element: .system_element_4456;
						=> nrel_note: [<p><i>Метод создания итератора поиска трехэлементных конструкций в sc-памяти</i> и <i>Метод создания итератора поиска пятиэлементных конструкций в sc-памяти</i>, а также <i>программный интерфейс итератора поиска трех- и пяти- элементных конструкций в sc-памяти</i> являются достаточно мощными средствами для решения любых задач <u><i>информационного поиска</i></u> в прикладных <i>ostis-системах</i>. Однако есть <i>модели решения задач</i>, в которых необходимо использовать другие методы поиска. Так, например, в задачах <u><i>логического вывода</i></u> считается удобным решать <i>задачи</i>, когда <i>поиск конструкций</i> любой необходимой конфигурации <i>в sc-памяти</i> сводится к <b><i>изоморфному поиску</i></b> этих конструкций по заданному <b><i>графу-образцу</i></b>. Такими <i>графами-образцами</i> могут выступать любые <i>атомарные логические формулы</i>, входящие в состав в любой другой <i>неатомарной формулы</i> (см. <i></i>).<i>изоморфный поиск</i> является одним из способов решения <i>задачи</i> поиска подграфа в <i>графе</i> (см. Fort1996). Эта задача заключается в том, чтобы найти все вхождения заданного <i>графа-образца</i> в исходном графе. Процесс <i>изоморфного поиска</i> может быть реализован с использованием различных алгоритмов. Один из них --- <i>Алгоритм Ульмана</i>, который основан на использовании матрицы смежности, чтобы определить соответствие между вершинами графов. Другой алгоритм --- <i>Алгоритм VF2</i>, который использует функцию сравнения для проверки соответствия соответствующих узлов и ребер в двух графах (см. Foggia2001). В современной информатике также известны алгоритмы, позволяющие решать <i>задачу</i> <i>изоморфного поиска</i> за субэкспоненциальное время (см. McKay2007).Основополагающим принципом разрабатываемой <i>Технологии OSTIS</i> является принцип заимствования наилучших существующих технологий для разработки <i>ostis-систем</i>. Однако в силу разных обстоятельств, например, связанных с особенностями <i>Реализации sc-памяти</i>, а также требований, предъявляемых к sc-агентам, занимающихся логическим выводом, необходимо разрабатывать и апробировать новые решения. В рамках текущей <i>Реализации sc-памяти</i> разработан принципиально другой алгоритм <i>изоморфного поиска</i>, позволяющего за оптимальное время находить графы, изоморфные данному <i>графу-образцу</i>.В общем случае <u>нет</u> необходимости реализовывать <i>изоморфный поиск</i> в универсальном виде. Это объясняется тем, что:
						<ul>
							<li> <i>изоморфный поиск</i> является NP-полной задачей, что означает, что затраты на ее решение растут экспоненциально с размером входных данных, и пока не существует эффективного алгоритма для решения задачи <i>изоморфного поиска</i>;
							<li> в результате определения изоморфизма двух заданных графов может быть обнаружено несколько узлов, которые соответствуют друг другу, но на самом деле не являются изоморфными;
							<li> из-за экспоненциального роста количества возможных вариантов изоморфизма при увеличении размера графа, даже небольшие погрешности при расчете изоморфизма могут привести к сильному искажению результатов;
							<li> для больших графов временные затраты на перебор всех возможных вариантов изоморфизма могут быть очень высокими. Это может снижать эффективность поиска и ограничивать возможности применения <i>изоморфного поиска</i> в реальных задачах (см. Cordella2004);
							<li> сложность поиска увеличивается с увеличением количества циклов в исходном <i>графе</i>, поскольку приводит к большему числу переборов;
							<li> существующие алгоритмы либо медленны, либо нерационально используют память, что приводит <i>изоморфный поиск</i> к медленной работе.</li>
						<ul>Некоторые алгоритмы изоморфного поиска вовсе имеют сложность <i>O(n!)</i> и не могут быть использованы для графов большого размера (см. Fort1996). Несмотря на все проблемы, связанные с <i>изоморфным поиском</i>, для удобства решения логических задач в текущем <i>Программном варианте реализации ostis-платформы</i> реализован "наиболее подходящий" алгоритм <i>изоморфного поиска</i>. Текущий вариант <i>изоморфного поиска</i> реализован в <i>Методе поиска конструкций в sc-памяти, изоморфных данному графу-образцу</i>. Данный метод позволяет находить <i>конструкции в sc-памяти</i>, изоморфные не просто некоторому <i>графу-образцу</i>, который представлен в <i>sc-памяти</i>, а <i>программному объекту</i> этого <i>графа-образца</i>, то есть <i>графу-образцу</i>, который представлен в удобном и быстром для обработки программном формате.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4451
						<- .system_element_141;
						=> .system_element_4436: [<p>scTemplate::Result HelperSearchTemplate(scTemplate const & templ, scTemplateSearchResult & result)</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
							<- .system_element_217;;
						*);
						=> .system_element_4437: <
							.system_element_4483;
							.system_element_4484
						>;
						=> .system_element_4438: 
							.system_element_4485
						;
						=> .system_element_4440: 
							.system_element_4486;
							.system_element_4487
						;;

						.system_element_4452
						<- .system_element_141;
						=> .system_element_4436: [<p>scTemplate::Result HelperGenTemplate(scTemplate const & templ, scTemplateGenResult & result)</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
							<- .system_element_217;;
						*);
						=> .system_element_4437: <
							.system_element_4483;
							.system_element_4488
						>;
						=> .system_element_4438: 
							.system_element_4489
						;
						=> .system_element_4440: 
							.system_element_4486;
							.system_element_4487
						;;

						.system_element_4453
						<- .system_element_141;
						=> .system_element_4436: [<p>scTemplate::Result HelperBuildTemplate(scTemplate & templ, scAddr const & templAddr)</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
							<- .system_element_217;;
						*);
						=> .system_element_4437: <
							.system_element_4483;
							.system_element_4439
						>;
						=> .system_element_4438: 
							.system_element_4490
						;
						=> .system_element_4440: 
							.system_element_4486;
							.system_element_4487
						;
						=> nrel_explanation: [<p><b><i>программный объект граф-образца</i></b> можно сформировать при помощи <i>Метода создания программного объекта графа-образца</i>, для этого необходимо в качестве аргументов задать <i>программный объект графа-образца</i> как выходный параметр и <i>sc-адрес элемента sc-памяти, соответствующего sc-структуре</i> <i>атомарной логической формулы</i> (sc-шаблону).Как и <i>итератор поиска трех- и пяти- элементных конструкций в sc-памяти</i>, <i>программный объект графа-образца</i> имеет специализированный <i>программный интерфейс</i>. Изначально <i>программный объект графа-образца</i> задается пустым. При помощи <b><i>Метода добавления трехэлементной конструкции для заданного графа-образца</i></b> и <b><i>Метода добавления пятиэлементной конструкции для заданного графа-образца</i></b> можно расширять заданный <i>программный объект графа-образца</i>. Расширение <i>программного объекта графа-образца</i> происходит с добавлением трехэлементных конструкций в <b><i>кортеж программных объектов трехэлементных конструкций в заданном графе-образце</i></b>, при этом порядок программный объектов конструкций в этом множестве задается последовательностью выполнения <i>Метода добавления трехэлементной конструкции для заданного графа-образца</i> и <i>Метода добавления пятиэлементной конструкции для заданного графа-образца</i>.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4430
						=> nrel_inclusion: [*

							.system_element_4448
							=> nrel_inclusion: [*

								.system_element_4483
								=> nrel_idtf: [<p>scTemplate</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
									<- .system_element_217;;
								*);
								=> nrel_idtf: [<p>программный объект атомарной логической формулы</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);
								=> nrel_idtf: [<p>программный объект sc-шаблона</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);
								<= nrel_inclusion: .system_element_4458;
								=> .system_element_4342: {
									.system_element_4491
									(*
										=> nrel_idtf: [<p>std::vector<scTemplateTriple *> m_templateTriples</p>]
										(*
											<- lang_ru;;
											=> nrel_format: format_html;;
										*);;
									*);
									.system_element_4492
									(*
										=> nrel_idtf: [<p>std::unordered_multimap<std::string, size_t> m_templateItemsNamesToReplacementItemsPositions</p>]
										(*
											<- lang_ru;;
											=> nrel_format: format_html;;
										*);;
									*);
									.system_element_4493
									(*
										=> nrel_idtf: [<p>std::vector<std::unordered_set<size_t>> m_priorityOrderedTemplateTriples</p>]
										(*
											<- lang_ru;;
											=> nrel_format: format_html;;
										*);;
									*);
									.system_element_4494
									(*
										=> nrel_idtf: [<p>std::map<std::string, scAddr> m_templateItemsNamesToReplacementItemsAddrs</p>]
										(*
											<- lang_ru;;
											=> nrel_format: format_html;;
										*);;
									*);
									.system_element_4495
									(*
										=> nrel_idtf: [<p>std::map<std::string, scType> m_templateItemsNamesToTypes</p>]
										(*
											<- lang_ru;;
											=> nrel_format: format_html;;
										*);;
									*)
								};;

								.system_element_4496
								=> nrel_idtf: [<p>scTemplateTriple</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
									<- .system_element_217;;
								*);
								<= nrel_inclusion: .system_element_4458;
								=> .system_element_4342: {
									.system_element_4497
									(*
										=> nrel_idtf: [<p>size_t m_index</p>]
										(*
											<- lang_ru;;
											=> nrel_format: format_html;;
										*);;
									*);
									.system_element_4498
									(*
										=> nrel_idtf: [<p>std::array<scTemplateItem, 3> m_values</p>]
										(*
											<- lang_ru;;
											=> nrel_format: format_html;;
										*);;
									*)
								};;

								.system_element_4499
								=> nrel_idtf: [<p>scTemplateItem</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
									<- .system_element_217;;
								*);
								<= nrel_inclusion: .system_element_4458;
								=> .system_element_4342: {
									.system_element_4500
									(*
										<= nrel_inclusion: .system_element_4439;;
										=> nrel_idtf: [<p>ScAddr m_addrValue</p>]
										(*
											<- lang_ru;;
											=> nrel_format: format_html;;
										*);;
									*);
									.system_element_4501
									(*
										<= nrel_inclusion: .system_element_4345;;
										=> nrel_idtf: [<p>ScType m_typeValue</p>]
										(*
											<- lang_ru;;
											=> nrel_format: format_html;;
										*);;
									*);
									.system_element_4502
									(*
										=> nrel_idtf: [<p>std::string m_name</p>]
										(*
											<- lang_ru;;
											=> nrel_format: format_html;;
										*);;
									*)
								};;

								.system_element_4503
								=> nrel_inclusion: [*
									<= .system_element_4421: .system_element_4483;;

									.system_element_4504
									<- .system_element_141;
									=> .system_element_4436: [<p>scTemplate & Triple(scTemplateItemValue const & param1, scTemplateItemValue const & param2, scTemplateItemValue const & param3)</p>]
									(*
										<- lang_ru;;
										=> nrel_format: format_html;;
										<- .system_element_217;;
									*);
									=> .system_element_4437: <
										.system_element_4505;
										.system_element_4505;
										.system_element_4505
									>;
									=> .system_element_4438: 
										.system_element_4483
									;
									=> .system_element_4440: 
										.system_element_4506
										(*
											=> nrel_inclusion: .system_element_4507;;
											=> nrel_inclusion: .system_element_4508;;
											=> nrel_inclusion: .system_element_4509;;
											=> nrel_inclusion: .system_element_4510;;
											=> nrel_inclusion: .system_element_4511;;
										*)
									;;

									.system_element_4512
									<- .system_element_141;
									=> .system_element_4436: [<p>scTemplate & Fiver(scTemplateItemValue const & param1, scTemplateItemValue const & param2, scTemplateItemValue const & param3, scTemplateItemValue const & param4, scTemplateItemValue const & param5)</p>]
									(*
										<- lang_ru;;
										=> nrel_format: format_html;;
										<- .system_element_217;;
									*);
									=> .system_element_4513: [<p>scTemplate & TripleWithRelation(scTemplateItemValue const & param1, scTemplateItemValue const & param2, scTemplateItemValue const & param3, scTemplateItemValue const & param4, scTemplateItemValue const & param5)</p>]
									(*
										<- lang_ru;;
										=> nrel_format: format_html;;
										<- .system_element_217;;
									*);
									=> .system_element_4437: <
										.system_element_4505;
										.system_element_4505;
										.system_element_4505;
										.system_element_4505;
										.system_element_4505
									>;
									=> .system_element_4438: 
										.system_element_4483
									;
									=> .system_element_4440: 
										.system_element_4506
										(*
											=> nrel_inclusion: .system_element_4514;;
											=> nrel_inclusion: .system_element_4508;;
											=> nrel_inclusion: .system_element_4515;;
											=> nrel_inclusion: .system_element_4516;;
											=> nrel_inclusion: .system_element_4511;;
										*)
									;;
								*];
								=> nrel_explanation: [<p>Чтобы сформировать необходимый <i>программный объект графа-образца</i> следует выполнить следующие действия:
								<ul>
									<li> Если <i>программный объект графа-образца</i> не создавался раннее, то необходимо создать его.
									<li> Для созданного <i>программного объекта графа-образца</i> применить несколько раз <i>Метод добавления трехэлементной конструкции для заданного графа-образца</i> (<i>Метод добавления пятиэлементной конструкции для заданного графа-образца</i>), задав в качестве трех (пяти) входных параметров <b><i>параметры Метода добавления конструкции для заданного графа-образца</i></b> в зависимости от нужной конфигурации добавляемого <i>программного объекта трехэлементной (пятиэлементной) конструкции</i>.</li>
								<ul>При этом <i>параметр Метода добавления конструкции для заданного графа-образца</i> существенно <u>отличается</u> от <i>параметра Метода создания итератора поиска конструкций в sc-памяти</i>. Кроме sc-адресов и классов элементов sc-памяти, могут быть указаны локальные идентификаторы этих адресов или классов в созданном графе-образце. Это существенно упрощает процесс формирования <i>программного объекта графа-образца</i>, когда необходимо в добавляемой конструкции указать <i>sc-адрес</i> или <i>класс элемента sc-памяти^</i>, который был уже указан раннее в другой конструкции в заданном <i>графе-образце</i>. Таким образом можно сослаться с помощью такого локального идентификатора на параметр уже ранее добавленной конструкции в заданный граф-образец. Кроме того такой способ позволяет получать по таким локальным идентификаторам элементы из найденных по заданному <i>графу-образцу</i> конструкций в sc-памяти.Вне зависимости от того, какие методы были применены для созданного <i>программного объекта графа-образца</i> в самой структуре <i>программного объекта графа образца</i> для удобства представления и обработки данных создаются <u>только</u> <b><i>программные объекты трехэлементных конструкций</i></b>. Каждый элемент в <i>программном объекте трехэлементной конструкции</i> кроме sc-адреса, класса и локального идентификатора, имеет свой в рамках этой конструкции номер позиции, заданный в диапазоне от нуля до двух, а также номер позиции в рамках всего графа-образца, вычисляемый как сумма произведения номера <i>трехэлементной конструкции в заданном графе-образце</i> и <i>Числа три</i> и <i>номера позиции этого элемента в рамках графа-образца</i>. Добавление <i>программного объекта трехэлементной конструкции в заданном программном объекте графа-образца</i> в <i>программный объект графа-образца</i> происходит следующим образом:
								<ul>
									<li> <u>Если</u> указанный в качестве второго параметра аргумент имеет локальный идентификатор в заданном графе-образце и этот локальный идентификатор так же указан для первого или второго аргумента, то завершить работу <i>Метода добавления трехэлементной конструкции для заданного графа-образца</i> с исключительной ситуацией о том, что <i>один и тот же локальный идентификатор одновременно указан для второго и первого (третьего) элементов заданного программного объекта трехэлементной конструкции в заданном программном объекте графа-образца</i>.
									<li> <u>Если</u> какой-то из параметров задан в качестве класса элемента sc-памяти, соответствующего sc-константе, то завершить работу <i>Метода добавления трехэлементной конструкции для заданного графа-образца</i> с исключительной ситуацией о том, что <i>класс элемента создаваемого программного объекта трехэлементной конструкции в заданном программном объекте графа-образца является классом элементов в sc-памяти, соответствующих sc-константам</i>.
									<li> <u>Если</u> какой-то из параметров задан в качестве sc-адреса несуществующего элемента в sc-памяти, то завершить работу <i>Метода добавления трехэлементной конструкции для заданного графа-образца</i> с исключительной ситуацией о том, что <i>элемент с sc-адресом элемента создаваемого программного объекта трехэлементной конструкции в заданном программном объекте графа-образца не существует в sc-памяти</i>.
									<li> Для всех параметров, для которых заданы локальные идентификаторы в заданном графе-образце, а также заданы sc-адреса элементов в sc-памяти, добавить все пары с этими локальными идентификаторами и соответствующими sc-адресами элементов в sc-памяти в отношение <i>локальный идентификатор элемента sc-памяти и sc-адрес этого элемента в заданном графе-образце*</i>, иначе если известны sc-адреса элементов в sc-памяти для этих локальных идентификаторов в отношении <i>локальный идентификатор элемента sc-памяти и sc-адрес этого элемента в заданном графе-образце*</i>, указать для заданных параметров известные sc-адреса элементов в sc-памяти.
									<li> Для всех параметров, для которых заданы локальные идентификаторы в заданном графе-образце, а также заданы классы элементов в sc-памяти, добавить все пары с этими локальными идентификаторами и соответствующими классами элементов в sc-памяти в отношение <i>локальный идентификатор элемента sc-памяти и класс этого элемента в заданном графе-образце*</i>.
									<li> Для всех параметров, для которых заданы только локальные идентификаторы в заданном графе-образце, а также в отношении <i>локальный идентификатор элемента sc-памяти и номера позиций этого элемента в заданном графе-образце*</i> по этим локальным идентификаторам неизвестны все номера позиций соответствующих элементов в заданном <i>графе-образце</i>, то добавить в это отношение все пары с локальными идентификаторами и номерами позиций соответствующих элементов в заданном графе-образце.
									<li> Для полученного <i>программного объекта трехэлементной конструкции в заданном программном объекте графа-образца</i> вычислить номер приоритета, необходимый при выполнении <i>Метода поиска конструкций в sc-памяти, изоморфных данному графу-образцу</i>:
									<ul>
										<li> <u>Если</u> в <i>программном объекте трехэлементной конструкции</i> для всех элементов указаны <i>sc-адреса элементов sc-памяти</i>, то номер приоритета заданной конструкции считается равным нулю (то есть считается самой приоритетной).
										<li> <u>Если</u> в <i>программном объекте трехэлементной конструкции</i> для второго элемента указан <i>sc-адрес элемента sc-памяти, соответствующего sc-коннектору</i>, то номер приоритета заданной конструкции считается равным единице (то есть считается второй по приоритету).
										<li> <u>Если</u> в <i>программном объекте трехэлементной конструкции</i> для первого и третьего элементов указаны <i>sc-адреса элемента sc-памяти</i>, то номер приоритета заданной конструкции считается равным двойке (то есть считается третьей по приоритету).
										<li> <u>Если</u> в <i>программном объекте трехэлементной конструкции</i> только для третьего элемента указан <i>sc-адрес элемента sc-памяти</i>, то номер приоритета заданной конструкции считается равным тройке.
										<li> <u>Если</u> в <i>программном объекте трехэлементной конструкции</i> для первого элемента указан <i>sc-адрес элемента sc-памяти</i>, а для третьего элемента --- <i>класс элемента sc-памяти, соответствующего sc-узлу^</i>, то номер приоритета заданной конструкции считается равным четверке.
										<li> <u>Если</u> в <i>программном объекте трехэлементной конструкции</i> для первого элемента указан <i>sc-адрес элемента sc-памяти</i>, а для третьего элемента --- <i>класс элемента sc-памяти, соответствующего sc-коннектору^</i>, то номер приоритета заданной конструкции считается равным пятерке.
										<li> <u>Если</u> в <i>программном объекте трехэлементной конструкции</i> нет элементов, для которых заданы <i>sc-адреса элементов sc-памяти</i>, то номер приоритета заданной конструкции считается равным шестерке (то есть считается самой неприоритетной).</li>
									<ul>После определения номера приоритета заданного <i>программного объекта трехэлементной конструкции в заданном программном объекте графа-образца</i> добавить данный объект во множество с позицией, равной вычисленному номеру приоритета, <i>упорядоченного по степени приоритета поиска множества множеств номеров программных объектов трехэлементных конструкций в заданном графе-образце</i>.
									<li> Полученный <i>программный объект трехэлементной конструкции заданного графа-образца</i> добавить в <i>кортеж программных объектов трехэлементных конструкций в заданном графе-образце</i>.</li>
								<ul>Добавление <i>программного объекта пятиэлементной конструкции</i> в <i>программный объект графа-образца</i> сводится к добавлению двух <i>программных объектов трехэлементной конструкции</i> в этот <i>программный объект графа-образца</i>, при этом во втором добавляемом <i>программном объекте трехэлементной конструкции</i> для третьего элемента указывается только локальный идентификатор второго элемента первого добавляемого <i>программного объекта трехэлементной конструкции в заданном программном объекте графа-образца</i> для заданного <i>программного объекта графа-образца</i>.Чтобы найти все <i>конструкции в sc-памяти</i>, изоморфные заданному <i>программному объекту графа-образца</i> следует выполнить следующие действия:
								<ul>
									<li> Для сформированного <i>программного объекта графа-образца</i> применить <i>Метод поиска конструкций в sc-памяти, изоморфных данному графу-образцу</i>.
									<li> Результатом этого метода будет <i>кортеж программных объектов всех конструкций в sc-памяти, изоморфных заданному графу-образцу</i>, который, как и итератор поиска трех- и пяти- элементных конструкций в sc-памяти, имеет свой <i>программный интерфейс</i>.</li>
								<ul></p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*];;
						*];;

						.system_element_4430
						=> nrel_inclusion: [*

							.system_element_4448
							=> nrel_inclusion: [*

								.system_element_4484
								=> nrel_idtf: [<p>scTemplateSearchResult</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
									<- .system_element_217;;
								*);
								<= nrel_inclusion: .system_element_4458;;

								.system_element_4503
								=> nrel_inclusion: [*

									.system_element_4517
									=> nrel_idtf: [<p>scTemplateSearch</p>]
									(*
										<- lang_ru;;
										=> nrel_format: format_html;;
										<- .system_element_217;;
									*);
									<= nrel_inclusion: .system_element_4458;
									=> .system_element_4342: {
										.system_element_4518
										(*
											=> nrel_idtf: [<p>std::map<std::string, std::unordered_set<size_t>>  m_templateItemsNamesToDependedTemplateTriples</p>]
											(*
												<- lang_ru;;
												=> nrel_format: format_html;;
											*);;
										*);
										.system_element_4519
										(*
											=> nrel_idtf: [<p>std::vector<std::unordered_set<size_t>> m_connectivityComponentsTemplateTriples</p>]
											(*
												<- lang_ru;;
												=> nrel_format: format_html;;
											*);;
										*);
										.system_element_4520
										(*
											=> nrel_idtf: [<p>std::vector<size_t> m_connectivityComponentPriorityTemplateTriples</p>]
											(*
												<- lang_ru;;
												=> nrel_format: format_html;;
											*);;
										*);
										.system_element_4521
										(*
											=> nrel_idtf: [<p>std::vector<std::unordered_set<scAddr, scAddrHashFunc<uint32_t>>>  m_notUsedEdgesInTemplateTriples</p>]
											(*
												<- lang_ru;;
												=> nrel_format: format_html;;
											*);;
										*);
										.system_element_4522
										(*
											=> nrel_idtf: [<p>std::vector<std::unordered_set<scAddr, scAddrHashFunc<uint32_t>>>  m_usedEdgesInTemplateTriples</p>]
											(*
												<- lang_ru;;
												=> nrel_format: format_html;;
											*);;
										*);
										.system_element_4523
										(*
											=> nrel_idtf: [<p>std::vector<std::unordered_set<scAddr, scAddrHashFunc<uint32_t>>>  m_usedEdgesInReplacementConstructions</p>]
											(*
												<- lang_ru;;
												=> nrel_format: format_html;;
											*);;
										*);
										.system_element_4524
										(*
											=> nrel_idtf: [<p>std::vector<std::unordered_set<size_t>>  m_checkedTemplateTriplesInReplacementConstructions</p>]
											(*
												<- lang_ru;;
												=> nrel_format: format_html;;
											*);;
										*);
										.system_element_4525
										(*
											=> nrel_idtf: [<p>size_t m_lastReplacementConstructionIdx</p>]
											(*
												<- lang_ru;;
												=> nrel_format: format_html;;
											*);;
										*);
										.system_element_4526
										(*
											=> nrel_idtf: [<p>std::unordered_set<size_t> m_foundReplacementConstructions</p>]
											(*
												<- lang_ru;;
												=> nrel_format: format_html;;
											*);;
										*)
									};;
								*];;

								.system_element_4527
								=> nrel_inclusion: [*
									<= .system_element_4421: .system_element_4484;;

									.system_element_4528
									<- .system_element_141;
									=> .system_element_4436: [<p>scTemplateSearchResultItem operator(size_t index) const noexcept(false)</p>]
									(*
										<- lang_ru;;
										=> nrel_format: format_html;;
										<- .system_element_217;;
									*);
									=> .system_element_4437: <
										.system_element_4462
									>;
									=> .system_element_4438: 
										.system_element_4529
									;
									=> .system_element_4440: 
										.system_element_4530
									;;

									.system_element_4531
									<- .system_element_141;
									<- .system_element_4532;
									=> .system_element_4436: [<p>bool Get(size_t index, scTemplateSearchResultItem & outItem) const noexcept</p>]
									(*
										<- lang_ru;;
										=> nrel_format: format_html;;
										<- .system_element_217;;
									*);
									=> .system_element_4437: <
										.system_element_4462;
										.system_element_4529
									>;
									=> .system_element_4438: 
										.system_element_4444
									;;
								*];;

								.system_element_4529
								=> nrel_idtf: [<p>scTemplateSearchResultItem</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
									<- .system_element_217;;
								*);
								<= nrel_inclusion: .system_element_4458;;

								.system_element_4533
								=> nrel_inclusion: [*
									<= .system_element_4421: .system_element_4529;;

									.system_element_4534
									<- .system_element_141;
									=> .system_element_4436: [<p>scAddr const & operator(size_t index) const noexcept(false)</p>]
									(*
										<- lang_ru;;
										=> nrel_format: format_html;;
										<- .system_element_217;;
									*);
									=> .system_element_4437: <
										.system_element_4462
									>;
									=> .system_element_4438: 
										.system_element_4439
									;
									=> .system_element_4440: 
										.system_element_4535
									;;

									.system_element_4536
									<- .system_element_141;
									<- .system_element_4532;
									=> .system_element_4436: [<p>bool Get(size_t index, scAddr & outAddr) const noexcept</p>]
									(*
										<- lang_ru;;
										=> nrel_format: format_html;;
										<- .system_element_217;;
									*);
									=> .system_element_4437: <
										.system_element_4462;
										.system_element_4439
									>;
									=> .system_element_4438: 
										.system_element_4444
									;;

									.system_element_4537
									<- .system_element_141;
									=> .system_element_4436: [<p>scAddr const & operator(std::string const & name) const noexcept(false)</p>]
									(*
										<- lang_ru;;
										=> nrel_format: format_html;;
										<- .system_element_217;;
									*);
									=> .system_element_4437: <
										.system_element_4538
									>;
									=> .system_element_4438: 
										.system_element_4439
									;
									=> .system_element_4440: 
										.system_element_4539
									;;

									.system_element_4540
									<- .system_element_141;
									<- .system_element_4532;
									=> .system_element_4436: [<p>bool Get(std::string const & name, scAddr & outAddr) const noexcept</p>]
									(*
										<- lang_ru;;
										=> nrel_format: format_html;;
										<- .system_element_217;;
									*);
									=> .system_element_4437: <
										.system_element_4538;
										.system_element_4439
									>;
									=> .system_element_4438: 
										.system_element_4444
									;;
								*];
								=> nrel_explanation: [<p>Текущий <b><i>Метод поиска конструкций в sc-памяти, изоморфных данному графу-образцу</i></b>, состоит из двух этапов: (1) <i>Этапа предобработки графа-образца</i>, (2)<i>Этапа поиска конструкций в sc-памяти, изоморфных заданному графу-образцу</i>. При этом внутри <i>Метода поиска конструкций в sc-памяти, изоморфных данному графу-образцу</i> происходит создание программного <i>итератора поиска конструкций в sc-памяти, изоморфных данному графу-образцу</i>, выполняющего весь алгоритм изоморфного поиска.<b><i>Этап предобработки графа-образца</i></b> состоит из <u>следующих</u> промежуточных шагов обработки:
								<ul>
									<li> Добавление в отношение <i>локальный идентификатор некоторого элемента в некотором программном объекте трехэлементной конструкции заданного графа-образца и множество всех номеров программных объектов трехэлементных конструкций в заданном графе-образце с этим элементом*</i> всех пар с локальными идентификаторами элементов в некотором программном объекте трехэлементной конструкции заданного графа-образца и множествами номеров соответствующих им программных объектов трехэлементных конструкций в заданном графе-образце. Во множества таких программных объектов не включаются те <i>программные объекты трехэлементных конструкций</i> в заданном графе-образце, номера которых входят в локальный идентификатор самого элемента. Этот локальный идентификатор элемента не является локальным идентификатором этого элемента в рамках всего графа-образца. Такой локальный идентификатор формируется самой системой, а не пользователем <i>Метода добавления трехэлементной конструкции для заданного графа-образца</i> (<i>Метода добавления пятиэлементной конструкции для заданного графа-образца</i>) и состоит из локального идентификатора элемента в рамках всего графа-образца и номера соответствующего программного объекта трехэлементной конструкции в заданном графе-образце. Зная такой локальный идентификатор элемента некоторого <i>программного объекта трехэлементной конструкции</i> графа-образца, можно быстро получать доступам к другим <i>программным объектам трехэлементных конструкций</i>, в которых есть данный элемент.
									<li> Удаление из множеств номеров <i>программных объектов трехэлементных конструкций</i>, которые являются вторыми компонентами пар отношения <i>локальный идентификатор некоторого элемента в некотором программном объекте трехэлементной конструкции заданного графа-образца и множество всех номеров программных объектов трехэлементных конструкций в заданном графе-образце с этим элементом*</i> и в которых есть элементы, являющиеся первыми компонентами этих пар, всех таких номеров <i>программных объектов трехэлементных конструкций</i>, переход по которым в процессе поиска изоморфных по заданному графу-образцу конструкций может привести к зацикливанию алгоритма поиска конструкций по заданному графу-образцу. Данный этап предобработки сформированного <i>программного объекта графа-образца</i> позволяет максимально возможным образом устранить переходы по таким <i>программным объектам трехэлементных конструкций</i> заданного графа-образца, существенно усложняющие процесс изоморфного поиска конструкций по заданному графу-образцу. Такими <i>программными объектами трехэлементных конструкций</i> являются программные объекты трехэлементных конструкций, например, у которых первыми элементами является sc-адрес одного и того же <i>элемента sc-памяти, соответствующего sc-структуре</i>, или <i>класс элемента sc-памяти^, соответствующего переменной sc-структуре</i>, или sc-адрес одного и того же <i>элемента sc-памяти, соответствующего sc-узлу неролевого отношения</i>. Поскольку сам SC-код позволяет представлять конструкции любой возможной конфигурации, то нельзя точно сказать, какие именно конфигурации конструкций могут приводить к циклическим ситуациям при выполнении алгоритма изоморфного поиска этих конструкций по заданному графу-образцу. Более универсальный алгоритм устранения циклов в графе-образце может привести к существенным дополнительным временным затратам, поскольку может потребовать более глубокого синтаксического анализа в исходном графе-образце, поэтому рекомендуется реализовывать условия, по которым можно определять программные объекты трехэлементных конструкций, переход по которым может привести к циклическим ситуациям в обработке графа-образца. Устранение циклов в графе-образце позволяет алгоритму изоморфного поиска конструкций по заданному графу-образцу более эффективно производить все требуемые операции над графами, поэтому он является ключевым этапом предобработки исходного <i>программного объекта графа-образца</i>. Также данный шаг нельзя выполнять вместе с предыдущим шагом, поскольку для устранения всех циклов в графе-образце необходимо знать полностью все возможные переходы по этому графу-образцу.
									<li> Поиск всех компонент связности в заданном графе-образце, то есть не связанных между собой подграфов в этом графе, и добавление всех соответствующих этим компонентам связности <i>программных объектов трехэлементных конструкций</i> во множества <i>кортежа множеств номеров программных объектов трехэлементных конструкций компонент связности в заданном графе-образце</i>. Таким образом, это позволяет найти даже такие компоненты связности, которые могли быть получены после выполнения второго шага алгоритма предобработки заданного графа-образца, то есть устранения циклов в заданном графе-образце. Разбиение графа-образца на компоненты связности могло быть одним из решений в задаче устранения цикла в заданном графе-образце, однако сам алгоритм изоморфного поиска конструкций по заданному графу-образцу является более совершенным и позволяет за один обход итератора поиска трехэлементных конструкций находить все трехэлементные конструкции для тем трехэлементных конструкций графа-образца, которые имеют один и тот же первый или третий элемент, поэтому разбиение графа-образца на компоненты связности не используется в предыдущем шаге.
									<li> Последним шагом <i>Этапа предобработки графа-образца</i> является выделение в найденных на предыдущем шаге <i>Этапа предобработки графа-образца</i> компонентах связности самых приоритетных для поиска <i>программных объектов трехэлементных конструкций</i> в заданном графе-образце. Самым приоритетным программным объектом трехэлементной конструкции является объект, имеющий номер приоритета, равный нулю, самым неприоритетным --- объект, имеющий номер приоритета, равный шести. При этом, если есть несколько <i>программных объектов трехэлементных конструкций</i>, которые имеют один и тот же номер приоритета, то самым приоритетным из них считается тот объект, у которого первый (третий) элемент, являющийся sc-адресом элемента sc-памяти, имеет наименьшее количество элементов, соответствующих выходящим (входящим) sc-коннекторам. В результате формируется <i>множество номеров самых приоритетных для поиска программных объектов трехэлементных конструкций компонент связности в заданном графе-образце</i>.</li>
								<ul>Таким образом, <i>Этап предобработки графа-образца</i> позволяет существенно упростить обработку графа-образца на этапе поиска изоморфных ему конструкций. Следующий <b><i>Этап поиска конструкций в sc-памяти, изоморфных заданному графу-образцу</i></b> включает <u>следующие</u> шаги:
								<ul>
									<li> <u>Если</u> заданный <i>кортеж программных объектов конструкций в sc-памяти, изоморфных заданному графу-образцу</i> не пустой, то удалить из него все программные объекты конструкций в sc-памяти.
									<li> <u>Если</u> <i>множество номеров самых приоритетных для поиска программных объектов трехэлементных конструкций компонент связности в заданном графе-образце</i> является пустым, то это означает, что заданный <i>граф-образец</i> является пустым. В таком случае результатом поиска является пустой <i>кортеж программных объектов конструкций в sc-памяти, изоморфных заданному графу-образцу</i> и <i>Этап поиска конструкций в sc-памяти, изоморфных заданному графу-образцу</i> завершается с успешным результатом.
									<li> Инициализировать <i>номер последней найденной конструкции в sc-памяти по заданному графу-образцу</i> значением, равным нулю. Задать <i>Номер текущей найденной конструкции в sc-памяти по заданному графу-образцу</i>, равным <i>номеру последней найденной конструкции в sc-памяти по заданному графу-образцу</i>. Задать <i>множество номеров "равносильных" программных объектов конструкций</i>, равным <i>множеству номеров самых приоритетных для поиска программных объектов трехэлементных конструкций компонент связности в заданном графе-образце</i>. Задать <i>множество номеров текущих программных объектов конструкций</i>, равным <i>множество номеров "равносильных" программных объектов конструкций</i>.
									<li> Из <i>множество номеров "равносильных" программных объектов конструкций</i> выбрать следующий номер. По полученному номеру из <i>кортежа программных объектов трехэлементных конструкций в заданном графе-образце</i> взять соответствующий ему <i>программный объект трехэлементной конструкции заданного графа-образца</i> в этом графе-образце.
									<li> Для <i>выбранного программного объекта трехэлементной конструкции</i> в заданнои графе-образце найти <u>все</u> такие <i>программные объекты трехэлементных конструкций</i>, (1) у элементов которых заданные классы и sc-адреса совпадают с классами и sc-адресами элементов <i>выбранного программного объекта трехэлементной конструкции</i> соответственно, при этом либо первые, либо третие их элементы имеют одинаковые локальные идентификаторы в заданном графе-образце или не имеют их вовсе, (2) для которых не были найдены соответствующие замены, то есть множеству, расположенному в <i>кортеже множеств номеров программных объектов трехэлементных конструкций заданного графа-образца для найденных по нему изоморфных конструкций в sc-памяти, номера которых равны номерам позиций множеств в этом ориентированном множестве</i> по <i>номеру текущей найденной конструкции в sc-памяти по заданному графу-образцу</i>, не принадлежат номера найденных <i>программных объектов трехэлементных конструкций</i>, а также номера которых не принадлежат <i>множеству номеров текущих программных объектов конструкций</i>. <i>Множество номеров "равносильных" программных объектов конструкций</i> сделать равным множеству всех найденных <i>программные объекты трехэлементных конструкций</i>.
									<li> <u>Если</u> полученное <i>множество номеров "равносильных" программных объектов конструкций</i> является пустым, то завершить данную итерацию алгоритма.
									<li> <u>Если</u> полученное <i>множество номеров "равносильных" программных объектов конструкций</i> не является пустым, то из <i>множества номеров "равносильных" программных объектов конструкций</i> выбрать случайный номер. По полученному номеру из <i>кортежа программных объектов трехэлементных конструкций в заданном графе-образце</i> взять соответствующий ему <i>программный объект трехэлементной конструкции заданного графа-образца</i> в этом графе-образце.
									<li> По полученному <i>программному объекту трехэлементной конструкции</i> создать <i>итератор поиска трехэлементных конструкций в sc-памяти</i>. Создание <i>итератора поиска трехэлементных конструкций в sc-памяти</i> происходит при помощи <i>Метода создания итератора поиска трехэлементных конструкций в sc-памяти</i>. Параметры метода назначаются элементы заданного <i>программного объекта трехэлементной конструкции</i>, при этом вместо <i>классов элементов sc-памяти, соответствующих sc-переменным</i> (<i>классов элементов sc-памяти, соответствующих sc-метапеременным</i>), используются соответствующие им <i>классы элементов sc-памяти, соответствующие sc-константам</i> (<i>классы элементов sc-памяти, соответствующие sc-переменным</i>). То есть, например, если у некоторого элемента <i>программного объекта трехэлементной конструкции</i> задан <i>класс элементов sc-памяти, соответствующих переменным sc-узлам</i>, то вместо него для <i>Метода создания итератора поиска трехэлементных конструкций в sc-памяти</i> используется соответствующий ему <i>класс элементов sc-памяти, соответствующих константным sc-узлам</i>. Таким образом, при переходе от <i>программного объекта трехэлементной конструкции</i> к <i>программному итератору поиска трехэлементных конструкций sc-памяти</i> понижается степень переменности элементов <i>программного объекта трехэлементной конструкции</i>: <i>классы элементов sc-памяти, соответствующих sc-метапеременным</i> преобразуются в <i>классы элементов sc-памяти, соответствующих sc-переменным</i>, а <i>классы элементов sc-памяти, соответствующих sc-переменным</i> --- в <i>классы элементов sc-памяти, соответствующих sc-константам</i>. Если <i>класс элемента программного объекта трехэлементной конструкции</i> не является нестрогим подмножеством <i>класса элементов sc-памяти, соответствующих sc-метапеременным</i> или <i>класса элементов sc-памяти, соответствующих sc-переменным</i>, то степень переменности не понижается.
									<li> С помощью <i>Метода перехода к следующей "подходящей" для заданного итератора конструкции в sc-памяти</i> перейти к <i>конструкции в sc-памяти</i>, изоморфной заданной конструкции в графе-образце.</li>
								<ul>Несмотря на широкий спектр задач, которые можно решать при помощи текущей реализации <i>изоморфного поиска</i>, существует ряд причин, по которым не следует использовать эту и другие реализации <i>изоморфного поиска</i>:
								<ul>
									<li> <i>изоморфный поиск</i> позволяет решать широкий спектр задач, если все знания, изоморфные заданному <i>графу-образцу</i>, находятся в <i>базе знаний</i>, либо отсутствуют. То есть уровень качества <i>изоморфного поиска</i> напрямую зависит от состояния <i>базы знаний</i>. Чем разнообразнее <i>фрагменты базы знаний</i>, тем хуже <i>изоморфный поиск</i> в работе;
									<li> Затраты на поиск при больших <i>графах-образцах</i> могут расходится с желаниями разработчика или пользователя. Чем больше <i>граф-образец</i>, тем больше ситуаций, в которых может быть нестандартное поведение алгоритма <i>изоморфного поиска</i>.
									<li> Большую часть задач, решаемых при помощи <i>изоморфного поиска</i>, можно и нужно решать при помощи <i>итераторов поиска трех- и пяти- элементных конструкций</i>. Чем проще метод решения задач, тем меньше ошибок и внештатных ситуаций можно получить.</li>
								<ul></p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*];;
						*];;
					*];;
				*];;

				.system_element_4331
				=> .system_element_2880: [<p>Текущий <i>Программный интерфейс Реализации sc-памяти</i> позволяет:

				<ul>

					<li> В необходимой и достаточной мере реализовывать <u>платформенно-зависимые</u> подсистемы текущего <i>Программного варианта реализации ostis-платформы</i>, практически независимо от <i>Реализации sc-памяти</i>. То есть текущий <i>Программный интерфейс Реализации sc-памяти</i> является способом унификации доступа к программной <i>Реализации sc-памяти</i> и позволяет <u>легко</u> подменять различные варианты реализации sc-памяти на <i>языке представления методов</i> <i>С++</i>, при этом сам <i>Программный интерфейс Реализации sc-памяти</i> практически не меняется или не изменяется вовсе.

					<li> Реализовывать базовые инструментальные средства для проектирования платформенно-независимых ostis-систем, например, <i>Реализацию scp-интерпретатора</i>.

					<li> Формировать и расширять <i>Библиотеку многократно используемых компонентов Программного варианта реализации ostis-платформы</i> за счет компонентов, использующих методы <i>Реализации sc-памяти</i> и входящих в состав различных программных расширений текущего <i>Программного интерфейса Реализации sc-памяти</i>.

					<li> Обеспечить различные уровни доступа к <i>Реализации sc-памяти</i>, в том числе уровни доступа различных пользователей <i>Программного варианта реализации ostis-платформы</i>. </li>

				<ul>Стоит отметить, что <i>Программный интерфейс Реализации sc-памяти</i> не может существовать отдельно от текущей <i>Реализации sc-памяти</i>. Кроме того, он является частью <i>Реализации sc-памяти</i>, то есть проектируется и разрабатывается согласованно с реализацией самой sc-памяти. Однако при необходимости он может быть использован для различных модификаций или версий текущей <i>Реализации sc-памяти</i>.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> .system_element_139: [<p>Несмотря на широкий спектр функциональных возможностей текущего <i>Программного интерфейса Реализации sc-памяти</i>, к его недостатком можно отнести следующее:
				<ul>
					<li> На уровне <i>Программного интерфейса Реализации sc-памяти</i> никак не ограничивается диапозон классов sc-элементов в sc-памяти, которые могут быть установлены в качестве аргументов, например, для <i>Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-узлу</i> и <i>Метода создания элемента в sc-памяти с заданным классом, соответствующего некоторому sc-коннектору</i>.
					<li> Из-за недостатков текущей реализации агентной архитектуры в <i>Программном варианте реализации ostis-платформы</i> <u>нельзя</u> для <i>Программного интерфейса Реализации sc-памяти</i> использовать <i>Реализацию sc-памяти</i>, хранящуюся в виде скомпилированного файла. Прежде всего это связано с тем, что платформенно-зависимые агенты реализуются средствами, которые используют создание исходных файлов при сборке всей платформы. Таким образом скомпилированные файлы остаются зависимыми от того устройства, где они были собраны.</li>
				<ul></p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*];;

			.system_element_4541
			=> nrel_inclusion: [*
				=> nrel_idtf: [<p>Документация Сетевого интерфейса Реализации sc-памяти Программной платформе ostis-систем</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				-> rrel_key_sc_element: .system_element_4332;
				=> nrel_authors: 
					.system_element_4293
				;
				=> nrel_explanation: [<p>Взаимодействие программной модели sc-памяти с внешними ресурсами может осуществляться посредством специализированного <i>Программного интерфейса Реализации sc-памяти</i>, однако этот вариант неудобен в большинстве случае, поскольку:
				<ul>
					<li> поддерживается только для очень ограниченного набора языков программирования (С, С++);
					<li> требует того, чтобы клиентское приложение, обращающееся к программной модели sc-памяти, фактически составляло с ней единое целое, таким образом исключается возможность построения распределенного коллектива ostis-систем;
					<li> как следствие предыдущего пункта, исключается возможность параллельной работы с sc-памятью нескольких клиентских приложений.</li>
				<ul>Для того, чтобы обеспечить возможность удаленного доступа к sc-памяти не учитывая при этом языки программирования, с помощью которых реализовано конкретное клиентское приложение, было принято решение о реализации возможности доступа к sc-памяти с использованием универсального языка, не зависящего от средств реализации того или иного компонента или системы. В качестве такого языка был разработан строковый язык на базе языка JSON.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;

				.system_element_4332
				=> nrel_idtf: [<p>Реализация подсистемы взаимодействия c sc-памятью на основе сетевых языков Websocket и JSON</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
					=> nrel_explanation: [<p>Реализация подсистемы взаимодействия c sc-памятью на основе языка JSON позволяет ostis-системам взаимодействовать с системами из внешней среды на основе общепринятого транспортного формата передачи данных JSON и предоставляет сетевой интерфейс для доступа к sc-памяти ostis-платформы.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;
				*);
				<- .system_element_120;
				<- .system_element_287;
				<- .system_element_290;
				=> .system_element_4322: 
					.system_element_4323;
					.system_element_217;
					.system_element_211;
					.system_element_4542;
					.system_element_4543;
					.system_element_1237
				;
				=> .system_element_405: 
					.system_element_4544
				;
				=> nrel_authors: 
					.system_element_4293
				;
				=> nrel_explanation: [<p>Взаимодействие c sc-памятью обеспечивается с помощью передачи информации на <i><b>SC-JSON-коде</b></i> и ведётся, с одной стороны, между сервером, являющегося частью ostis-системы, написанным на том же языке реализации этой ostis-системы и имеющим доступ к её sc-памяти, и с другой стороны множеством клиентом, которым известно о наличии сервера в пределах сети их использования.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> nrel_note: [<p>Осмысленные фрагменты текстов <i><b>SC-JSON-кода</b></i> представляют семантически корректную структуру сущностей и связей между ними.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> nrel_note: [<p>С помощью подсистемы взаимодействия с sc-памятью на основе языка JSON можно взаимодействовать с ostis-системой на таком же множестве возможных операций, как и в случае, если бы взаимодействие происходило (непосредственно) напрямую, на том же языке реализации платформы интерпретации sc-моделей компьютерных систем. При этом результат работы отличается только скоростью обработки информации.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> .system_element_4312: {
					.system_element_4545;
					.system_element_4546
					(*
						=> .system_element_4312: {
							.system_element_4547;
							.system_element_4548;
							.system_element_4549;
							.system_element_4550
						};;
					*)
				};;

				.system_element_4545
				=> nrel_idtf: [<p>Серверная система на основе Websocket, обеспечивающая доступ к Реализации sc-памяти в Программной платформе ostis-систем при помощи команд SC-JSON-кода</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> nrel_idtf: [<p>Система, работающая по принципам Websocket и предоставляющая параллельно-асинхронный многоклиентский доступ к sc-памяти платформы интерпретации sc-моделей при помощи SC-JSON-кода</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> nrel_idtf: [<p>SC-JSON-сервер</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> .system_element_2127: [<p>sc-сервер</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				<- .system_element_120;
				<- .system_element_286;
				<- .system_element_290;
				=> .system_element_4322: 
					.system_element_4551;
					.system_element_217
				;
				=> .system_element_936: 
					.system_element_4544
				;
				=> .system_element_130: 
					.system_element_4552;
					.system_element_4553;
					.system_element_4554
					(*
						=> nrel_idtf: [<p>sc-config-utils</p>];;
						<= .system_element_4555: .system_element_4554
						(*
							=> nrel_idtf: [<p>sc-config-utils</p>];;
							<- .system_element_120;;
							<- .system_element_287;;
							<- .system_element_290;;
							=> nrel_authors: 
								.system_element_4293
							;;
							=> .system_element_129: [<p>https://github.com/ostis-ai/sc-machine/tree/main/sc-tools/sc-config-utils</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);;
					*);
					.system_element_4313
				;
				=> .system_element_129: [<p>https://github.com/ostis-ai/sc-machine/tree/main/sc-tools/sc-server</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> nrel_authors: 
					.system_element_4293
				;;

				.system_element_4556
				=> nrel_inclusion: [*
					=> nrel_idtf: [<p>Документация Метаязыка обмена сообщениями между ostis-системами в Программной платформе ostis-систем</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					-> rrel_key_sc_element: .system_element_4544;
					=> nrel_authors: 
						.system_element_4293
					;
					=> nrel_explanation: [<p>Среди эффективных протоколов, используемых при реализации <i>клиент-серверных систем</i>, стоит отметить протоколы прикладного уровня стека <i>TCP/IP</i> --- протоколы <b><i>HTTP</i></b> и <b><i>WebSocket</i></b> Bhumij2018. Целесообразным является использование протокола <i>WebSocket</i>, это объясняется следующими причинами: <i>WebSocket</i> выгодно использовать в веб-ориентированных системах, в которых данные, отправляемые сервером, представляются или сохраняются на стороне клиента. В <i>WebSocket</i> данные постоянно передаются через одно и то же открытое <i>соединение</i>, поэтому коммуникация по протоколу <i>WebSocket</i> быстрее чем коммуникация по HTTP Tomasetti2021, Bhumij2018. Это очень важно с точки зрения проектирования <i>Экосистемы OSTIS</i>, которые могут состоять из <u>десятков тысяч</u> различного вида <i>ostis-систем</i>.
					<li> Поскольку в основе <i>ostis-систем</i> лежит идея агентно-ориентированной обработки знаний (асинхронной обработки), а память таких систем должна быть одновременно распределенной и общей, то необходимо, чтобы каждая из них (в частности, самостоятельная <i>ostis-система</i>) могла общаться с другими <i>ostis-системами</i>. Причем такое общение может и должно происходить посредством инициирования событий в памяти этих систем. Отсюда следует однозначный вывод, что протокол <i>HTTP</i> не может быть использован в передовых <i>интеллектуальных системах нового поколения</i> по причине однонаправленности создаваемого им соединения.В силу слабой развитости средств для обработки текстов на <i>SCs-коде</i> в качестве языка коммуникации систем был разработан строковый язык на базе языка <i>JSON</i> Marrs2017 --- <i>SC-JSON-код</i>. Его выбор объясняется гибкостью задания отношений между описываемыми им объектами.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4544
					=> nrel_idtf: [<p>Semantic JSON-code</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_idtf: [<p>Semantic Javascript Object Notation code</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_idtf: [<p>Язык внешнего смыслового представления знаний для взаимодействия с ostis-системами на основе языка JSON</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> nrel_idtf: [<p>Метаязык, являющийся подмножеством языка JSON и обеспечивающий внешнее представление и структуризацию <i>sc-текстов</i>, используемых ostis-системой в процессе своего функционирования и взаимодействия со внешней средой.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					=> .system_element_2127: [<p>sc-json-текст</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
						<- .system_element_2012;;
					*);
					<- .system_element_2128;
					<- .system_element_2596;
					<= nrel_inclusion: .system_element_4557;
					=> nrel_authors: 
						.system_element_4293;
						.system_element_4311
					;
					=> .system_element_2130: 
						.system_element_4558;
						.system_element_4559
					;
					=> .system_element_2880: {
						[<p>Язык JSON является общепринятым открытым форматом, для работы с которым существует большое количество библиотек для популярных языков программирования. Это, в свою очередь, упрощает реализацию клиента и сервера для протокола, построенного на базе <i><b>SC-JSON-код</b></i>.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						[<p>Реализация подсистемы взаимодействия со внешней средой на базе <i><b>SC-JSON-код</b></i> не накладывает принципиальных ограничений на объем (длину) каждой команды, в отличие от других бинарных протоколов. Таким образом, появляется возможность использования неатомарных команд, позволяющих, например, за один акт пересылки такой команды по сети создать сразу несколько sc-элементов. Важными примерами таких команд являются <i>команда создания sc-конструкции, изоморфной заданному sc-шаблону</i>, и <i>команда поиска sc-конструкций, изоморфных заданному sc-шаблону</i>.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*)
					};
					=> nrel_note: [<p>Можно сказать, что язык на базе JSON является следующим шагом на пути к созданию мощного и универсального языка запросов, аналогичного языку SQL для реляционных баз данных и предназначенному для работы с sc-памятью. Следующий шагом станет реализация такого протокола на основе одного из стандартов внешнего отображения sc-конструкций, например, <i>SCs-кода</i>, что, в свою очередь, позволит передавать в качестве команд целые программы обработки sc-конструкций, например на Языке SCP.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);;

					.system_element_4560
					=> nrel_inclusion: [*

						.system_element_4560
						=> nrel_note: [<p><i>Синтаксис SC-JSON-кода</i> задается: (1) <i>Алфавитом SC-JSON-кода</i>, (2) Грамматикой SC-JSON-кода</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= .system_element_1010: .system_element_4544;;

						.system_element_4561
						=> nrel_inclusion: [*

							.system_element_4544
							<= nrel_set_of_subsets: .system_element_4562
							(*
								<= nrel_inclusion: .system_element_4563;;
								<= nrel_set_of_subsets: .system_element_4564
								(*
									<= nrel_cartesian_product: <
										.system_element_4565;
										.system_element_4566
										(*
											=> nrel_subdividing: {
												.system_element_4567;
												.system_element_4568;
												.system_element_4569
												(*
													=> nrel_subdividing: {
														.system_element_4565;
														.system_element_4570
													};;
												*)
											};;
										*)
									>;;
								*);;
								=> nrel_subdividing: {
									.system_element_4571;
									.system_element_4572
								};;
							*);;
						*];;

						.system_element_4573
						=> nrel_idtf: [<p>Множество всех возможных символов в SC-JSON-коде</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						=> nrel_explanation: [<p>Поскольку SC-JSON-код является линейным строковым языком представления знаний, то его алфавит включает объединение алфавитов всех языков, тексты на которых могут представлять внешние идентификаторы и/или содержимое файлов ostis-системы, множество всех цифр и множество всех других специальных символов.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= .system_element_827: .system_element_4544;
						=> nrel_note: [<p>Последовательности знаков алфавита могут образовывать sc-json ключевые слова, sc-json-пары, sc-json-предложения из sc-json-пар и sc-json-тексты из sc-json-предложений.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4544
						=> .system_element_2166: 
							[<p>Каждое правило <i>Грамматики SC-JSON-кода</i> описывает корректный с точки зрения <i>Синтаксиса SC-JSON-кода</i> порядок sc-json-объектов в sc-json-предложении. Совокупность правил <i>Грамматики SC-JSON-кода</i> описывает корректный с точки зрения <i>Синтаксиса SC-JSON-кода</i> порядок sc-json-предложений в sc-json-тексте.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);
							[<p>Каждое sc-json-предложение является sc-json-списком, состоящим из sc-json-пар и представляет собой команду или ответ на эту команду.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);
							[<p>Каждое <i>команда (ответ на команду) на SC-JSON-коде</i> состоит из заголовка, включающего sc-json-пары описания самой команды (ответа на команду), и сообщения, различного для каждого класса команд (ответов на команды). Сообщение <i>команды (ответа на команду) на SC-JSON-коде</i> обычно представляет собой список sc-json-объектов и может не ограничиваться по мощности.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);
							[<p>Каждая sc-json-пара состоит из двух элементов: ключевого слова и некоторого другого sc-json-объекта, ассоциируемого с этим ключевым словом. Набор ключевых слов в sc-json-парах определяется конкретным классом <i>команд (ответов на команды) на SC-JSON-коде</i>. sc-json-пара начинается знаком открывающейся фигурной скобки " и заканчивается знаком закрывающейся фигурной скобки """. Ключевое слово и sc-json-объект, ассоциируемый с ним, разделяются при помощи знака двоеточия ":".</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);
							[<p>sc-json-строки, записанные в sc-json-текстах, начинаются и заканчиваются знаком двух ковычек .</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);
							[<p>sc-json-списки, состоящие не из sc-json-пар, начинаются знаком открывающейся квадратной скобки "" и заканчиваются знаком закрывающейся квадратной скобки "". sc-json-объекты в sc-json-списках разделяются запятыми ",".</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*)
						;;

						.system_element_4574
						=> nrel_idtf: [<p>Множество всех возможных правил, используемых при построении команд и ответов на них на SC-JSON-коде</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						=> nrel_explanation: [<p>Каждой команде <i>SC-JSON-кода</i> однозначно соответствует правило грамматики <i>SC-JSON-кода</i>.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= .system_element_4575: .system_element_4544;
						=> nrel_explanation: [<p>Правила <i>Грамматики SC-JSON-кода</i> позволяют правильно составить команду на SC-JSON-коде. Каждое правило грамматики <i>SC-JSON-кода</i> представляется в виде правила на <i>Языке описания грамматик ANTLR</i> и его интерпретации на естественном языке.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						-> rrel_key_sc_element: .system_element_4576
						(*
							<=> nrel_semantic_equivalence: "file://images/command.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Класс <i>команд на SC-JSON-коде</i> включает <i>команду создания sc-элементов</i>, <i>команду получения соответствующих типов sc-элементов</i>, <i>команду удаления sc-элементов</i>, <i>команду обработки ключевых sc-элементов</i>, <i>команду обработки содержимого файлов ostis-системы</i>, <i>команду поиска sc-конструкций, изоморфных заданному sc-шаблону</i>, <i>команду генерации sc-конструкции, изоморфной заданному sc-шаблону</i>, и <i>команду обработки sc-событий</i>. В <i>команду на SC-JSON-коде</i> включаются идентификатор этой команды, тип и сообщение.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4571;;
						*);
						-> rrel_key_sc_element: .system_element_4580
						(*
							<=> nrel_semantic_equivalence: "file://images/command_answer.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Класс <i>ответов на команды на SC-JSON-коде</i> включает <i>ответ на команду создания sc-элементов</i>, <i>ответ на команду получения соответствующих типов sc-элементов</i>, <i>ответ на команду удаления sc-элементов</i>, <i>ответ на команду обработки ключевых sc-элементов</i>, <i>ответ на команду обработки содержимого файлов ostis-системы</i>, <i>ответ на команду поиска sc-конструкций, изоморфных заданному sc-шаблону</i>, <i>ответ на команду генерации sc-конструкции, изоморфной заданному sc-шаблону</i>, и <i>ответ на команду обработки sc-событий</i>. В <i>ответ на команду на SC-JSON-коде</i> включаются идентификатор соответствующей команды, статус обработки ответа и ответное сообщение.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4572;;
						*);
						-> .system_element_4581
						(*
							<=> nrel_semantic_equivalence: "file://images/create_elements_command.pdf"
							(*
								<- concept_file;;
								=> nrel_format: format_pdf;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>В сообщении <i>команды создания sc-элементов</i> представляется список описаний создаваемых sc-элементов. Такими sc-элементами могут быть sc-узел, sc-дуга, sc-ребро или файл ostis-системы. Тип sc-элемента указывается в паре с ключевым словом "el": для sc-узла sc-json-тип элемент представляется как "node", для sc-дуги и sc-ребра --- "edge", для файла ostis-системы --- "link". Метки типов sc-элементов уточняются в соответствующих им описаниях в сообщении команды в паре с ключевым словом "type". Если создаваемым sc-элементом является файл ostis-системы, то дополнительно указывается содержимое этого файла ostis-системы в паре с ключевым словом "content", если создаваемым sc-элементом является sc-дуга или sc-ребро, то указываются описания sc-элементов, из которых они выходят, и sc-элементов, в которые они входят. Описание таких sc-элементов состоят из двух пар: первая пара указывает на способ ассоциации с sc-элементом и представляется как "addr" или "idtf" или "ref" в паре с ключевым словом "type", вторая пара --- то, по чему происходит ассоциация с этим sc-элементом: его хэшу, системному идентификатору или номеру в массиве создаваемых sc-элементов --- в паре с ключевым словом "value".</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4582;;
						*);
						-> .system_element_4583
						(*
							<=> nrel_semantic_equivalence: "file://images/create_elements_command_answer.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Сообщением <i>ответа на команду создания sc-элементов</i> является список хэшей созданных sc-элементов, соответствующих описаниям <i>команды создания sc-элементов</i> со статусом 1, в случае успешной обработки команды.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4584;;
						*);
						-> .system_element_4585
						(*
							<=> nrel_semantic_equivalence: "file://images/create_elements_by_scs_command.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>В списке описаний создаваемых sc-элементов сообщения этой команды вместо описания создаваемого отдельного sc-элемента указывается фрагмент SCs-текста.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4586;;
						*);
						-> .system_element_4587
						(*
							<=> nrel_semantic_equivalence: "file://images/create_elements_by_scs_command_answer.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Сообщением <i>ответа на команду создания sc-элементов</i> является список результатов обработки переданных SCs-текстов. Нулевой статус говорит о том, что обработка соотвествующего SCs-текста завершилась безуспешно.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4588;;
						*);
						-> .system_element_4589
						(*
							<=> nrel_semantic_equivalence: "file://images/check_elements_command.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Сообщением <i>команды получения соответствующих типов sc-элементов</i> является списком хэшей sc-элементов, у которых необходимо получить синтаксические типы.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4590;;
						*);
						-> .system_element_4591
						(*
							<=> nrel_semantic_equivalence: "file://images/check_elements_command_answer.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Сообщением <i>ответа на команду получения соответствующих типов sc-элементов</i> является список типов проверенных sc-элементов, соответствующих описаниям <i>команды получения соответствующих типов sc-элементов</i> со статусом 1, в случае успешной обработки команды.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4592;;
						*);
						-> .system_element_4593
						(*
							<=> nrel_semantic_equivalence: "file://images/delete_elements_command.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Сообщением <i>команды удаления sc-элементов</i> является список хэшей sc-элементов, которые необходимо удалить из sc-памяти.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4594;;
						*);
						-> .system_element_4595
						(*
							<=> nrel_semantic_equivalence: "file://images/delete_elements_command_answer.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Сообщение <i>ответа на команду удаления sc-элементов</i> является пустым со статусом 1, в случае успешной обработки команды.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4596;;
						*);
						-> .system_element_4597
						(*
							<=> nrel_semantic_equivalence: "file://images/handle_keynodes_command.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Сообщение <i>команды обработки ключевых sc-элементов</i> может включать описание ключевых sc-элементов, которые необходимо найти и/или разрешить по их идентификаторам. Такое деление осуществляется с помощью подкоманд, содержащихся в сообщении команды. Идентификаторами подкоманд могут быть "find" и "resolve" соответственно, стоящие в паре с ключевым словом "command". Описание искомого sc-элемента команды "find" включает системный идентификатор sc-элемента, по которому необходимо найти этот sc-элемент, стоящий в паре с ключевым словом "idtf". Описание разрешаемого sc-элемента команды "resolve" включает системный идентификатор sc-элемента, по которому необходимо найти этот sc-элемент, либо в случае безуспешного поиска создать sc-элемент некоторого типа, указанного в его описании в паре с ключевым словом "elType", и установить для него системный идентификатор, по которому была произведена попытка найти другой sc-элемент.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4598;;
						*);
						-> .system_element_4599
						(*
							<=> nrel_semantic_equivalence: "file://images/handle_keynodes_command_answer.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Сообщением <i>ответа на команду обработки ключевых sc-элементов</i> является список хэшей sc-элементов, соответствующих описаниям <i>команды обработки ключевых sc-элементов</i> со статусом 1, в случае успешной обработки команды.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4600;;
						*);
						-> .system_element_4601
						(*
							<=> nrel_semantic_equivalence: "file://images/handle_link_contents_command.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Сообщение <i>команды обработки содержимого файлов ostis-системы</i> может включать описание ключевых файлов ostis-системы, которые необходимо найти по их содержимому или части этого содержимого, для которых необходимо установить содержимое разрешить и/или у которых необходимо получить содержимое. Как и в <i>Правиле, задающее синтаксис команды обработки ключевых sc-элементов</i> деление осуществляется с помощью подкоманд, содержащихся в сообщении команды. Идентификаторами подкоманд могут быть "find", "find_by_substr", "set" и "get" соответственно, стоящие в паре с ключевым словом "command". В описаниях команд "set" и "get" указывается хэш файла ostis-системы в паре с ключевым словом "addr". В описаниях команд "set", "find" и "find_by_substr" указывается содержимое файла ostis-системы в паре с ключевым словом "data". Дополнительно в описании подкоманды "set" указывается тип устанавливаемого содержимого файла ostis-системы.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4602;;
						*);
						-> .system_element_4603
						(*
							<=> nrel_semantic_equivalence: "file://images/handle_link_contents_command_answer.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Сообщением <i>ответа на команду обработки содержимого файлов ostis-системы</i> является список, состоящий из булевого результата установки содержимого в файл ostis-системы и/или найденных файлов ostis-системы по их содержимому и/или описания полученного содержимого файлов ostis-системы, соответствующих описаниям <i>команды обработки содержимого файлов ostis-системы</i> со статусом 1, в случае успешной обработки команды.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4604;;
						*);
						-> .system_element_4605
						(*
							<=> nrel_semantic_equivalence: "file://images/search_template_command.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								<= nrel_inclusion: .system_element_4606;;
								=> .system_element_4578: [<p><i>Правило, задающее синтаксис команды поиска sc-конструкций, изоморфных заданному sc-шаблону</i> включает <i>Правило, задающее синтаксис сообщения <i>команды поиска sc-конструкций, изоморфных заданному sc-шаблону,</i> и <i>команды генерации sc-конструкции, изоморфной заданному sc-шаблону</i></i> и описывает команду поиска sc-конструкций по сформированному этой командой sc-шаблону (см. <i>Правило, задающее синтаксис сообщения <i>команды поиска sc-конструкций, изоморфных заданному sc-шаблону,</i> и <i>команды генерации sc-конструкции, изоморфной заданному sc-шаблону</i></i>).</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4607;;
						*);
						-> .system_element_4608
						(*
							<=> nrel_semantic_equivalence: "file://images/search_template_command_answer.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Сообщение <i>ответа на команду поиска sc-конструкций, изоморфных заданному sc-шаблону</i> состоит из списка найденных sc-конструкций и отображения псевдонимов sc-элементов на их позиции в тройках sc-шаблона. Ответ имеет статус 1, в случае успешной обработки команды.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4609;;
						*);
						-> .system_element_4610
						(*
							<=> nrel_semantic_equivalence: "file://images/generate_template_command.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								<= nrel_inclusion: .system_element_4611;;
								=> .system_element_4578: [<p><i>Правило, задающее синтаксис команды создания sc-конструкции, изоморфной заданному sc-шаблону</i> включает <i>Правило, задающее синтаксис сообщения <i>команды поиска sc-конструкций, изоморфных заданному sc-шаблону,</i> и <i>команды генерации sc-конструкции, изоморфной заданному sc-шаблону</i></i> и описывает команду создания sc-конструкции по сформированному этой командой sc-шаблону (см. <i>Правило, задающее синтаксис сообщения <i>команды поиска sc-конструкций, изоморфных заданному sc-шаблону,</i> и <i>команды генерации sc-конструкции, изоморфной заданному sc-шаблону</i></i>).</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4612;;
						*);
						-> .system_element_4613
						(*
							<=> nrel_semantic_equivalence: "file://images/generate_template_command_answer.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Сообщение <i>ответа на команду создания sc-конструкции, изоморфной заданному sc-шаблону</i> состоит из списка найденных sc-конструкций и отображения псевдонимов sc-элементов на их позиции в тройках sc-шаблона. Ответ имеет статус 1, в случае успешной обработки команды.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4614;;
						*);
						-> .system_element_4615
						(*
							<=> nrel_semantic_equivalence: "file://images/template_message_command.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Сообщения <i>команды поиска sc-конструкций, изоморфных заданному sc-шаблону,</i> и <i>команды создания sc-конструкции, изоморфной заданному sc-шаблону</i> включают описание троек, необходимых для создания sc-шаблона поиска или генерации изоморфных sc-конструкций. Описание каждой тройки sc-шаблона включает описание sc-элементов этой тройки. Описания первого и третьего sc-элементов тройки должны всегда содержать хэш или тип в паре с ключевым словом "value". Если выбран тип, то в паре с ключевым словом "type" указывается "type", если --- хэш, то --- "addr". Вторым sc-элементом тройки должна быть дуга, для которой всегда указывается тип в паре с ключевым словом "value". Для каждого sc-элемента тройки может указываться псевдоним в паре с "alias". Псевдоним представляет собой строку и может быть использован для ассоциации с sc-элементами в других тройках sc-шаблона, либо ассоциации со значениями переменных sc-шаблона, которые указываются в списке под ключевым словом "params" и могут представлять собой либо хэш sc-элемента, либо его системный идентификатор. Таким образом, в некоторых случаях может отсутствовать необходимость указания хэша или типа sc-элемента. Также вместо списка описаний троек sc-шаблона, может указываться хэш или системный идентификатор sc-структуры, хранящейся в sc-памяти. хэш и системный идентификатор указываются в паре с ключевым словом "value".</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
						*);
						-> .system_element_4616
						(*
							<=> nrel_semantic_equivalence: "file://images/handle_events_command.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Сообщение <i>команды обработки sc-событий</i> может включать описание sc-элементов, по котором необходимо зарегистрировать или разрегистрировать sc-события. Идентификаторами подкоманд в описании команды могут быть "create" и "delete" соответственно, стоящие в паре с ключевым словом "command". Описание команды регистрации sс-cобытий "create" представляет собой список описаний типов sc-событий и sc-элементов, по которым необходимо зарегистрировать sc-события. Описания sc-элементов включают хэши этих sc-элементов в парах с ключевым словом "addr". Описание команды разрегистрации sc-событий представляет собой список позиций sc-событий в очереди sc-событий, которые необходимо удалить из этой очереди sc-событий.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							=> nrel_inclusion: .system_element_4617
							(*
								<=> nrel_semantic_equivalence: "file://images/sc_event_types.png"
								(*
									<- concept_file;;
									=> nrel_format: format_png;;
									<- .system_element_4577;;
									=> .system_element_4578: [<p>sc-событиями могут быть <i>sc-события добавления выходящей дуги из sc-элемента (add_outgoing_edge)</i>, <i>sc-события добавления входящей дуги в sc-элемент (add_ingoing_edge)</i>, <i>sc-события удаления выходящей дуги из sc-элемента (remove_outgoing_edge)</i>, <i>sc-события удаления входящей дуги в sc-элемент (remove_ingoing_edge)</i>, <i>sc-события изменения содержимого файла ostis-системы (content_change)</i> и <i>sc-события удаления sc-элемента (delete_element)</i>.</p>]
									(*
										<- lang_ru;;
										=> nrel_format: format_html;;
									*);;
								*);;
							*);;
							<= .system_element_4579: .system_element_4618;;
						*);
						-> .system_element_4619
						(*
							<=> nrel_semantic_equivalence: "file://images/handle_events_command_answer.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p>Сообщение <i>ответа на команду обработки sc-событий</i> состоит из позиций зарегистрированных sc-событий в очереди. Успешным результатом <i>команды обработки sc-событий</i> является статус 1.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4620;;
						*);
						-> .system_element_4621
						(*
							<=> nrel_semantic_equivalence: "file://images/init_event_command_answer.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p><i>Ответ инициализации sc-события</i> возникает тогда и только тогда, когда в sc-памяти инициализируется соответствующее sc-событие. <i>Ответ инициализации sc-события</i> всегда отсылается той клиентской системе, которая зарегистрировала это sc-событие. В сообщение <i>ответа инициализации sc-события</i> включаются хэши тех sc-элементов, которые связаны с зарегистрированным sc-событием. Таким образом, если было зарегистрировано sc-событие выходящей sc-дуги, то в списке сообщения <i>ответа инициализации sc-события</i> будут находится хэши трёх sc-элементов: хэш sc-элемента, который был подписан на sc-событие, хэш добавленной выходящей из него sc-дуги и хэш sc-элемента, являющегося концом этой sc-дуги.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							<= .system_element_4579: .system_element_4622;;
						*);
						-> .system_element_4623
						(*
							<=> nrel_semantic_equivalence: "file://images/sc_addr_types.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p><i>Правило, задающее синтаксис синтаксических типов sc-элементов</i> включает <i>Правило, задающее синтаксис синтаксических типов sc-узлов</i>, <i>Правило, задающее синтаксис синтаксических типов sc-дуг</i>, <i>Правило, задающее синтаксис синтаксических типов файлов ostis-системы</i>. Синтаксические типы sc-элементов представляются в виде целого числа и соответствуют программным синтаксическим типам, представляемым в sc-памяти.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
							=> nrel_note: [<p>На данный момент форма представления синтаксического типа sc-элемента зависит от того, как располагаются биты в маске sc-элемента. Следующим шагом в развитии <i>SC-JSON-кода</i> и его грамматики могли быть стать устранение такой зависимости и переход к представлению синтаксических типов в виде строковых литералов, интерпретируемых <i>Реализации интерпретатора команда SC-JSON-кода</i>.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);
						-> .system_element_4624
						(*
							<=> nrel_semantic_equivalence: "file://images/sc_node_types.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p><i>Правило, задающее синтаксис синтаксических типов sc-узлов</i> описывает возможные синтаксические типы sc-узлов, интерпретируемые на стороне <i>Реализации интерпретатора команда SC-JSON-кода</i>.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
						*);
						-> .system_element_4625
						(*
							<=> nrel_semantic_equivalence: "file://images/sc_edge_types.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p><i>Правило, задающее синтаксис синтаксических типов sc-дуг</i> описывает возможные синтаксические типы sc-дуг, в том числе и sc-рёбер, интерпретируемые на стороне <i>Реализации интерпретатора команда SC-JSON-кода</i>.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
						*);
						-> .system_element_4626
						(*
							<=> nrel_semantic_equivalence: "file://images/sc_link_types.png"
							(*
								<- concept_file;;
								=> nrel_format: format_png;;
								<- .system_element_4577;;
								=> .system_element_4578: [<p><i>Правило, задающее синтаксис синтаксических типов файлов ostis-системы</i> описывает возможные синтаксические типы файлов ostis-системы, интерпретируемые на стороне <i>Реализации интерпретатора команда SC-JSON-кода</i>.</p>]
								(*
									<- lang_ru;;
									=> nrel_format: format_html;;
								*);;
							*);;
						*);;

						.system_element_4571
						=> nrel_idtf: [<p>sc-json-code command</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4544;
						=> nrel_note: [<p>Множество <i>команд на SC-JSON-коде</i> легко расширяемо засчёт гибкости и функциональности языка JSON.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4572
						=> nrel_idtf: [<p>sc-json-code command answer</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4544;
						=> nrel_note: [<p>Множество <i>ответов на команды на SC-JSON-коде</i> легко расширяемо вместе с расширением <i>команд на SC-JSON-коде</i>.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4582
						=> nrel_idtf: [<p>create elements command</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4571;
						=> .system_element_203: .system_element_4627
						(*
							<=> nrel_semantic_equivalence: "file://images/create_elements_command_example.png";;
							<- .system_element_4582;;
							=> .system_element_3489: .system_element_4628;;
							=> .system_element_4578: [<p>Обработать команду создания sc-элементов: sc-узла с типом 1 (неуточняемого типа), файла ostis-системы с типом 2 (неуточняемого типа) и содержимым в виде числа с плавающей точкой 45.4 и sc-дуги типа 32 (константного типа) между sc-элементом, находящимся на нулевой позиции в массиве создаваемых sc-элементов, и sc-элементом, находящимся на первой позиции в том же самом массиве.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);
						=> .system_element_4629: .system_element_4584;
						=> nrel_note: [<p>Стоит отметить, что на уровне интерфейса sc-памяти команда интерпретируется быстро за счёт того, что не используются шаблоны создания изоморфных им конструкций. Также содержимое сообщения <i>команды создания sc-элементов</i> может быть пустым.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4584
						=> nrel_idtf: [<p>create elements command answer</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4572;
						=> .system_element_203: .system_element_4628
						(*
							<=> nrel_semantic_equivalence: "file://images/create_elements_command_answer_example.png";;
							<- .system_element_4584;;
							=> .system_element_4578: [<p>Созданы sc-элементы с хэшами 323, 534 и 342 соответственно. Команда обработана успешно.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);;

						.system_element_4590
						=> nrel_idtf: [<p>check elements command</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4571;
						=> .system_element_203: .system_element_4630
						(*
							<=> nrel_semantic_equivalence: "file://images/check_elements_command_example.png";;
							<- .system_element_4590;;
							=> .system_element_3489: .system_element_4631;;
							=> .system_element_4578: [<p>Получить синтаксические типы sc-элементов с хэшами 885 и 1025.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);
						=> .system_element_4629: .system_element_4592;
						=> nrel_note: [<p>Содержимое сообщения <i>команды получения соответствующих типов sc-элементов</i> может быть пустым.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4592
						=> nrel_idtf: [<p>check elements command answer</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4572;
						=> .system_element_203: .system_element_4631
						(*
							<=> nrel_semantic_equivalence: "file://images/check_elements_command_answer_example.png";;
							<- .system_element_4592;;
							=> .system_element_4578: [<p>Типы sc-элементов 32 и 0 соответственно. Команда обработана успешно.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);
						=> nrel_note: [<p>Если sc-элемент с указанным хэшем не существует, то его тип будет равен 0.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4594
						=> nrel_idtf: [<p>delete elements command</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4571;
						=> .system_element_203: .system_element_4632
						(*
							<=> nrel_semantic_equivalence: "file://images/delete_elements_command_example.png";;
							<- .system_element_4594;;
							=> .system_element_3489: .system_element_4633;;
							=> .system_element_4578: [<p>Удалить sc-элементы с хэшами 885 и 1025.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);
						=> .system_element_4629: .system_element_4596;
						=> nrel_note: [<p>Содержимое сообщения <i>команды удаления sc-элементов</i> может быть пустым.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4596
						=> nrel_idtf: [<p>delete elements command answer</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4572;
						=> .system_element_203: .system_element_4633
						(*
							<=> nrel_semantic_equivalence: "file://images/delete_elements_command_answer_example.png";;
							<- .system_element_4596;;
							=> .system_element_4578: [<p>sc-элементы были удалены из sc-памяти успешно.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);
						=> nrel_note: [<p>Если sc-элемент с указанным хэшем не существует, ответ на команду будет безуспешным.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4598
						=> nrel_idtf: [<p>handle keynodes command</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4571;
						=> .system_element_203: .system_element_4634
						(*
							<=> nrel_semantic_equivalence: "file://images/handle_keynodes_command_example.png";;
							<- .system_element_4598;;
							=> .system_element_3489: .system_element_4635;;
							=> .system_element_4578: [<p>(1) Найти sc-элемент по системному идентификатору "any_system_identifier"; (2) Разрешить sc-элемент с типом 1 (неуточняемого типа) по системному идентификатору "any_system_identifier".</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);
						=> .system_element_4629: .system_element_4600;
						=> nrel_note: [<p>Данный класс команд позволяет быстро обращаться к sc-элементам по их системным идентификаторам, поскольку ключевые sc-элементы кэшируются на уровне интерфейса.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4600
						=> nrel_idtf: [<p>handle keynodes command answer</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4572;
						=> .system_element_203: .system_element_4635
						(*
							<=> nrel_semantic_equivalence: "file://images/handle_keynodes_command_answer_example.png";;
							<- .system_element_4600;;
							=> .system_element_4578: [<p>Ключевый sc-элемент с системным идентификатором "any_system_identifier" не был найден, поэтому был создан. хэш нового ключевого sc-элемента --- 128. Команда выполнена успешно.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);;

						.system_element_4602
						=> nrel_idtf: [<p>handle link contents command</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4571;
						=> .system_element_203: .system_element_4636
						(*
							<=> nrel_semantic_equivalence: "file://images/handle_link_contents_command_example.png";;
							<- .system_element_4602;;
							=> .system_element_3489: .system_element_4637;;
							=> .system_element_4578: [<p>(1) Установить содержимое 67 типа "int" в файл ostis-системы с хэшем 3123; (2) Получить содержимое файла ostis-системы с хэшем 232; (3) Найти файлы ostis-системы с содержимым "exist".</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);
						=> .system_element_4629: .system_element_4604;
						=> nrel_note: [<p>Стоит отметить, что в случае, если файл ostis-системы уже имеет содержимое, то при установке нового содержимого старое содержимое будет удалено из памяти. Содержимое файла ostis-системы может быть установлено как пустое.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4604
						=> nrel_idtf: [<p>handle link contents command answer</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4572;
						=> .system_element_203: .system_element_4637
						(*
							<=> nrel_semantic_equivalence: "file://images/handle_link_contents_command_answer_example.png";;
							<- .system_element_4604;;
							=> .system_element_4578: [<p>(1) Содержимое 67 типа "int" было установлено успешно в файл ostis-системы с хэшем 3123; (2) Содержимое файла ostis-системы с хэшем 232 --- число 67 целочисленного типа; (3) Файлы ostis-системы с содержимым "exist": 324 и 423.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);;

						.system_element_4607
						=> nrel_idtf: [<p>search template command</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4571;
						=> .system_element_203: .system_element_4638
						(*
							<=> nrel_semantic_equivalence: "file://images/search_template_command_example.png";;
							<- .system_element_4607;;
							=> .system_element_3489: .system_element_4639;;
							=> .system_element_4578: [<p>Найти все такие тройки, в которых первым элементом является sc-элемент c хэшем 23123, третьим sc-элементом является файл ostis-системы неуточняемого константного типа c псевдонимом "_trg", а вторым элементом --- sc-дуга типа sc_edge_d_common c псевдонимом "_edge1", исходящая от sc-элемента c хэшем 23123 и входящая в файл ostis-системы с псевдонимом "_trg", и найти все такие тройки, в которых первым элементом является sc-элемент c хэшем 231342, третьим элементов является sc-дуга под псевдонимом "_edge1", а вторым элементом --- sc-дуга типа sc_edge_access_const_pos_perm, исходящая от sc-элемента c хэшем 231342 и входящая в sc-дугу "_edge1". На место переменной с псевдонимом "_trg" подставить sc-элемент с хэшем 564.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);
						=> .system_element_4629: .system_element_4609;
						=> nrel_note: [<p>Поиск sс-конструкций по сформированному sc-шаблону осуществляется специализированным модулем, являющимся частью sc-памяти.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4609
						=> nrel_idtf: [<p>search template command answer</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4572;
						=> .system_element_203: .system_element_4639
						(*
							<=> nrel_semantic_equivalence: "file://images/search_template_command_answer_example.png";;
							<- .system_element_4609;;
							=> .system_element_4578: [<p>Найдена одна sc-конструкция, состоящая из двух троек. хэши sc-элементов в тройках: 23123, 4953, 564 и 231342, 533, 4953 соответственно их расположению в тройках. Команда выполнена успешно.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);
						=> nrel_note: [<p>Важно отметить, что sc-шаблон поиска sc-конструкций не может быть пустым.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4612
						=> nrel_idtf: [<p>generate template command</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4571;
						=> .system_element_203: .system_element_4640
						(*
							<=> nrel_semantic_equivalence: "file://images/generate_template_command_example.png";;
							<- .system_element_4612;;
							=> .system_element_3489: .system_element_4641;;
							=> .system_element_4578: [<p>Создать такую тройку, в которой первым элементом является sc-элемент c хэшем 589, третьим sc-элементом является sc-узел неуточняемого типа c псевдонимом "_trg", а вторым элементом --- sc-дуга типа sc_edge_d_common c псевдонимом "_edge1", исходящая от sc-элемента c хэшем 589 и входящая в sc-узел с псевдонимом "_trg". На место переменной с псевдонимом "_trg" подставить sc-элемент с хэшем 332.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);
						=> .system_element_4629: .system_element_4614;
						=> nrel_note: [<p>Создание sс-конструкции по сформированному sc-шаблону осуществляется специализированным модулем, являющимся частью sc-памяти.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4614
						=> nrel_idtf: [<p>search template command answer</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4572;
						=> .system_element_203: .system_element_4641
						(*
							<=> nrel_semantic_equivalence: "file://images/generate_template_command_answer_example.png";;
							<- .system_element_4614;;
							=> .system_element_4578: [<p>Создана одна sc-конструкция, состоящая из одной тройки. хэши sc-элементов в тройке: 128, 589, 332 соответственно их расположению в тройках. Команда выполнена успешно.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);
						=> nrel_note: [<p>Важно отметить, что sc-шаблон создания sc-конструкции не может быть пустым.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4618
						=> nrel_idtf: [<p>handle events command</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4571;
						=> .system_element_203: .system_element_4642
						(*
							<=> nrel_semantic_equivalence: "file://images/handle_events_command_example.png";;
							<- .system_element_4618;;
							=> .system_element_3489: .system_element_4643;;
							=> .system_element_4578: [<p>(1) Зарегистрировать sc-событие типа "add_outgoing_edge" по sc-элементу с хэшем 324; (2) Разрегистрировать sc-события с позициями sc-элементов 2, 4 и 5 соответственно.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);
						=> .system_element_4629: .system_element_4620;
						=> .system_element_4629: .system_element_4622;
						=> nrel_note: [<p><i>Ответ инициализации sc-события</i> может производиться несколько раз за разные промежутки времени.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;

						.system_element_4620
						=> nrel_idtf: [<p>handle events command answer</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4572;
						=> nrel_inclusion: .system_element_4544;
						=> .system_element_203: .system_element_4643
						(*
							<=> nrel_semantic_equivalence: "file://images/handle_events_command_answer_example.png";;
							<- .system_element_4620;;
							=> .system_element_4578: [<p>(1) sc-событие типа "add_outgoing_edge" по sc-элементу с хэшем 324 было зарегистрировано успешно на 7-ой позиции очереди sc-событий; (2) sc-события под позициями 2, 4, 5 удалены успешно.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);;

						.system_element_4622
						=> nrel_idtf: [<p>init event command answer</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						<= nrel_inclusion: .system_element_4572;
						=> .system_element_203: .system_element_4644
						(*
							<=> nrel_semantic_equivalence: "file://images/init_event_command_answer_example.png";;
							<- .system_element_4622;;
							=> .system_element_4578: [<p>sc-событие было инициализировано успешно: добавлена выходящая sc-дуга с хэшем 328 из зарегистрированного sc-элемента с хэшем 324 в sc-элемент c хэшем 35. Статус sc-события --- 1.</p>]
							(*
								<- lang_ru;;
								=> nrel_format: format_html;;
							*);;
						*);;
					*];;
				*];;

				.system_element_4545
				=> .system_element_2880: [<p><i>Реализация интерпретатора команд SC-JSON-кода</i>, представляет собой интерпретатор команд и ответов на них <i>SC-JSON-кода</i> на программное представление sc-конструкций в sc-памяти при помощи Библиотеки программных компонентов для обработки и, задающее синтаксис json-текстов JSON for Modern C++ и Библиотека кросс-платформенных программных компонентов для реализации серверных приложений на основе Websocket WebSocket++, а также обеспечивается комплексным тестовым покрытием посредством программных фреймворков Google Tests и Google Benchmark Tests. Библиотека программных компонентов для обработки и, задающее синтаксис json-текстов JSON for Modern C++ имеет богатый, удобный и быстродействующий функционал, необходимый для реализации подобных компонентов ostis-систем, а Библиотеки кросс-платформенных программных компонентов для реализации серверных приложений на основе Websocket WebSocket++ позволяет элегантно проектировать серверные системы без использовании избыточных зависимостей и решение. Настройка программного компонента осуществляется с помощью <i>Программного компонента настройки программных компонентов ostis-систем</i> и скриптов языков CMake и Bash.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> nrel_explanation: [<p>Стоит отметить, что текущая <i>Реализация интерпретатора команд SC-JSON-кода</i> не является первой в своём роде и заменяет предыдущую её реализацию, написанную на языке Python. Причиной такой замены состоит в следующем:
				<ul>
					<li> предыдущая <i>Реализация интерпретатора команд SC-JSON-кода</i>, реализованная на языке программирования Python, зависит от библиотеки Boost Python, предоставляемой сообществом по развитию и коллаборации языков С++ и Python. Дело в том, что такое решение требует поддержки механизма интерпретации программного кода на языке Python на язык С++, что является избыточным и необоснованным, поскольку большая часть программного кода <i><b>Программного варианта реализации ostis-платформы</b></i> реализована на языках С и С++. Новая реализация описываемой программной системы позволяет избавиться от использования ёмких и ресурсозатратных библиотек (например, boost-python-lib, llvm) и языка Python;
					<li> при реализации распределённых подсистем важную роль играет скорость обработки знаний, то есть возможность быстро и срочно отвечать на запросы пользователя. Качество доступа к sc-памяти посредством реализованного <i>сетевого интерфейса</i> должно быть соизмеримо с качеством доступа к sc-памяти при помощи специализированного <i>программного интерфейса</i>, реализованного на том же языке программирования, что и сама система. Новая реализация позволяет повысить скорость обработки запросов <i>Сетевого интерфейса Реализации sc-памяти</i>, в том числе и обработка знаний, не менее чем в 1,5 раза по сравнению с предыдущим вариантом реализации этой подсистемы.</li>
				<ul></p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*];;
		*];;

		.system_element_4645
		=> nrel_inclusion: [*
			=> nrel_idtf: [<p>Документация Реализации scp-интерпретатора в Программной платформе ostis-систем</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			-> rrel_key_sc_element: .system_element_4314;
			=> nrel_authors: 
				.system_element_1105;
				.system_element_4293
			;;

			.system_element_4314
			<= .system_element_4325: .system_element_4646
			(*
				=> nrel_note: [<p>Важнейшей особенностью <i>Языка SCP</i> является тот факт, что его программы записываются таким же образом, что и обрабатываемые ими знания, то есть в SC-коде. Это, с одной стороны, дает возможность сделать ostis-системы платформенно-независимыми (четко разделить <i>sc-модель компьютерной системы</i> и платформу интерпретации таких моделей), а с другой стороны требует наличия в рамках платформы <i>Реализации scp-интерпретатора</i>, то есть интерпретатора программ <i>Языка SCP</i>.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;
			*);
			<- .system_element_294;
			<- .system_element_287;
			<- .system_element_290;
			=> .system_element_130: {
				.system_element_4320;
				.system_element_4321;
				.system_element_4313
			};
			=> .system_element_246: [<p>https://github.com/ostis-ai/scp-machine</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);
			=> .system_element_4322: 
				.system_element_217
			;
			=> nrel_authors: 
				.system_element_1105;
				.system_element_4293
			;
			=> .system_element_4312: {
				.system_element_4647;
				.system_element_4648
				(*
					=> .system_element_4312: {
						.system_element_4649;
						.system_element_4650;
						.system_element_4651;
						.system_element_4652;
						.system_element_4653;
						.system_element_4654;
						.system_element_4655;
						.system_element_4656;
						.system_element_4657
					};;
				*);
				.system_element_4658;
				.system_element_4659;
				.system_element_4660;
				.system_element_4661
			};
			=> nrel_note: [<p>Текущая <i>Реализация scp-интерпретатора</i> не включает в себя специализированных средств для работы с блокировками, поскольку механизм блокировок элементов sc-памяти реализован на более низком уровне в рамках <i>Реализации sc-памяти</i></p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;

			.system_element_4662
			=> nrel_inclusion: [*
				=> nrel_idtf: [<p>Документация Реализации интерпретатора sc-моделей пользовательских интерфейсов в Программной платформе ostis-систем</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				-> rrel_key_sc_element: .system_element_4661;
				=> nrel_authors: 
					.system_element_4293
				;
				=> nrel_explanation: [<p>В большинстве случаев разработка <i>пользовательского интерфейса</i> в современных системах отнимает большую часть времени, затрачиваемого на разработку всей системы. Однако эффективность использования <i>программной компьютерной системы</i> зависит от разрабатываемого <i>пользовательского интерфейса</i> (см. Myers1992, <i></i>).Наряду с <i>Реализацией sc-памяти</i> важной частью <i>Программного варианта реализации ostis-платформы</i> является <b><i>Реализация интерпретатора sc-моделей пользовательских интерфейсов</i></b>, которая предоставляет базовые средства просмотра и редактирования базы знаний пользователем, средства для навигации по <i>базе знаний</i> (задания <i>вопросов</i> к <i>базе знаний</i>) и может дополняться новыми компонентами в зависимости от задач, решаемых каждой конкретной <i>ostis-системой</i>.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);;

				.system_element_4661
				=> nrel_idtf: [<p>sc-web</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> nrel_explanation: [<p>Наряду с <i>Реализацией sc-памяти</i> важной частью <i>Программного варианта реализации ostis-платформы ostis-систем</i> является <i>Реализация интерпретатора sc-моделей пользовательских интерфейсов ostis-систем</i>, которая предоставляет базовые средства просмотра и редактирования базы знаний пользователем, средства для навигации по базе знаний (задания вопросов к базе знаний) и может дополняться новыми компонентами в зависимости от задач, решаемых каждой конкретной ostis-системой.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> nrel_idtf: [<p>Предлагаемый нами интерпретатор для интерпретации sc-моделей пользовательских интерфейсов ostis-систем</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				<- .system_element_294;
				<- .system_element_287;
				<- .system_element_290;
				=> .system_element_246: [<p>https://github.com/ostis-ai/sc-web</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> .system_element_130: {
					.system_element_4663;
					.system_element_4664;
					.system_element_4665;
					.system_element_4666
				};
				=> .system_element_4423: 
					.system_element_4667;
					.system_element_4668;
					.system_element_211;
					.system_element_1239;
					.system_element_4669
				;
				=> nrel_authors: 
					.system_element_4311;
					.system_element_4293
				;
				=> nrel_explanation: [<p>Важным принципом <i>Реализации интерпретатора sc-моделей пользовательских интерфейсов</i> является простота и однотипность подключения любых компонентов <i>пользовательского интерфейса</i> (<i>редакторов</i>, <i>визуализаторов</i>, <i>переключателей</i>, <i>команд меню</i> и так далее). Для этого реализуется программная прослойка Sandbox, в рамках которой реализуются низкоуровневые операции взаимодействия с серверной частью и которая обеспечивает более удобный <i>программный интерфейс</i> для разработчиков компонентов. Текущий вариант <i>Реализации интерпретатора sc-моделей пользовательских интерфейсов</i> является открытым и доступен на Ostis-sc-web2023.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> .system_element_4670: 
					[<p>Отсутствие единого унифицированного механизма клиент-серверного взаимодействия. Часть компонентов (визуализатор sc-текстов в SCn-коде, команды меню и др.) работают по протоколу HTTP, часть по протоколу SCTP с использованием технологии WebSocket, это приводит к значительным трудностям при развитии платформы.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Протокол HTTP предполагает четкое разделение активного клиента и пассивного сервера, который отвечает на запросы клиентов. Таким образом, сервер (в данном случае --- sc-память) практически не имеет возможности по своей инициативе отправить сообщение клиенту, что повышает безопасность системы, но значительно снижает ее интерактивность. Кроме того, такой вариант реализации затрудняет реализацию принятого в Технологии OSTIS многоагентного подхода, в частности, затрудняет реализацию sc-агентов на стороне клиента. Указанные проблемы могут быть решены путем постоянного мониторинга определенных событий со стороны клиента, однако такой вариант неэффективен.Кроме того, часть интерфейса фактически работает напрямую с sc-памятью с использованием технологии WebSocket, а часть --- через прослойку на базе библиотеки tornado для языка программирования Python, что приводит к дополнительным зависимостям от сторонних библиотек.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Часть компонентов (например, поле поиска по идентификатору) реализована сторонними средствами и практически никак не связана с sc-памятью. Это затрудняет развитие платформы.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Текущая <i>Реализация интерпретатора sc-моделей пользовательских интерфейсов</i> ориентирована только на ведение диалога с пользователем (в стиле вопрос пользователя --- ответ системы). Не поддерживаются такие очевидно необходимые ситуации, как выполнение команды, не предполагающей ответа;возникновение ошибки или отсутствие ответа;необходимость задания вопроса системой пользователю и т.д.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Ограничена возможность взаимодействия пользователя с системой без использования специальных элементов управления. Например, можно задать вопрос системе, нарисовав его в SCg-коде, но ответ пользователь не увидит, хотя в памяти он будет сформирован соответствующим агентом.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Идея платформенной независимости пользовательского интерфейса (построения sc-модели пользовательского интерфейса) реализована не в полной мере. Полностью описать sc-модель пользовательского интерфейса (включая точное размещение, размеры, дизайн компонентов, их поведение и др.) в настоящее время скорее всего окажется затруднительно из-за ограничений производительности, однако вполне возможно реализовать возможность задания вопросов ко всем компонентам интерфейса, изменить их расположение и т.д., однако эти возможности нельзя реализовать в текущей версии реализации платформы.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Интерфейсная часть работает медленно из-за некоторых недостатков реализации серверной части на языке Python.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Не реализован механизм наследования при добавлении новых внешних языков. Например, добавление нового языка даже очень близкого к SCg-коду требует физического копирования кода компонента и внесение соответствующих изменений, при этом получаются два никак не связанных между собой компонента, которые начинают развиваться независимо друг от друга.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Слабый уровень задокументированности текущей <i>Реализации интерпретатора sc-моделей пользовательских интерфейсов ostis-систем</i>.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*)
				;
				=> .system_element_4671: 
					[<p>Унифицировать принципы взаимодействия всех компонентов интерфейса с <i>Программной моделью sc-памяти</i>, независимо от того, к какому типу относится компонент. Например, список команд меню должен формироваться через тот же механизм, что и ответ на запрос пользователя, и команда редактирования, сформированная пользователем, и команда добавления нового фрагмента в базу знаний и т.д.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Унифицировать принципы взаимодействия пользователей с системой независимо от способа взаимодействия и внешнего языка. Например, должна быть возможность задания вопросов и выполнения других команд прямо через SCg/SCn интерфейс. При этом необходимо учитывать принципы редактирования базы знаний, чтобы пользователя не мог под видом задания вопроса внести новую информацию в согласованную часть базы знаний.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Унифицировать принципы обработки событий, происходящих при взаимодействии пользователя с компонентами интерфейса --- поведение кнопок и других интерактивных компонентов должно задаваться не статически сторонними средствами, а реализовываться в виде агента, который, тем не менее, может быть реализован произвольным образом (не обязательно на платформенно-независимом уровне). Любое действие, совершаемое пользователем, на логическом уровне должно трактоваться и обрабатываться как инициирование агента.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Обеспечить возможность выполнять команды (в частности, задавать вопросы) с произвольным количеством аргументов, в том числе --- без аргументов.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Обеспечить возможность отображения ответа на вопрос по частям, если ответ очень большой и для отображения требуется много времени.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Каждый отображаемый компонент интерфейса должен трактоваться как изображение некоторого sc-узла, описанного в базе знаний. Таким образом, пользователь должен иметь возможность задания произвольных вопросов к любым компонентам интерфейса.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Максимально упростить и задокументировать механизм добавления новых компонентов.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Обеспечить возможность добавления новых компонентов на основе имеющихся без создания независимых копий. Например, должна быть возможность создать компонент для языка, расширяющего язык SCg новыми примитивами, переопределять принципы размещения sc-текстов и т.д.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Свести к минимуму зависимость от сторонних библиотек.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*);
					[<p>Свести к минимуму использование протокола HTTP (начальная загрузка общей структуры интерфейса), обеспечить возможность равноправного двустороннего взаимодействия серверной и клиентской части.</p>]
					(*
						<- lang_ru;;
						=> nrel_format: format_html;;
					*)
				;
				=> nrel_note: [<p>Очевидно, что реализация большинства из приведенных требований связана не только с собственно вариантом реализации платформы, но и требует развития теории логико-семантических моделей пользовательских интерфейсов и уточнения в рамках нее общих принципов организации пользовательских интерфейсов ostis-систем. Однако, принципиальная возможность реализации таких моделей должна быть учтена в рамках реализации платформы.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				=> .system_element_4672: 
					.system_element_4673
					(*
						=> nrel_explanation: [<p><i>Панель меню команд пользовательского интерфейса</i> содержит изображения классов команд (как атомарных, так и неатомарных), имеющихся на данный момент в базе знаний и входящих в декомпозицию <i>Главного меню пользовательского интерфейса</i> (имеется в виду полная декомпозиция, которая в общем случае может включать несколько уровней неатомарных классов команд).Взаимодействие с изображением неатомарного класса команд инициирует команду изображения классов команд, входящих в декомпозицию данного неатомарного класса команд.Взаимодействие с изображением атомарного класса команд инициирует генерацию команды данного класса с ранее выбранными аргументами на основе соответствующей <i>обобщенной формулировки класса команд</i> (шаблона класса команд).</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;
					*);
					.system_element_4674
					(*
						=> nrel_explanation: [<p><i>Компонент переключения языка идентификации отображаемых sc-элементов</i> является изображением множества имеющихся в системе естественных языков. Взаимодействие пользователя с данным компонентом переключает пользовательский интерфейс в режим общения с конкретным пользователем с использованием <i>основных sc-идентификаторов</i>, принадлежащих данному <i>естественному языку</i>. Это значит, что при изображении sc-идентификаторов sc-элементов на каком-либо языке, например, SCg-коде или SCn-коде будут использоваться <i>основные sc-идентификаторы</i>, принадлежащие данному <i>естественному языку</i>. Это касается как sc-элементов, отображаемых в рамках <i>Панели визуализации и редактирования знаний</i>, так и любых других sc-элементов, например, классов команд и даже самих <i>естественных языков</i>, изображаемых в рамках самого <i>Компонента переключения языка идентификации отображаемых sc-элементов</i>.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;
					*);
					.system_element_4675
					(*
						=> nrel_explanation: [<p><i>Компонент переключения внешнего языка визуализации знаний</i> служит для переключения языка визуализации знаний в текущем окне, отображаемом на <i>Панели визуализации и редактирования знаний</i>. В текущей реализации в качестве таких языков по умолчанию поддерживаются SCg-код и SCn-код, а также любые другие языки, входящие во множество <i>внешних языков визуализации SC-кода</i>.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;
					*);
					.system_element_4676
					(*
						=> nrel_explanation: [<p><i>Поле поиска sc-элементов по идентификатору</i> позволяет осуществлять поиск <b>sc-идентификаторов</b>, содержащих подстроку, введенную в данное поле (с учетом регистра). В результате поиска отображается список sc-идентификаторов, содержащих указанную подстроку, при взаимодействии с которыми осуществляется автоматическое задание вопроса"Что это такое?", аргументом которого является либо для сам sc-элемент, имеющий данный sc-идентификатор (в случае, если указанный sc-идентификатор является основным или системным, и, таким образом, указанный sc-элемент может быть определен однозначно), либо для самого внутреннего файла ostis-системы, являющегося sc-идентификатором (в случае, если данный sc-идентификатор является неосновным).</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;
					*);
					.system_element_4677
					(*
						=> nrel_explanation: [<p><i>Панель отображения диалога пользователя с ostis-системой</i> отображает упорядоченный по времени список sc-элементов, являющихся знаками действий, которые инициировал пользователь в рамках диалога с ostis-системой путем взаимодействия с изображениями соответствующих классов команд (то есть, если действие было инициировано другим способом, например, путем его явного инициирования через создание дуги принадлежности множеству <i>инициированных действий</i> в sc.g-редакторе, то на данной панели оно отображено не будет). При взаимодействии пользователя с любым из изображенных знаков действий на <i>Панели визуализации и редактирования знаний</i> отображается окно, содержащее результат выполнения данного <i>действия</i> на том языке визуализации, на котором он был отображен, когда пользователь просматривал его в последний (предыдущий) раз. Таким образом, в текущей реализации данная панель может работать только в том случае, если инициированное пользователем действие предполагает явно представленный в памяти результат данного действия. В свою очередь, из этого следует, что в настоящее время данная панель, как и в целом <i>Реализация интерпретатора sc-моделей пользовательских интерфейсов ostis-систем</i>, позволяет работать с системой только в режиме диалога "вопрос-ответ".</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;
					*);
					.system_element_4678
					(*
						=> nrel_explanation: [<p><i>Панель визуализации и редактирования знаний</i> отображает окна, содержащие sc-текст, представленный на некотором языке из множества <i>внешних языков визуализации SC-кода</i> и, как правило, являющийся результатом некоторого действия, инициированного пользователем. Если соответствующий визуализатор поддерживает возможность редактирования текстов соответствующего естественного языка, то он одновременно является также и редактором.</p>];;
						=> .system_element_4679: 
							.system_element_4680;
							.system_element_4681
						;;
						=> nrel_note: [<p>При необходимости пользовательский интерфейс каждой конкретной ostis-системы может быть дополнен визуализаторами и редакторами различных внешних языков, которые в текущей версии <i>Реализации интерпретатора sc-моделей пользовательских интерфейсов ostis-систем</i> будут также располагаться на <i>Панели визуализации и редактирования знаний</i>.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);;
					*)
				;;
			*];;
		*];;

		.system_element_4315
		=> .system_element_4679: .system_element_4682
		(*
			=> nrel_idtf: [<p>sc-builder</p>];;
			=> .system_element_405: scs_code;;
			<- .system_element_294;;
			<- .system_element_287;;
			<- .system_element_290;;
			=> .system_element_130: {
				.system_element_4320;
				.system_element_4321;
				.system_element_4313
			};;
			=> nrel_authors: 
				.system_element_4311;
				.system_element_4293
			;;
			=> nrel_explanation: [<p>Сборщик базы знаний из исходных текстов позволяет осуществить сборку базы знаний из набора исходных текстов, записанных в SCs-коде с ограничениями (см. <i>Раздел **про исходные тексты**</i>) в бинарный формат, воспринимаемый <i>Программной моделью sc-памяти</i>. При этом возможна как сборка "с нуля" (с уничтожением ранее созданного слепка памяти), так и аддитивная сборка, когда информация, содержащаяся в заданном множестве файлов, добавляется к уже имеющемуся слепку состояния памяти.В текущей реализации сборщик осуществляет "склеивание" ("слияние") sc-элементов, имеющих на уровне исходных текстов одинаковые <i>системные sc-идентификаторы</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);;
	*];;
*];;
