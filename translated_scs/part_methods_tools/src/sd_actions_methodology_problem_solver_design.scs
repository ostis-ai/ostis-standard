.system_element_2671
=> nrel_summary: [<p><i>Предметная область и онтология действий и методик проектирования решателей задач ostis-систем</i> посвящена методике построения и модификации <i>решателей задач</i> <i>ostis-систем</i>.</p>]
(*
	<- lang_ru;;
	=> nrel_format: format_html;;
*);
=> nrel_introduction: <
	[<p>В области разработки <i>решателей задач</i> существует большое количество конкретных реализаций, однако вопросы совместимости различных решателей задачи и их компонентов практически не рассматриваются. Гипотетически возможно существование универсального решателя задач, объединяющего в себе все известные способы и методы решения задач. Однако использование такого решателя в прикладных целях не является целесообразным. Таким образом, наиболее приемлемым вариантом становится создание библиотеки совместимых между собой компонентов, из которых впоследствии может быть собран решатель, удовлетворяющий необходимым требованиям.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> .system_element_180: .system_element_2526;;
	*);
	[<p><em>решатель задач ostis-системы</em> представляет собой иерархическую систему <i>навыков</i>, которыми владеет ostis-система на текущий момент. В свою очередь, <i>навык</i> представляет собой некоторый <i>метод</i> решения задач заданного класса и соответствующую ему систему <i>sc-агентов</i> (<i>машину обработки знаний</i> частного вида), обеспечивающих интерпретацию данного метода. В связи с этим методика проектирования решателей задач ostis-систем фактически сводится к методике проектирования баз знаний ostis-систем и методике проектирования машин обработки знаний ostis-систем, которая детально рассматривается в данной главе.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> .system_element_180: .system_element_2672;;
	*);
	[<p>Вопросам разработки <i>решателей задач ostis-систем</i> посвящен ряд работ, таких как Shunkevich2013, Shunkevich2015, Shunkevich2015a, Golenkov2015, Shunkevich2018. Среди других известных работ, посвященных вопросам компонентного проектирования решателей задач в целом, стоит отметить работы Borisov2014, Gribova2015a, в которых, однако, не уделяется внимание разработке комплексной методики проектирования решателей задач, которой посвящена данная глава.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*)
>;
=> nrel_conclusion: [<p>В данной предметной области предложена <i>Методика построения и модификации машины обработки знаний ostis-систем</i>, которая включает несколько этапов:
<ul>
	<li> формирование требований и спецификация <i>машины обработки знаний</i>;
	<li> формирование коллектива sc-агентов, входящих в состав разрабатываемой машины;
	<li> разработка алгоритмов атомарных sc-агентов;
	<li> реализация scp-программ;
	<li> верификация разработанных компонентов;
	<li> отладка разработанных компонентов, исправление ошибок.</li>
<ul><i>Методика построения и модификации машины обработки знаний ostis-систем</i> основана на онтологии деятельности разработчиков <i>машины обработки знаний</i>. Наличие такой онтологии позволяет:
<ul>
	<li> частично автоматизировать процесс построения и модификации <i>машины обработки знаний</i>;
	<li> повысить эффективность информационной поддержки разработчиков, поскольку данная онтология может быть включена в <i>Базу знаний Метасистемы OSTIS</i>.</li>
<ul>Также предложена модель <i>Системы автоматизации проектирования решателей задач ostis-систем</i>. Cистема может использоваться тремя способами:
<ul>
	<li> Как подсистема в рамках <i>Метасистемы OSTIS</i>. Данный вариант использования предполагает отладку необходимых компонентов в рамках метасистемы с последующим переносом их в <i>дочернюю ostis-систему</i>.
	<li> Как <i>самостоятельная ostis-система</i>, предназначенная исключительно для разработки и отладки компонентов решателей задач. В этом случае проектируемые компоненты отлаживаются в рамках такой системы, а затем должны быть перенесены в дочернюю ostis-систему.
	<li> Как подсистема в рамках дочерней ostis-системы. В таком варианте отладка компонентов осуществляется непосредственно в той же системе, в которой предполагается их использование, и дополнительного переноса не требуется.</li>
<ul></p>]
(*
	<- lang_ru;;
	=> nrel_format: format_html;;
*);
=> .system_element_1: 
	.system_element_1643;
	sc_agent;
	new_scp_program;
	breakpoint;
	incorrectness_in_scp_program;
	error_in_scp_program;
	.system_element_2572
;
=> .system_element_14: 
	.system_element_2673;
	.system_element_2674;
	.system_element_2675;
	.system_element_2676;
	.system_element_2451;
	.system_element_2677;
	.system_element_2678;
	.system_element_2679
;
=> nrel_inclusion: [*
	=> .system_element_756: 
		.system_element_2680
	;
	=> nrel_note: [<p>Основу любого решателя задач составляет система sc-агентов, то есть <i>машина обработки знаний ostis-системы</i>, в связи с этим целесообразно рассмотреть более детально процесс проектирования <i>машин обработки знаний ostis-систем</i>. Приведенная методика разработана с учетом того, что каждая <i>машина обработки знаний ostis-систем</i> представляет собой иерархический коллектив sc-агентов.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_note: [<p>Построение общей методики проектирования решателей задач ostis-систем требует также уточнения принципов разработки <i>методов</i> решения задач, которые, в свою очередь, тесно пересекаются с общими принципами разработки баз знаний ostis-систем.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> .system_element_180: .system_element_2672;;
	*);;

	.system_element_2681
	=> .system_element_282: {
		.system_element_2682
		(*
			=> .system_element_282: <
				[<p><i>Выделение задач</i>, решение которых должен обеспечивать <i>решатель задач</i>.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				[<p><i>Продумывание предполагаемых способов решения таких задач</i> и на основе данного анализа определение места будущей машины обработки знаний <i>решателя задач</i> в общей иерархии <i>решателей задач</i>.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*)
			>;;
			=> nrel_note: [<p>Важность данного этапа заключается в том, что при правильной классификации существует вероятность того, что в составе <i>библиотеки многократно используемых компонентов решателей задач ostis-систем</i> уже есть реализованный вариант требуемой машины обработки знаний. В противном случае, у разработчика появляется возможность включить разработанную машину в <i>библиотеку многократно используемых компонентов решателей задач ostis-систем</i> для последующего использования. Данные факты обусловлены тем, что структура <i>библиотеки многократно используемых компонентов решателей задач ostis-систем</i> основана на семантической классификации <i>решателей задач</i> и, соответственно, их компонентов.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
			=> nrel_note: [<p>При недостаточно четкой спецификации и классификации разрабатываемого <i>решателя задач</i> повышается вероятность того, что подходящая машина обработки знаний не будет найдена в библиотеке компонентов даже в случае, если она там есть, а вновь разработанный <i>решатель задач</i> не сможет быть включен в библиотеку. Таким образом, принцип многократного использования уже разработанных компонентов будет нарушен, что существенно повысит затраты на разработку.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);
		.system_element_2683
		(*
			=> nrel_note: [<p>В случае, когда найти в библиотеке готовую машину обработки знаний, удовлетворяющую всем предъявляемым требованиям, не удалось, необходимо выделить (то есть собственно определить множество требуемых компонентов) и специфицировать все ее компоненты.</p>];;
			=> nrel_result: [<p>Результатом данного этапа является перечень полностью специфицированных <i>абстрактных sc-агентов</i>, которые войдут в состав разрабатываемой машины обработки знаний, с их иерархией вплоть до <i>атомарных абстрактных sc-агентов</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
			=> nrel_note: [<p>В рамках данного этапа очень важно проектировать коллектив агентов таким образом, чтобы максимально задействовать уже имеющиеся в библиотеке многократно используемые компоненты ostis-систем, а при отсутствии нужного компонента --- иметь возможность включить его в библиотеку после реализации.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
			=> .system_element_2684: {
				[<p>Каждый разрабатываемый sc-агент должен быть, по возможности, предметно независим, то есть во множество ключевых узлов данного sc-агента не должны входить понятия, имеющие отношение непосредственно к рассматриваемой предметной области. Исключение составляют понятия из общих предметных областей, которые носят междисциплинарный характер (например, отношение <i>включение*</i> или понятие <i>действие</i>). Данное правило также может быть нарушено в случае, если sc-агент является вспомогательным и ориентирован на обработку какого-либо конкретного класса объектов (например, sc-агенты, выполняющие арифметические вычисления, могут напрямую работать с конкретными отношениями <i>сложение*</i> и <i>умножение*</i> и тому подобное). Всю необходимую для решения задачи информацию sc-агент должен извлекать из семантической окрестности соответствующего инициированного действия. Разработанный с учетом указанных требований sc-агент может быть использован при проектировании большего числа ostis-систем, чем в случае, если бы он был реализован с ориентацией на конкретную предметную область. После завершения разработки и отладки такой sc-агент должен быть включен в <i>библиотеку многократно используемых абстрактных sc-агентов</i>, которая входит в состав <i>библиотеки многократно используемых компонентов решателей задач ostis-систем</i>.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				[<p>Не стоит путать понятия sc-агент и <i>агентная программа</i> (в том числе <i>агентная scp-программа</i>). Взаимодействие sc-агентов осуществляется исключительно посредством спецификации информационных процессов в общей памяти, каждый sc-агент реагирует на некоторый класс событий в sc-памяти. Таким образом, каждому sc-агенту соответствует некоторое условие инициирования и одна агентная программа, которая запускается автоматически при возникновении в sc-памяти соответствующего условия инициирования. При этом в рамках данной программы могут сколько угодно раз вызываться различные подпрограммы. Однако не стоит путать инициирование sc-агента, которое осуществляется при появлении в sc-памяти соответствующей конструкции, и вызов подпрограммы другой программой, который предполагает явное указание вызываемой подпрограммы и перечня ее параметров.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				[<p>Каждый sc-агент должен самостоятельно проверять полноту соответствия своего условия инициирования текущему состоянию sc-памяти. В процессе решения какой-либо задачи может возникнуть ситуация, когда на появление одной и той же структуры среагировали несколько sc-агентов. В таком случае выполнение продолжают только те из них, условие инициирования которых полностью соответствует сложившейся ситуации. Остальные sc-агенты в данном случае прекращают выполнение и возвращаются в режим ожидания. Выполнение данного принципа достигается за счет тщательного уточнения спецификаций разрабатываемых sc-агентов. В общем случае условия инициирования у нескольких sc-агентов могут совпадать, например, в случае, когда одна и та же задача может быть решена разными способами и заранее неизвестно, какой из них приведет к желаемому результату.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				[<p>Необходимо помнить, что неатомарный sc-агент с точки зрения других sc-агентов, не входящих в его состав, должен функционировать как целостный sc-агент (выполнять логически атомарные действия), что накладывает определенные требования на спецификации атомарных sc-агентов, входящих в его состав: как минимум, необходимо, чтобы в составе неатомарного sc-агента присутствовал хотя бы один атомарный sc-агент, условие инициирования которого полностью совпадает с условием инициирования данного неатомарного sc-агента.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				.system_element_2685
				(*
					<=> .system_element_200: {
						[<p>Проектируемый sc-агент должен быть максимально независим от предметной области, что позволит в дальнейшем использовать его при разработке <i>решателей задач</i> максимально возможного числа ostis-систем. При этом универсальность предполагает не только минимизацию числа ключевых узлов sc-агента, но и выделение класса действий, выполняемых данным sc-агентом таким образом, чтобы имело смысл включить данный sc-агент в <i>библиотеку многократно используемых абстрактных sc-агентов</i> и использовать его при разработке <i>решателей задач</i> других ostis-систем. Не следует искусственно увязывать ряд действий в один sc-агент и, наоборот, расчленять одно самодостаточное действие на поддействия: это вызовет сложности восприятия принципов работы sc-агента разработчиками и не позволит использовать sc-агент в ряде систем (например, в обучающих системах, которые должны объяснять ход решения пользователю).</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						[<p>Выполняемое данным sc-агентом действие должно быть логически целостным и завершенным. Следует помнить, что все sc-агенты взаимодействуют исключительно через общую sc-память, и избегать ситуаций, в которых инициирование одного sc-агента осуществляется путем явной генерации известного условия инициирования другим <i>sc-агентом</i> (то есть, по сути, явным непосредственным вызовом одного sc-агента другим).</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*);
						[<p>Имеет смысл выделять в отдельные sc-агенты относительно крупные фрагменты реализации некоторого общего алгоритма, которые могут выполняться независимо друг от друга.</p>]
						(*
							<- lang_ru;;
							=> nrel_format: format_html;;
						*)
					};;
				*);
				[<p>При объединении sc-агентов в коллективы рекомендуется проектировать их таким образом, чтобы они могли быть использованы не только как часть рассматриваемого <i>неатомарного абстрактного sc-агента</i>. В случае, если это не представляется возможным и некоторые sc-агенты, будучи отделенными от коллектива, теряют <i>смысл</i>, необходимо указать данный факт при документировании рассматриваемых sc-агентов.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*);
				[<p>Фактическим инициатором запуска sc-агента посредством общей памяти (автором соответствующей конструкции) может быть как непосредственно пользователь системы, так и другой sc-агент, что никак не должно отражаться в работе самого sc-агента.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*)
			};;
		*);
		.system_element_2686
		(*
			=> .system_element_296: {
				[<p><i>Продумывание алгоритма</i> работы каждого разрабатываемого <i>атомарного sc-агента</i>.</p>]
				(*
					<- lang_ru;;
					=> nrel_format: format_html;;
				*)
			};;
			=> nrel_note: [<p>Разработка алгоритма подразумевает выделение в нем логически целостных фрагментов, которые могут быть реализованы как отдельные <i>scp-программы</i>, в том числе выполняемые параллельно. Таким образом, появляется необходимость говорить не только о <i>библиотеке многократно используемых абстрактных sc-агентов</i>, но и о <i>библиотеке многократно используемых программ обработки sc-текстов</i> на различных языках программирования, в том числе <i>библиотеке многократно используемых scp-программ</i>. Благодаря этому часть scp-программ, реализующих алгоритм работы некоторого sc-агента, может быть заимствована из соответствующей библиотеки.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
			=> nrel_note: [<p>Важно помнить, что если в процессе работы <i>sc-агент</i> генерирует в памяти какие-либо временные структуры, то при завершении работы он обязан удалять всю информацию, использование которой в системе более нецелесообразно (убрать за собой информационный мусор). Исключение составляют ситуации, когда подобная информация необходима нескольким <i>sc-агентам</i> для решения одной задачи, однако после решения задачи информация становится бесполезной или избыточной и требует удаления. В данном случае может возникнуть ситуация, когда ни один из <i>sc-агентов</i> не в состоянии удалить информационный мусор. В таком случае возникает необходимость говорить о включении в состав <i>решателя задач</i> специализированных <i>sc-агентов</i>, задачей которых является выявление и уничтожение информационного мусора.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);
		.system_element_2687
		(*
			=> nrel_explanation: [<p>Конечным этапом непосредственно разработки является реализация специфицированных ранее <i>scp-программ</i> или при необходимости программ, реализуемых на уровне <i>ostis-платформы</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);
		.system_element_2688
		(*
			=> nrel_note: [<p>Верификация разработанных компонентов может осуществляться как вручную, так и с использованием специфицированных средств, входящих в состав системы автоматизации проектирования <i>решателей задач</i> <i>ostis-систем</i>.</p>]
			(*
				<- lang_ru;;
				=> nrel_format: format_html;;
			*);;
		*);
		.system_element_2689
		(*
			=> .system_element_417: {
				.system_element_2690;
				.system_element_2691;
				.system_element_2692;
				.system_element_2693
			};;
		*)
	};
	=> nrel_note: [<p><i>Верификация разработанных компонентов</i> и <i>отладка разработанных компонентов и исправление ошибок</i> могут выполняться параллельно и повторяются до тех пор, пока разработанные компоненты не будут удовлетворять необходимым требованиям.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_note: [<p>Предлагаемая методика может быть применена как при разработке <i>машины обработки знаний</i> объединенных <i>решателей задач</i>, так и при разработке <i>машины обработки знаний</i> <i>решателей задач</i> частного вида, поскольку с формальной точки зрения все такие машины трактуются как <i>неатомарные абстрактные sc-агенты</i>.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	=> nrel_note: [<p><i>Методика построения и модификации машин обработки знаний ostis-систем</i> основана на онтологии деятельности разработчиков машин обработки знаний.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
		=> nrel_note: [<p>Наличие такой онтологии позволяет:
		<ul>
			<li> частично автоматизировать процесс построения и модификации машины обработки знаний при помощи соответствующей <i>Системы автоматизации проектирования решателей задач ostis-систем</i>;
			<li> повысить эффективность информационной поддержки разработчиков, поскольку данная онтология включена в базу знаний <i>Метасистемы OSTIS</i>.</li>
		<ul></p>]
		(*
			<- lang_ru;;
			=> nrel_format: format_html;;
		*);;
	*);;

	.system_element_2694
	=> nrel_explanation: [<p>Каждый <i>решатель задач ostis-системы</i> представляет собой совокупность навыков, а машина обработки знаний --- совокупность интерпретаторов навыков, составляющих некоторый <i>решатель задач ostis-системы</i>, то есть его операционную семантику. Таким образом <i>машина обработки знаний</i> представляет собой <i>абстрактный sc-агент</i>, в связи с чем разработка машины сводится к разработке такого агента.</p>]
	(*
		<- lang_ru;;
		=> nrel_format: format_html;;
	*);
	<= nrel_inclusion: .system_element_2695;
	=> nrel_subdividing: {
		action_to_develop_atomic_abstract_sc_agent
		(*
			=> nrel_inclusion: action_to_develop_platform_independent_atomic_abstract_sc_agent;;
		*);
		action_to_develop_non_atomic_abstract_sc_agent
	};
	=> .system_element_2696: 
		action_to_specify_abstract_sc_agent;
		action_to_find_abstract_sc_agent_in_the_library_by_given_specification;
		action_to_verify_sc_agent;
		action_to_debug_sc_agent
	;;

	action_to_develop_platform_independent_atomic_abstract_sc_agent
	=> .system_element_2696: 
		action_to_decompose_platform_independent_atomic_abstract_sc_agent_to_scp_program;
		action_to_develop_scp_program
	;;

	action_to_develop_non_atomic_abstract_sc_agent
	=> .system_element_2696: 
		action_to_decompose_non_atomic_abstract_sc_agent;
		.system_element_2695
	;;

	action_to_develop_scp_program
	=> .system_element_2696: 
		action_to_specify_scp_program;
		action_to_find_scp_program_in_the_library_by_given_specification;
		action_to_implement_the_specified_scp_program;
		action_to_verify_scp_program;
		action_to_debug_scp_program
	;;

	action_to_verify_sc_agent
	=> nrel_subdividing: {
		action_to_verify_atomic_sc_agent;
		action_to_verify_non_atomic_sc_agent
	};;

	action_to_debug_sc_agent
	=> nrel_subdividing: {
		action_to_debug_atomic_sc_agent;
		action_to_debug_non_atomic_sc_agent
	};;
*];;
