\begin{SCn}
    \scnsectionheader{Предметная область и онтология языка внешнего линейного представления информационных конструкций внутреннего языка ostis-систем}
    \begin{scnsubstruct}
        \scnidtf{Описание \textit{SCs-кода}}
        \begin{scnreltovector}{конкатенация сегментов}
            \scnitem{Описание Алфавита SCs-кода}
            \scnitem{Описание sc.s-разделителей и sc.s-ограничителей}
            \scnitem{Описание sc.s-предложений}
            \scnitem{Описание Ядра SCs-кода и различных направлений его расширения}
        \end{scnreltovector}
        \scnheader{SCs-код}
        \scnidtf{Semantic Code string}
        \scnidtf{Язык линейного представления знаний ostis-систем}
        \scnidtf{Множество всевозможных текстов \textit{SCs-кода}}
        \scnidtf{Тексты \textit{SCs-кода}}
        \begin{scnindent}
            \scniselement{имя собственное}
        \end{scnindent}
        \scnidtf{текст \textit{SCs-кода}}
        \begin{scnindent}
            \scniselement{имя нарицательное}
        \end{scnindent}
        \scnidtf{sc.s-текст}
        \scniselement{линейный язык}
        \scnrelfrom{алфавит}{Алфавит SCs-кода}
        \scnrelfrom{разделители}{sc.s-разделитель}
        \scnrelfrom{ограничители}{sc.s-ограничитель}
        \scnrelfrom{предложения}{sc.s-предложение}
        \scnrelfrom{неоднозначные обозначения описываемых сущностей}{неоднозначное sc.s-изображение sc-элемента}
        \scnidtftext{explanation}{Множество линейных текстов (\textit{sc.s-текстов}), каждый из которых состоит из предложений (\textit{sc.s-предложений}), разделенных друг от друга двойной \textit{точкой с запятой} (разделителем \textit{sc.s-предложений}). При этом \mbox{\textit{sc.s-предложение}} представляет собой последовательность \textit{sc-идентификаторов}, являющихся именами описываемых \textit{сущностей} и разделяемых между собой различными \textit{sc.s-разделителями} и \textit{sc.s-ограничителями}}
        
        \scnheader{неоднозначное sc.s-изображение sc-элемента}
        \scnrelboth{пара пересекающихся множеств}{sc-выражение}
        \scnidtf{условное обозначение неименуемой (неидентифицируемой) сущности}
        \scnsuperset{sc.s-коннектор}
        \begin{scnindent}
            \scnidtf{неоднозначное sc.s-изображение \textit{sc-коннектора}, являющееся также одновременно одним из видов \textit{sc.s-разделителей}}
            \scnsubset{sc.s-разделитель}
        \end{scnindent}
        \scnsuperset{неоднозначное sc.s-изображение sc-узла}
        \begin{scnindent}
            \scnsuperset{условное обозначение неименуемого множества sc-элементов}
            \begin{scnindent}
                \scntext{пояснение}{условное обозначение неименуемого множества sc-элементов в \textit{SCs-коде} представляется строкой из двух символов --- \textit{левой фигурной скобки} и \textit{правой фигурной скобки}.}
            \end{scnindent}
            \scnsuperset{условное обозначение неименуемого кортежа sc-элементов}
            \begin{scnindent}
                \scntext{пояснение}{В \textit{SCs-коде} такое обозначение представляется двух-символьной \textit{строкой}, состоящей из \textit{левой угловой скобки} и \textit{правой угловой скобки}}
            \end{scnindent}
            \scnsuperset{условное обозначение неименуемого файла-экземпляра ostis-системы}
            \begin{scnindent}
                \scntext{пояснение}{В \textit{SCs-коде} такое обозначение представляется двух-символьной \textit{строкой}, состоящей из \textit{левой квадратной скобки} и \textit{правой квадратной скобки}}
            \end{scnindent}
            \scnsuperset{условное обозначение неименуемого файла-образца ostis-системы}
            \begin{scnindent}
                \scntext{пояснение}{В \textit{SCs-коде} такое обозначение представляется \textit{строкой}, состоящей из \textit{восклицательного знака}, \textit{левой квадратной скобки}, \textit{правой квадратной скобки} и еще одного \textit{восклицательного знака}}
            \end{scnindent}
        \end{scnindent}

        \scnsegmentheader{Описание Алфавита SCs-кода}
        \begin{scnsubstruct}
            \scnheader{Алфавит SCs-кода}
            \scnidtf{Алфавит символов SCs-кода}
            \scnidtf{множество символов SCs-кода}
            \scnidtf{символ, используемый в текстах SCs-кода}
            \begin{scnreltoset}{объединение}
                \scnitem{Алфавит символов, используемых в sc.s-разделителях}
                \scnitem{Алфавит символов, используемых в sc.s-ограничителях}
                \scnitem{Алфавит символов, используемых в sc-идентификаторах}
                \begin{scnindent}
                    \begin{scnreltoset}{объединение}
                        \scnitem{Алфавит символов, используемых в простых строковых sc-идентификаторах}
                        \scnitem{Алфавит символов, используемых в sc-выражениях}
                    \end{scnreltoset}
                \end{scnindent}
                \scnitem{Алфавит символов, используемых в неоднозначных sc.s-изображениях sc-узлов}
            \end{scnreltoset}
            \begin{scnrelfromlist}{принципы}
                \scnfileitem{Алфавит SCs-кода строится на основе современных общепринятых наборов символов, что позволяет упростить разработку средств для работы с sc.s-текстами с использованием современных технологий.}
                \scnfileitem{В состав sc.s-текстов, как и в состав текстов любых других языков, являющихся вариантами внешнего отображения текстов SC-кода, могут входить различные файлы, в том числе естественно-языковые или даже файлы, содержащие другие sc.s-тексты. В общем случае в таких файлах могут использоваться самые разные символы, в связи с чем будем считать, что в Алфавит SCs-кода эти символы не включаются.}
            \end{scnrelfromlist}

            \scnheader{Алфавит символов, используемых в sc.s-разделителях}
            \begin{scnhaselementset}
                \scnitem{\textit{пробел}}
                \scnitem{\textit{точка с запятой}}
                \scnitem{\textit{двоеточие}}
                \scnitem{\textit{круглый маркер}}
                \scnitem{\textit{знак равенства}}
            \end{scnhaselementset}
            \scnsuperset{Алфавит символов, используемых в sc.s-разделителях, изображающих связь инцидентности sc-элементов}
            \begin{scnindent}
                \begin{scnhaselementset}
                    \scnitem{\scnfileclass{<}}
                    \scnitem{\scnfileclass{>}}
                    \scnitem{\scnfileclass{|}}
                    \scnitem{\scnfileclass{-}}
                \end{scnhaselementset}
            \end{scnindent}
            \scnsuperset{Алфавит символов, используемых в sc.s-коннекторах}
            \begin{scnindent}
                \scnsuperset{Расширенный алфавит символов, используемых в sc.s-коннекторах}
                \begin{scnindent}
                    \scnidtf{Расширенный алфавит sc.s-коннекторов}
                    \begin{scnhaselementset}
                        \scnitem{\scnfileclass{$\in$}}
                        \scnitem{\scnfileclass{$\ni$}}
                        \scnitem{\scnfileclass{$\notin$}}
                        \scnitem{\scnfileclass{$\not \ni$}}
                        \scnitem{\scnfileclass{$\subseteq$}}
                        \scnitem{\scnfileclass{$\supseteq$}}
                        \scnitem{\scnfileclass{$\subset$}}
                        \scnitem{\scnfileclass{$\supset$}}
                        \scnitem{\scnfileclass{$\leq$}}
                        \scnitem{\scnfileclass{$\geq$}}
                        \scnitem{\scnfileclass{$\Leftarrow$}}
                        \scnitem{\scnfileclass{$\Rightarrow$}}
                        \scnitem{\scnfileclass{$\Leftrightarrow$}}
                        \scnitem{\scnfileclass{$\leftarrow$}}
                        \scnitem{\scnfileclass{$\rightarrow$}}
                        \scnitem{\scnfileclass{$\leftrightarrow$}}
                    \end{scnhaselementset}
                    \scnsuperset{Базовый алфавит символов, используемых в sc.s-коннекторах}
                    \begin{scnindent}
                        \scnidtf{Базовый алфавит sc.s-коннекторов}
                        \begin{scnhaselementset}
                            \scnitem{\scnfileclass{$\sim$}}
                            \scnitem{\textit{знак подчеркивания}}
                            \scnitem{\textit{знак равенства}}
                            \scnitem{\scnfileclass{>}}
                            \scnitem{\scnfileclass{<}}
                            \scnitem{\textit{двоеточие}}
                            \scnitem{\scnfileclass{-}}
                            \scnitem{\scnfileclass{|}}
                            \scnitem{\scnfileclass{/}}
                        \end{scnhaselementset}
                    \end{scnindent}
                \end{scnindent}
                \scntext{примечание}{Как в Базовом, так и в Расширенном Алфавитах sc.s-коннекторов используются следующие общие признаки, характеризующие тип изображаемого sc-коннектора:
                \begin{scnitemize}
                    \item \textit{знак подчеркивания} как признак изображений переменных sc-коннекторов (один \textit{знак подчеркивания} для sc-коннекторов, являющихся первичными sc-переменными, два  \textit{знака подчеркивания} для sc-коннекторов, являющихся вторичными sc-переменными (sc-метапеременными));
                    \item \textit{вертикальная черта} (|) как признак изображений негативных sc-дуг принадлежности;
                    \item \textit{косая черта} (/) как признак изображений нечетких sc-дуг принадлежности;
                    \item \textit{тильда} ($\sim$) как признак изображений временных sc-дуг принадлежности
                \end{scnitemize}
                    При необходимости комбинации указанных признаков перечисленные символы комбинируются так, как показано в сегменте \textit{Описание sc.s-разделителей и sc.s-ограничителей}.}\bigskip
            \end{scnindent}
            
            \begin{scnset}
                \scnitem{Расширенный алфавит символов, используемых в sc.s-коннекторах}
                \scnitem{Базовый алфавит символов, используемых в sc.s-коннекторах}
            \end{scnset}
            \scntext{пояснение}{Для упрощения процесса разработки исходных текстов баз знаний с использованием SCs-кода и создания соответствующих средств вводятся два алфавита символов. \textit{Базовый алфавит символов, используемых в sc.s-коннекторах} включает только символы, входящие в переносимый набор символов (portable character set) и имеющиеся на стандартной современной клавиатуре. Таким образом, для разработки исходных текстов баз знаний, использующих только \textit{Базовый алфавит символов, используемых в sc.s-коннекторах} достаточно обычного текстового редактора. \textit{Расширенный алфавит символов, используемых в sc.s-коннекторах} включает также дополнительные символы, которые позволяют сделать sc.s-тексты (и sc.n-тексты) более читабельными и наглядными. Для визуализации и разработки sc.s-текстов с использованием расширенного алфавита требуется наличие специализированных средств.}
            
            \scnheader{Алфавит символов, используемых в sc.s-ограничителях}
            \begin{scnhaselementset}
                \scnitem{\scnfileclass{(}}
                \scnitem{\scnfileclass{)}}
                \scnitem{\scnfileclass{\scnstar}}
            \end{scnhaselementset}

            \scnheader{Алфавит символов, используемых в неоднозначных sc.s-изображениях sc-узлов}
            \begin{scnhaselementset}
                \scnitem{\scnfileclass{\scnleftcurlbrace}}
                \scnitem{\scnfileclass{\scnrightcurlbrace}}
                \scnitem{\scnfileclass{-}}
                \scnitem{\scnfileclass{!}}
                \scnitem{\scnfileclass{\scnleftsquarebracene}}
                \scnitem{\scnfileclass{\scnrightsquarebracene}}
            \end{scnhaselementset}
            \bigskip
        \end{scnsubstruct}
        \scnendsegmentcomment

        \scnsegmentheader{Описание sc.s-разделителей и sc.s-ограничителей}
        \begin{scnsubstruct}
            \scnheader{sc.s-разделитель}
            \scnidtf{разделитель, используемый в sc.s-текстах}
            \begin{scnsubdividing}
                \scnitem{sc.s-разделитель, используемый для структуризации sc.s-предложений}
                \begin{scnindent}    
                    \scnsuperset{sc.s-коннектор}
                    \scnsuperset{sc.s-разделитель, изображающий связь инцидентности sc-элементов}
                    \scnsuperset{двоеточие}
                    \begin{scnindent}
                        \scneqfileclass{$\colon$}
                        \scntext{примечание}{Разделяет sc-идентификатор бинарного отношения и второй компонент одной из связок этого отношения в случае, если указанное бинарное отношение и его связка связаны \uline{константной} sc-дугой принадлежности.}
                    \end{scnindent}
                    \scnsuperset{двойное двоеточие}
                    \begin{scnindent}
                        \scneqfileclass{$\colon\colon$}
                        \scntext{примечание}{Разделяет sc-идентификатор бинарного отношения и второй компонент одной из связок этого отношения в случае, если указанное бинарное отношение и его связка связаны \uline{переменной} sc-дугой принадлежности.}
                    \end{scnindent}
                \end{scnindent}
                \scnitem{sc.s-разделитель sc.s-предложений}
                \begin{scnindent}
                    \scneqfileclass{$;;$}
                    \scnidtf{двойная точка с запятой}
                \end{scnindent}
            \end{scnsubdividing}

            \scnheader{sc.s-ограничитель}
            \scnsuperset{sc.s-ограничитель присоединенных sc.s-предложений}
            \begin{scnindent}
                \scneq{\scnfilelong{(!\scnleftsquarebrace (* \scnrightsquarebrace! $\cup$ !\scnleftsquarebrace *) \scnrightsquarebrace!)}}
                \scntext{пояснение}{Круглые скобки со звездочкой ограничивают присоединенные sc.s-предложения, которые, в свою очередь, могут иметь в своем составе другие присоединенные sc.s-предложения.}
            \end{scnindent}

            \scnheader{sc.s-коннектор}
            \scnidtf{изображение \textit{sc-коннектора} во внешнем тексте SCs-кода или SCn-кода}
            \scnsubset{sc.s-разделитель}
            \scntext{примечание}{типология sc.s-коннекторов полностью соответствует типологии sc.g-коннекторов, и, тем более, \mbox{sc-коннекторов}, т.к. она учитывает устоявшиеся традиции изображения связок целого ряда конкретных отношений}
            \begin{scnsubdividing}
                \scnitem{ориентированный sc.s-коннектор}
                \scnitem{неориентированный sc.s-коннектор}
            \end{scnsubdividing}
            \begin{scnsubdividing}
                \scnitem{sc.s-коннектор, соответствующий sc.g-дуге принадлежности}
                \scnitem{sc.s-коннектор, соответствующий sc.g-коннектору, который не является sc.g-дугой принадлежности}
            \end{scnsubdividing}
           
            \scnheader{sc.s-разделитель, изображающий связь инцидентности sc-элементов}
            \begin{scnsubdividing}
                \scnitem{знак инцидентности правого sc-коннектора}
                \begin{scnindent}
                    \scnidtf{знак инцидентности sc-коннектора, sc-идентификатор которого находится справа}
                    \scneqfileclass{|-}
                \end{scnindent}
                \scnitem{знак инцидентности левого sc-коннектора}
                \begin{scnindent}
                    \scnidtf{знак инцидентности sc-коннектора, sc-идентификатор которого находится слева}
                    \scneqfileclass{-|}
                \end{scnindent}
                \scnitem{знак инцидентности входящей sc-дуги справа}
                \begin{scnindent}
                    \scnidtf{знак инцидентности sc-дуги, sc-идентификатор который находится справа}
                    \scneqfileclass{|<}
                \end{scnindent}
                \scnitem{знак инцидентности входящей sc-дуги слева}
                \begin{scnindent}
                    \scnidtf{знак инцидентности sc-дуги, sc-идентификатор который находится слева}
                    \scneqfileclass{>|}
                \end{scnindent}
            \end{scnsubdividing}
            \scntext{пояснение}{На множестве sc-элементов задано бинарное ориентированное отношение инцидентности sc-элементов, а так же подмножество этого отношения --- отношение инцидентности входящих sc-дуг, каждая пара которого связывает sc-дугу с тем sc-элементом, в который она входит.В SC-коде sc-коннекторы могут соединять между собой не только sc-узел с sc-узлами, но и sc-узел с sc-коннектором и даже sc-коннектор с sc-коннектором. В последнем случае, указывая инцидентность sc-коннекторов, необходимо уточнить, какой из них является соединяемым (связываемым), а какой-соединяющим (связующим). Поэтому отношение инцидентности, заданное на множестве sc-элементов является ориентированным. Первый компонент пары этого отношения --- связующий sc-коннектор, а второй --- связуемый sc-элемент. Очевидно, что связующий sc-элемент всегда является sc-коннектором, а sc-узел может быть только связуемым.}
            \scntext{примечание}{указанные sc.s-разделители с точки зрения синтаксической структуры sc.s-предложений аналогичны \mbox{sc.s-коннекторам}, но с точки зрения их денотационной семантики в отличие от sc.s-коннекторов они не являются изображениями соответствующих sc-коннекторов}
            \input{Contents/part_kb/intro_lang/intro_scs_connectors}
            \input{Contents/part_kb/intro_lang/intro_scs_connectors_transf}
            
            \scnheader{знак равенства}
            \scneqfileclass{=}
            \scnidtf{связь синонимии между sc-идентификаторами, по крайней мере один из которого является sc-выражением}
            \scntext{примечание}{знак равенства является \textit{sc.s-разделителем} двух \textit{sc-идентификаторов}, которые идентифицируют (именуют) одну и ту же \textit{сущность} и, соответственно, являются \textit{sc-идентификаторами}* (внешними уникальными изображениями) одного и того же \textit{sc-элемента}. При этом из указанных двух sc-идентификаторов чаще всего один является простым sc-идентификатором, а второй --- sc-выражением. Реже оба эти sc-идентификатора являются sc-выражениями. И совсем редко оба они являются простыми sc-идентификаторами. Последнее обозначает то, что оба эти sc-идентификатора являются основными \textit{sc-идентификаторами}* одного и того же \textit{sc-элемента}. Пример:\textit{SC-код} = \textit{sc.s-текст};;Здесь первый \textit{sc-идентификатор} является \textit{именем собственным}, а второй --- \textit{именем нарицательным}.При трансляции \textit{sc.s-текста} в \textit{SC-код} знаку равенства на некотором этапе может быть поставлено в соответствие \textit{sc-ребро}, принадлежащее отношению \textit{синонимии}* \textit{sc-элементов}, идентифицируемых \mbox{\textit{sc-идентификаторами}}, связанными знаком равенства. Но на последующем этапе указанное \textit{sc-ребро} \uline{удаляется}, а связанные им \textit{sc-элементы} \uline{склеиваются}. Таким образом \textit{sc-ребро}, принадлежащее отношению \textit{синонимии}* sc-элементов, имеет не только денотационную, но и операционную семантику.}\scnheader{знак равенства с включением}
            \scneq{\scnfilelong{(!\scnleftsquarebracene $\supseteq$ \scnrightsquarebracene! $\cup$ !\scnleftsquarebracene $\subseteq$ \scnrightsquarebracene!)}}
            \scnidtf{изображение \textit{sc-дуги}, принадлежащей отношению \textit{погружения}*, связывающей два \textit{sc-узла}, обозначающих \textit{sc-тексты}, первый из которых является погружающим, а второй (в который указанная \textit{sc-дуга} входит) является погружаемым, вводимым в состав первого \textit{sc-текста}}
            \scntext{примечание}{\textit{sc-дуга}, принадлежащая отношению \textit{погружения}*, интерпретируется как команда погружения одного \textit{sc-текста} в состав другого. При выполнении этой команды (1) все \textit{sc-элементы} погружаемого \textit{sc-текста} становятся элементами, принадлежащими погружающему \textit{sc-тексту}, (2) все синонимичные \textit{sc-элементы}, оказавшиеся в составе погружающего \textit{sc-текста}, склеиваются, (3) \textit{sc-узел}, обозначающий погружаемый \textit{sc-текст}, а так же спецификация этого \textit{sc-текста} (включая перечень всех его \textit{sc-элементов}) погружается в историю эволюции \textit{базы знаний} вместе со спецификацией события погружения рассматриваемого \textit{sc-текста} в состав \textit{базы знаний}.}
            
            \scnheader{(знак равенства $\cup$ знак равенства с включением)}
            \scntext{примечание}{указанные sc.s-коннекторы отличаются от остальных sc.s-коннекторов тем, что они и соответствующие им sc-коннекторы (sc-ребра, принадлежащих отношению синонимии sc-элементов и sc-дуги, принадлежащие отношению погружения одного sc-текста в состав другого) имеют не только денотационную, но и операционную семантику, т.к. являются командами склеивания и командами погружения.}
            
            \scnheader{sc.s-коннектор, соответствующий sc.g-дуге принадлежности}
            \scnrelfrom{таблица}{Таблица. Алфавит sc.s-коннекторов, соответствующих sc.g-дугам принадлежности}

            \scnheader{sc.s-коннектор, соответствующий sc.g-коннектору, который не является sc.g-дугой принадлежности}
            \scnrelfrom{таблица}{Таблица. Алфавит sc.s-коннекторов, соответствующих sc.g-коннекторам, которые не являются sc-дугами принадлежности}
        \end{scnsubstruct}
        \scnendsegmentcomment
        
        \scnsegmentheader{Описание sc.s-предложений}
        \begin{scnsubstruct}
            \scnheader{sc.s-предложение}
            \scnidtf{минимальный семантически целостный фрагмент sc.s-текста}
            \scnidtf{минимальный sc.s-текст}
            \scnsubset{sc.s-текст}
            \scnsuperset{простое sc.s-предложение}
            \begin{scnindent}
                \scnidtf{минимальное sc.s-предложение}
                \scntext{пояснение}{\textit{sc.s-предложение}, (1) \uline{состоящее} или из двух \textit{sc-идентификаторов}, соединенных между собой \textit{\mbox{sc.s-коннектором}}, или из трех \textit{sc-идентификаторов}, разделенных \textit{sc.s-разделителями, изображающими связь инцидентности sc-элементов}, и (2) завершающееся \textit{двойной точкой с запятой}}
                \scntext{примечание}{Нетрудно заметить, что простые sc.s-предложения по сути аналогичны триплетам языка RDF (\mbox{RDF-триплетам}), за тем исключением, что \textit{простое sc.s-предложение} можно развернуть\ при помощи \textit{Операции конверсии sc.s-предложений*} не меняя при этом его смысл, а RDF-триплет нельзя. Это является одной из причин, по которой, в отличие от RDF-триплетов, в простых \mbox{sc.s-предложениях} \textit{\mbox{sc.s-коннекторы}} и \textit{\mbox{sc.s-разделители}, изображающие связь инцидентности \mbox{sc-элементов}} не могут быть опущены, поскольку они в том числе показывают направление изображаемой ими связи между sc-элементами.}
                \begin{scnrelfromlist}{пример}
                    \scnfileitem{\textit{многоугольник} $\supset$ \textit{треугольник}}
                    \begin{scnindent}
                        \scnrelboth{семантическая эквивалентность}{\scnfileimage[20em]{Contents/part_kb/images/scs/inclusion.png}}
                    \end{scnindent}
                    \scnfileitem{\textit{сторона*} $\ni$ (\textit{Четырехугк(ТчкА;ТчкВ;ТчкС;ТчкD)} $\Rightarrow$ \textit{Отр(ТчкВ;ТчкС)});;}
                    \begin{scnindent}
                        \scnrelboth{семантическая эквивалентность}{\scnfileimage[20em]{Contents/part_kb/images/scs/side.png}}
                    \end{scnindent}
                    \scnfileitem{\textit{Si} |- \textit{ai} >| \textit{ei}}
                    \begin{scnindent}
                        \scnrelboth{семантическая эквивалентность}{\scnfileimage[20em]{Contents/part_kb/images/scs/inclusion_incident.png}}
                    \end{scnindent}
                \end{scnrelfromlist}
            \end{scnindent}
            \scntext{примечание}{Признаком завершения любого \textit{sc.s-предложения}, т.е. последними его символами является \textit{двойная точка с запятой}, которую, следовательно, можно считать разделителем \textit{sc.s-предложений}.}
            \begin{scnrelfromlist}{заданная операция}
                \scnitem{Операция конверсии sc.s-предложения*}
                \begin{scnindent}
                    \scnsubset{синтаксическая трансформация*}
                    \scntext{пояснение}{Каждое \textit{sc.s-предложение} (в том числе, и \textit{простое sc.s-предложение}) можно преобразовать в семантически эквивалентное ему \textit{sc.s-предложение} путем конверсии (разворота) цепочки компонентов \textit{sc.s-предложения}. Так, например, при конверсии (развороте) простого \textit{\mbox{sc.s-предложения}} (1) первый его \textit{\mbox{sc-идентификатор}} (первый компонент этого \textit{\mbox{sc.s-предложения}}) становится третьим компонентом конвертированного\textit{ \mbox{sc.s-предложения}}, (2) второй его \textit{\mbox{sc-идентификатор}} (третий компонент исходного \textit{\mbox{sc.s-предложения}}) становится первым компонентом конвертированного\ \textit{\mbox{sc.s-предложения}} и (3) второй компонент исходного \textit{\mbox{sc.s-предложения}} (\textit{\mbox{sc.s-коннектор}} или \textit{\mbox{sc.s-разделитель}, изображающий связь инцидентности \mbox{sc-элементов}}, соединяющий указанные выше компоненты) остается вторым компонентом конвертированного \textit{\mbox{sc.s-предложения}}, но меняет направленность ($\ni$ заменяется на $\in$ и наоборот, $\supset$ на $\subset$ и наоборот, $\Rightarrow$ на $\Leftarrow$ и наоборот и т.д.)}
                    \scntext{примечание}{Можно говорить не только о конверсии sc.s-предложения, но и о конверсии sc.s-коннектора, о конверсии sc.s-разделителя, изображающего связь инцидентности sc.s-элементов.}
                    \scnrelfrom{sc.s-текст до трансформации}{\scnfilelong{\textit{треугольник $\ni$ Треуг(ТчкВ;ТчкС;ТчкD)};;}}
                    \scnrelfrom{sc.s-текст после трансформации}{\scnfilelong{\textit{Треуг(ТчкВ;ТчкС;ТчкD) $\in$ треугольник};;}}
                    \begin{scnindent}
                        \scnrelboth{семантическая эквивалентность}{\scnfileimage[20em]{Contents/part_kb/images/scs/conversion.png}}
                    \end{scnindent}
                \end{scnindent}
                \scnitem{Операция присоединения sc.s-предложения*}
                \begin{scnindent}
                    \scnsubset{синтаксическая трансформация*}
                    \scnidtf{Операция соединения двух sc.s-предложений при совпадении последнего компонента первого предложения с первым компонентом второго*}
                    \scntext{пояснение}{В результате выполнения данной операции:
                    \begin{scnitemize}
                        \item первый компонент второго sc.s-предложения удаляется;
                        \item оставшаяся часть второго предложения окружается sc.s-ограничителем присоединенных предложений ((*\ и *)). Разделитель sc.s-предложений (;;) также попадает внутрь указанного ограничителя;
                        \item полученная конструкция помещается между последним компонентом первого предложения и разделителем sc.s-предложений, которым заканчивалось первое предложение;
                        \item второе предложение, таким образом, становится присоединенным sc.s-предложением.
                    \end{scnitemize}
                    Аналогичным образом к любому присоединенному sc.s-предложению могут пристыковываться\ другие присоединенные sc.s-предложения, в общем случае уровень такой вложенности не ограничен.}
                \end{scnindent}
                \scnitem{Операция слияния sc.s-предложений*}
                \begin{scnindent}
                    \scnsubset{синтаксическая трансформация*}
                    \scnidtf{Операция присоединения простого sc.s-предложения к sc.s-предложению, у которого последний sc.s-коннектор совпадает с sc.s-коннектором простого sc.s-предложения, а предшествующий указанному sc.s-коннектору sc-идентификатор совпадает с первым sc-идентификатором простого sc.s-предложения*}
                    \scntext{пояснение}{В результате выполнения этой операции совпадающие sc-идентификаторы и sc.s-коннекторы соединяемых sc.s-предложений склеиваются\ , а последние sc-иден\-ти\-фи\-ка\-то\-ры соединяемых \textit{sc.s-предложений} становятся последними компонентами объединенного \textit{sc.s-предложения},разделенными \textit{точкой с запятой}. Аналогичным образом можно присоединять сколько угодно простых \textit{sc.s-предложений}.}
                \end{scnindent}
                \scnitem{Операция разложения sc.s-предложений на простые sc.s-предложения*}
                \begin{scnindent}
                    \scnsubset{синтаксическая трансформация*}
                    \scntext{пояснение}{Каждое \textit{sc.s-предложение} можно разложить на множество \textit{простых sc.s-предложений}, т.е. представить в виде последовательности \textit{простых sc.s-предложений}.}
                \end{scnindent}
                \scnitem{Операция разложения sc.s-предложений на простые sc.s-предложения с sc.s-разделителем, изображающим связь инцидентности sc-элементов*}
                \begin{scnindent}
                    \scnsubset{синтаксическая трансформация*}
                    \scntext{пояснение}{Каждое \textit{sc.s-предложение} (в том числе и \textit{простое sc.s-предложение} с \textit{sc.s-коннектором}) можно представить в виде семантически эквивалентной последовательности \textit{простых \mbox{sc.s-предложений}} с \textit{sc.s-разделителем, изображающим связь инцидентности \mbox{sc-элементов}}.}
                    \scntext{примечание}{Данная операция осуществляет \uline{однозначное} (!) формирование множества \textit{простых \mbox{sc.s-предложений}} указанного вида.}
                \end{scnindent}
            \end{scnrelfromlist}

            \newpage
            \scnheader{sc.s-предложение}
            \scntext{примечание}{Операции, заданные на множестве \textit{sc.s-предложений} можно разделить на три группы:
            \begin{scnitemize}
                \item группа операций конверсии \textit{sc.s-предложений}, состоящая из одной операции;
                \item группа операций соединения \textit{sc.s-предложений};
                \item группа операций декомпозиции \textit{sc.s-предложений} и, в частности, операций разложения \textit{sc.s-предложений}.
            \end{scnitemize}
            Очевидно, что операции соединения \textit{sc.s-предложений} и операции декомпозиции \textit{sc.s-предложений} являются обратными друг другу операциями.}
            
            \scnheader{Описание примеров выполнения операций, заданных на множестве sc.s-предложений}
            \begin{scnsubstruct}
            \bigskip
            \scnfilelongheader{\textit{треугольник $\ni$ Треугк(ТчкВ;ТчкС;ТчкD)};;}
            \scnrelfrom{Операция конверсии sc.s-предложения}{\scnfilelong{\textit{Треугк(ТчкВ;ТчкС;ТчкD) $\in$ треугольник};;}}
            \begin{scnindent}
                \scnrelboth{семантическая эквивалентность}{\scnfileimage[20em]{Contents/part_kb/images/scs/conversion.png}}
            \end{scnindent}

            \scnfilelongheader{\textit{треугольник $\ni$ Треугк(ТчкВ;ТчкС;ТчкD);;\newlineТреугк(ТчкВ;ТчкС;ТчкD) $\Rightarrow$ сторона*:включение*: Отр(ТчкВ;ТчкC);;}}
            \scnrelfrom{Операция присоединения sc.s-предложения}{\scnfilelong{\textit{треугольник $\ni$ Треугк(ТчкВ;ТчкС;ТчкD) (* $\Rightarrow$ сторона*:включение*:Отр(ТчкВ;ТчкС);;*) };;}}
            \begin{scnindent}
                \scnrelboth{семантическая эквивалентность}{\scnfileimage[20em]{Contents/part_kb/images/scs/joining_sentences.png}}
            \end{scnindent}

            \scnfilelongheader{\textit{сторона* $\ni$ (Треугк(ТчкВ;Тчк С;ТчкD) $\Rightarrow$ Отр(ТчкВ;ТчкС));;\newlineсторона* $\ni$ (Треугк(ТчкВ;Тчк С;ТчкD) $\Rightarrow$ Отр(ТчкC;ТчкD));;}}
            \scnrelfrom{Операция слияния sc.s-предложений}{\scnfilelong{\textit{сторона* $\ni$ ((Треугк(ТчкВ;ТчкС;ТчкD) $\Rightarrow$ Отр(ТчкВ;ТчкС));(Треуг(ТчкВ;ТчкС;ТчкD) $\Rightarrow$ Отр(ТчкC;ТчкD)));;}}}
            \begin{scnindent}
                \scnrelfrom{синтаксическая трансформация}{\scnfilelong{\textit{Треугк(ТчкВ;ТчкС;ТчкD)}$\Rightarrow$\textit{сторона*}: \textit{Отр(ТчкВ;ТчкС)};\textit{Отр(ТчкС;ТчкD)};;}}
                \scnrelboth{семантическая эквивалентность}{\scnfileimage[20em]{Contents/part_kb/images/scs/joining_sentence.png}}
            \end{scnindent}

            \scnfilelongheader{\textit{Треугк(ТчкВ;ТчкС;ТчкD) $\Rightarrow$ сторона*:включение*:Отр(ТчкВ;ТчкС);;}}
            \scnrelfrom{Операция разложения sc.s-предложений на простые sc.s-предложения}{\scnfilelong{\textit{сторона* $\ni$ (Треугк(ТчкВ;ТчкС;ТчкD) $\Rightarrow$ Отр(ТчкВ;ТчкС));;\newline включение* $\ni$ (Треугк(ТчкВ;ТчкС;ТчкD) $\Rightarrow$ Отр(ТчкВ;ТчкС));;}}}
            \begin{scnindent}
                \scnrelboth{семантическая эквивалентность}{\scnfileimage[20em]{Contents/part_kb/images/scs/dividing_sentences.png}}
            \end{scnindent}

            \scnfilelongheader{\textit{треугольник $\ni$ Треугк(ТчкВ;ТчкC;ТчкD)}}
            \scnrelfrom{Операция разложения sc.s-предложений на простые sc.s-предложения с sc.s-разделителем, изображающим связь инцидентности sc-элементов}{\scnfilelong{\textit{треугольник |- ai >| Треугк(ТчкВ;ТчкС;ТчкD);;\newlineконстантный постоянный sc-узел, обозначающий класс $\ni$ треугольник;;\newlineконстантная постоянная позитивная sc-дуга принадлежности $\ni$ ai;;\newlineконстантный постоянный sc-узел общего вида $\ni$ Треугк(ТчкВ;ТчкC;ТчкD);;}}}
            \begin{scnindent}
                \scnrelboth{семантическая эквивалентность}{\scnfileimage[20em]{Contents/part_kb/images/scs/dividing_sentences_incident.png}}
            \end{scnindent}
            
            \scnheader{присоединенное sc.s-предложение}
            \scnidtf{встроенное sc.s-предложение}
            \scntext{пояснение}{Присоединенные sc.s-предложения используются для того, чтобы продолжить спецификацию какого-либо sc-элемента, sc-идентификатор которого является последним компонентом в рамках какого-либо sc.s-предложения, не начиная при этом нового sc.s-предложения и, таким образом, не дублируя указанный \mbox{sc-идентификатор}. Внутрь присоединенных sc.s-предложений также могут встраиваться другие присоединенные sc.s-предложения, в общем случае уровень вложенности таких предложений не ограничен. Таким образом присоединенные sc.s-предложения описывают ветвление\ sc.s-предложений, при этом точками такого ветвления\ выступают sc-идентификаторы, входящие в состав этих sc.s-предложений.Благодаря введению присоединенных sc.s-предложений появляется возможность любой sc-текст изобразить в виде одного sc.s-предложения, содержащего необходимое количество присоединенных sc.s-предложений. Таким образом, SCs-код по выразительной мощности становится эквивалентным SCn-коду.}\scnheader{sc.s-предложение}
            \scntext{денотационная семантика}{С семантической точки зрения \textit{sc.s-предложение} представляет собой описание некоторого \uline{маршрута} в соответствующем sc-тексте, который является графовой структурой специального вида и структура которого описывается (изображается) с помощью \textit{sc.s-предложений}. Указанный маршрут проводится\ по sc-коннекторам и по связям инцидентности sc-элементов, если маршрут проходит через инцидентные sc-коннекторы. В описании указанного маршрута могут дополнительно указываться множества (чаще всего отношения), которым принадлежат sc-коннекторы, входящие в описываемый маршрут. Кроме того, указанный маршрут в начале и/или в конце может иметь разветвления, когда какой-либо sc-элемент \uline{одинаково} инцидентен нескольким \uline{однотипным} sc-коннекторам, соединяющим указанный sc-элемент с некоторыми другими sc-элементами.Таким образом каждое указанное разветвление состоит из неограниченного числа ветвей, каждая из которых состоит из одного sc-коннектора и одного связываемого им sc-элемента.}
            
            \scnheader{компонент sc.s-предложения*}
            \scntext{пояснение}{Каждое \textit{sc.s-предложение} представляет собой последовательность (1) \textit{sc-идентификаторов}, \mbox{(2) \textit{sc.s-коннекторов}} или \textit{sc.s-разделителей}, изображающих связь инцидентности \textit{sc-элементов}, (3) \textit{точек с запятыми}, (4) \textit{ограничителей присоединенных sc.s-предложений}, завершаемая \textit{двойной точкой с запятой}. При этом непосредственно соседствовать друг с другом не могут ни \textit{\mbox{sc-идентификаторы}}, ни \textit{\mbox{sc.s-коннекторы}}, ни, очевидно, \textit{точки с запятыми} и \textit{ограничители присоединенных sc.s-предложений}.~\\Между \textit{sc-идентификаторами} в рамках \textit{sc.s-предложения} может находиться либо \textit{точка с запятой}, либо \textit{sc.s-коннектор}, либо \textit{sc.s-разделитель}, изображающий связь инцидентности \textit{sc-элементов}. Слева и справа от \textit{sc.s-коннектора} и от \textit{sc.s-разделителя}, изображающего связь инцидентности \textit{sc-элементов}, должны находиться \textit{sc-идентификаторы}.Указанные \textit{sc-идентификаторы}, \textit{sc.s-коннекторы} и \textit{sc.s-разделители}, изображающие связь инцидентности \textit{sc-элементов}, считаются компонентами соответствующего \textit{sc.s-предложения}. Понятие быть компонентом sc.s-предложения\ является относительным понятием (отношением), т.к. в состав некоторых компонентов \textit{sc.s-предложения} (в состав \textit{sc-идентификаторов}, являющихся \textit{sc.s-выражениями}, ограничиваемыми фигурными или квадратными скобками) могут входить других \textit{sc.s-предложения}, состоящие из своих компонентов.}\scnrelfrom{первый домен}{sc.s-предложение}
            \scnrelfrom{второй домен}{(sc-идентификатор $\cup$ sc.s-разделитель $\cup$ sc.s-ограничитель)}
            
            \scnheader{sc.s-модификатор*}
            \scnsubset{компонент sc.s-предложения*}
            \scntext{пояснение}{Это дополнительный вид компонентов \textit{sc.s-предложений}. Каждый \textit{sc.s-модификатор}, являющийся компонентом некоторого \textit{sc.s-предложения}, представляет собой \textit{sc-идентификатор}, обозначающий множество (чаще всего, отношение), которому принадлежит sc-коннектор, изображенный \textit{sc.s-коннектором}, который предшествует указанному \textit{sc-идентификатору}. Признаком \textit{sc.s-модификатора} является \textit{двоеточие} (или \textit{двойное двоеточие}), которое ставится после \textit{sc.s-модификатора} и отделяет его либо от следующего за ним другого \textit{sc.s-модификатора} для этого же \textit{sc.s-коннектора}, либо от следующего за ним \textit{sc-идентификатора}, соответствующего sc-элементу, который инцидентен sc-коннектору, изображенному \textit{sc.s-коннектором}, находящимся левее рассматриваемого \textit{sc-идентификатора} после одного или нескольких \textit{sc.s-модификаторов}. Обычное (одинарное) \textit{двоеточие} обозначает, что sc-элемент, изображенный соответствующим \mbox{sc.s-модификатором}, связан с sc-коннектором, изображенным левее этого \mbox{sc.s-модификатора}, \textit{базовой \mbox{sc-дугой}} (\textit{константной постоянной позитивной \mbox{sc-дугой} принадлежности}), \textit{двойное двоеточие} обозначает, что указанные элементы связаны \textit{переменной постоянной позитивной \mbox{sc-дугой} принадлежности}.}
            \begin{scnrelfromlist}{пример}
                \scnfileitem{\textit{Четырехугк(ТчкА;ТчкВ;ТчкС;ТчкD)} $\Rightarrow$ \textit{сторона*} : \textit{включение*} : \textit{Отр(ТчкВ;ТчкС)};;}
                \begin{scnindent}
                    \scnrelboth{семантическая эквивалентность}{\scnfileimage[20em]{Contents/part_kb/images/scs/modifier.png}}
                \end{scnindent}
                \scnfileitem{\textit{Треугк(ТчкА;ТчкВ;ТчкС)} $\_\Rightarrow$ \textit{сторона*} :: \textit{\_s};; }
                \begin{scnindent}
                    \scnrelboth{семантическая эквивалентность}{\scnfileimage[20em]{Contents/part_kb/images/scs/modifier_var.png}}
                \end{scnindent}
            \end{scnrelfromlist}

            \scnheader{sc.s-текст}
            \scnidtf{конкатенация \textit{sc.s-предложений}}
            \scnidtf{последовательность \textit{sc.s-предложений}, разделяемых \textit{двойными точками с запятой}}
            \scnsuperset{максимальный исходный sc.s-текст}
            \begin{scnindent}
                \scnidtf{конкатенция \textit{sc.s-предложений}, слева и справа от которой отсутствуют какие-либо символы SCs-кода}
            \end{scnindent}
            \scnsuperset{максимальный sc.s-текст, включенный в структуру}
            \begin{scnindent}
                \scnidtf{конкатенция всех \textit{sc.s-предложений}, входящих в состав \textit{sc.s-выражения структуры}}
                \scnsuperset{sc.s-текст, включенный в структуру}
                \begin{scnindent}
                    \scnidtf{часть цепочки \textit{sc.s-предложений}, входящих в состав максимального sc.s-текста, включенного в структуру}
                    \scnsuperset{sc.s-предложение, включенное в структуру}
                \end{scnindent}
            \end{scnindent}
            \scntext{примечание}{\textit{sc.s-предложение} является минимальным sc.s-текстом.}\scntext{свойство}{Смысл sc.s-текста (а также \textit{sc.s-текста, включенного в структуру} не зависит от порядка \textit{\mbox{sc.s-предложений}} в этих sc-текстах. Т.е. перестановка \textit{\mbox{sc.s-предложений}} в рамках таких \mbox{sc.s-текстов} смысла этих \mbox{sc.s-текстов} не меняет (т.е. приводит к семантически эквивалентным \mbox{sc.s-текстам}), но сильно влияет на трудоемкость человеческого восприятия (на читабельность) этих текстов.}
            \scnrelfrom{пример}{\scnfilelong{\textit{материальный объект} $\ni$ \textit{Земля} (* => \textit{вращаться вокруг}*: \textit{спутник}*: \textit{Луна};;*);; \textit{материальный объект} $\ni$ \textit{Луна}(* => \textit{основной идентификатор}*: \scnleftsquarebrace Moon \scnrightsquarebrace (* <- \textit{Английский язык};; *); \scnleftsquarebrace Луна \scnrightsquarebrace (* <- \textit{Русский язык};; *);; *);; \textit{материальный объект} $\ni$ \textit{Солнце} (* => \textit{вращаться вокруг}*: \textit{Земля}; \textit{Марс};; *);; \textit{материальный объект} $\ni$ \textit{Марс};;}}
            \begin{scnindent}
                \scnrelfrom{семантическая эквивалентность}{\scnfileimage[20em]{Contents/part_kb/images/scs/scs_text_example.png}}
            \end{scnindent}
            \bigskip
        \end{scnsubstruct}
        \scnendsegmentcomment
        
        \scnsegmentheader{Описание Ядра SCs-кода и различных направлений его расширения}
        \begin{scnsubstruct}
            \scnheader{Ядро SCs-кода}
            \scnidtf{Подъязык SCs-кода, который использует минимальный набор синтаксических средств, но при этом имеет семантическую мощность, эквивалентную мощности SCs-кода в целом}
            \scntext{принципы, лежащие в основе}{В Ядре SCs-кода:
            \begin{scnitemize}
                \item используются только \textit{простые sc-идентификаторы}, в том числе \textit{sc-идентификаторы внешних файлов ostis-систем} (sc-выражения не используются);
                \item используются только \textit{sc.s-разделители, изображающие связь инцидентности sc-элементов}, а также sc.s-коннектор, изображающий константную  постоянную позитивную пару принадлежности ($\in$ и $\ni$ в Расширенном алфавите и \scnqq{\scnnonamednode->\scnnonamednode} и \scnqq{\scnnonamednode<-\scnnonamednode} в Базовом алфавите). Другие \textit{sc.s-коннекторы} не используются;
                \item не используются \textit{sc.s-модификаторы} и, соответственно, двоеточия, являющиеся признаком завершения \textit{sc.s-модификаторов};
                \item используются только \textit{простые sc.s-предложения}, которые, как следует из вышеуказанных свойств Ядра SCs-кода, либо состоят из двух \textit{простых sc-идентификаторов}, соединяемых sc.s-коннектором, изображающим константную  постоянную позитивную пару принадлежности, либо трех \textit{простых sc-идентификаторов}, разделенных \textit{sc.s-разделителями, изображающими связь инцидентности sc-элементов}.
            \end{scnitemize}
            Из перечисленных свойств Ядра SCs-кода следует, что для представления (изображения) любого \mbox{sc-текста} средствами Ядра SCs-кода необходимо для \uline{всех} (!) sc-элементов этого \mbox{sc-текста} (кроме константных постоянных позитивных пар принадлежности) построить соответствующие им простые \textit{sc-идентификаторы}, т.е. необходимо проименовать все указанные sc-элементы. В свою очередь, тип каждого используемого \mbox{sc-элемента} (кроме константных постоянных позитивных пар принадлежности) задается явно путем указания принадлежности этих элементов соответствующим классам sc-элементов, в том числе классам, входящим в Ядро SC-кода.Как видно из приведенного описания, Ядро SCs-кода соответствует Ядру SCg-кода, за исключением того, что в Ядре SCg-кода нет необходимости именовать все изображаемые sc-элементы, а также в Ядре SCg-кода присутствуют графические изображения для sc-элементов, принадлежащих соответствующим классам Ядра SC-кода и эту принадлежность нет необходимости указывать явно.}
            \scntext{примечание}{Очевидно, что широко практически применять Ядро SCs-кода для записи больших фрагментов баз знаний неудобно и неэффективно. Тем не менее, с практической точки зрения Ядро SCs-кода может использоваться, например, для обмена информацией со сторонними средствами представления графовых конструкций, рассчитанными на представление информации в виде триплетов (например, RDF-хранилищ).Для обеспечения возможности более широкого практического использования необходимы синтаксические расширения Ядра SCs-кода в целях:
            \begin{scnitemize}
                \item минимизации числа идентифицируемых (именуемых) sc-элементов путем использования \textit{sc-выражений} и ликвидации необходимости идентифицировать (именовать) \uline{все} (!) sc-элементы;
                \item сокращения текста путем минимизации числа повторений одного и того же \textit{sc-идентификатора} путем соединения \textit{sc.s-предложений};
                \item повышение уровня наглядности, читабельности\ sc.s-текстов.
            \end{scnitemize}}
            \scnhaselementrole{пример}{\scnfilelong{\textit{треугольник |- ai >| Треугк(ТчкВ;ТчкС;ТчкD);;\newlineТреугк(ТчкВ;ТчкС;ТчкD) |- bi >| Отр(ТчкВ;ТчкС);;\newlineсторона* |- сi >| bi;;\newlineконстантный постоянный sc-узел, обозначающий класс $\ni$ треугольник;;\newlineконстантный постоянный sc-узел, обозначающий отношение $\ni$ сторона*;;\newlineконстантная постоянная позитивная sc-дуга принадлежности $\ni$ ai;;\newlineконстантная постоянная sc-дуга $\ni$ bi;;\newlineконстантная постоянная позитивная sc-дуга принадлежности $\ni$ ci;;\newlineконстантный постоянный sc-узел общего вида $\ni$ Отр(ТчкВ;ТчкС);;\newlineконстантный постоянный sc-узел общего вида $\ni$ Треугк(ТчкВ;ТчкC;ТчкD);;}}}
            \bigskip
            \begin{scnindent}
                \scnrelboth{семантическая эквивалентность}{\scnfileimage[20em]{Contents/part_kb/images/scs/kernel_incident.png}}
            \end{scnindent}
            
            \scnheader{Первое направление расширения Ядра SCs-кода}
            \scnidtf{Первое направление расширения Ядра SCs-кода \uline{и всех иных его расширений}}
            \scntext{принципы}{По сравнению с \textit{Ядром SCs-кода} в \textit{Первом направлении расширения Ядра SCs-кода} вместо \textit{sc-идентификато|-ров}, являющихся идентификаторами (именами), которые взаимно однозначно соответствуют синонимичным им (представляемым ими) sc-коннекторам, вводятся \textit{sc.s-коннекторы}, каждый из которых соответствует не одному конкретному sc-коннектору, а некоторому классу однотипных sc-коннекторов. Очевидно, что это ликвидирует необходимость \uline{каждому} sc-коннектору приписывать уникальный \textit{sc-идентификатор}. Кроме того, \textit{Алфавит sc.s-коннекторов} включает в себя элементы этого Алфавита (классы \uline{синтаксически} эквивалентных \textit{sc.s-коннекторов}), которые соответствуют \uline{всем} (!) элементам Алфавита sc-коннекторов, но при этом дополнительно включают в себя и другие элементы Алфавита \textit{sc.s-коннекторов}, которые соответствуют часто используемым \uline{семантически} явно выделяемым классам sc-коннекторов. К таким дополнительно вводимым классам \textit{sc.s-коннекторов} относятся \textit{константные sc.s-коннекторы} включения множеств ($\supset$\ или $\subset$), \textit{переменные sc.s-коннекторы} включения множеств ($\_\supset$\ или $\subset\_$), \textit{sc.s-коннектор} синонимии ($=$), \textit{sc.s-коннектор} погружения ($=\subset$\ или $\supset=$) и др.Заметим, что указанное расширение Алфавита \textit{sc.s-коннекторов} аналогично расширенному Алфавиту \textit{sc.g-коннекторов} в SCg-коде и ликвидирует необходимость (как и в SCs-коде) явно специфицировать (средствами SCs-кода) синтаксически выделяемые классы \textit{sc.s-коннекторов}.}
            
            \scnheader{Второе направление расширения Ядра SCs-кода}
            \scntext{принципы}{Во Втором направлении расширения Ядра SCs-кода вводятся модификаторы \textit{sc.s-коннекторов} (\textit{\mbox{sc.s-модификаторы}}), которые позволяют достаточно компактно дополнительно специфицировать \mbox{sc-коннекторы}, изображаемые (представляемые) соответствующими \textit{sc.s-коннекторами}. Речь идет о такой часто востребованной форме спецификации sc-коннекторов, как указание множества (возможно, нескольких множеств), которому принадлежит специфицируемый  sc-коннектор (чаще всего, таким множеством является \textit{бинарное отношение} (в частности, \textit{ролевое отношение}) или \textit{квазибинарное отношение}).}
            
            \scnheader{sc.s-модификатор*}
            \scniselement{отношение}
            \begin{scnindent}
                \scnidtf{относительное понятие}
            \end{scnindent}
            \scnidtf{модификатор sc.s-коннектора*}
            \scntext{пояснение}{\textit{sc-идентификатор}, который (1) находится либо между \textit{sc.s-коннектором} и \textit{двоеточием}, либо между \textit{двоеточиями} и (2) обозначает множество (чаще всего, отношение), которому принадлежит sc-коннектор, изображаемый ближайшим предшествующим \textit{sc.s-коннектором}. Два подряд идущих двоеточия (::) обозначают, что указанное множество связано с указанным sc-коннектором \textit{\uline{переменной} позитивной постоянной sc-дугой принадлежности}.Очевидно, что, если не использовать \textit{sc.s-модификаторы}, указанного вида спецификация sc-коннекторов средствами SCs-кода будет выглядеть значительно более громоздкой.}
            
            \scnheader{Третье направление расширения Ядра SCs-кода}
            \scntext{принципы}{В \textit{Третьем направлении расширения Ядра SCs-кода} осуществляется переход от использования только \textit{простых sc-идентификаторов} к использованию как \textit{простых sc-идентификаторов}, так и \textit{sc-выражений}, а также к использованию \textit{sc.s-представлений некоторых неидентифицируемых sc-узлов}. Это существенно сокращает число придумываемых \textit{простых sc-идентификаторов}, т.к. каждое \textit{sc-выражение} в конечном счете  это комбинация \textit{простых sc-идентификаторов}, построенная по правилам, которые достаточно легко семантически интерпретируются. Если проводить аналогию с SCg-кодом, то очевидно, что \textit{\mbox{sc-выражение}}, ограничиваемое фигурными скобками, есть не что иное, как информационная конструкция, ограничиваемая \textit{sc.g-контуром}, а \textit{sc-выражение}, ограничиваемое квадратными скобками есть не что иное, как информационная конструкция, ограничиваемая \textit{sc.g-рамкой}. Отличие здесь заключается в том, что круглыми и квадратными скобками можно ограничивать только линейные информационные конструкции (цепочки символов).}
            
            \scnheader{sc.s-представление неидентифицируемого sc-узла}
            \scnidtf{изображение (представление) неидентифицируемого (неименуемого) sc-узла в sc.s-тексте}
            \scnidtf{sc.s-обозначение неименуемой сущности, не являющейся парой, обозначаемой sc-коннектором}
            \scnidtf{sc.s-представление sc-узла, не являющееся sc-идентификатором (именем этого sc-узла)}
            \begin{scnreltoset}{разбиение}
                \scnitem{sc.s-обозначение неименуемой структуры}
                \begin{scnindent}
                    \scnidtf{конкатенация левой фигурной скобки и правой фигурной скобки}
                \end{scnindent}
                \scnitem{sc.s-обозначение неименуемой неориентированной связки}
                \begin{scnindent}
                    \scnidtf{конкатенация левой фигурной скобки, дефиса и правой фигурной скобки}
                \end{scnindent}
                \scnitem{sc.s-обозначение неименуемого кортежа}
                \begin{scnindent}
                    \scnidtf{конкатенация левой угловой скобки, дефиса и правой угловой скобки}
                \end{scnindent}
                \scnitem{sc.s-обозначение неименуемого файла-экземпляра}
                \begin{scnindent}
                    \scnidtf{конкатенация левой квадратной скобки и правой квадратной скобки}
                \end{scnindent}
                \scnitem{sc.s-обозначение неименуемого файла-класса}
                \begin{scnindent}
                    \scnidtf{конкатенация восклицательного знака, левой квадратной скобки и правой квадратной скобки}
                \end{scnindent}
                \scnitem{sc.s-обозначение неименуемой терминальной сущности}
                \begin{scnindent}
                    \scnidtf{конкатенация левой круглой скобки, буквы о\ и правой круглой скобки}
                \end{scnindent}
            \end{scnreltoset}
            \scntext{примечание}{Если одно и то же обозначение неименуемой сущности встречается в \uline{разных} \textit{sc.s-предложениях}, то считается, что это обозначения \uline{разных} сущностей, т.е. изображения \uline{разных} sc-узлов.}
            
            \scnheader{Четвертое направление расширения Ядра SCs-кода}
            \scntext{принципы}{В \textit{Четвертом направлении расширения Ядра SCs-кода} осуществляется переход от использования только \textit{простых sc.s-предложений} к использованию также \textit{sc.s-предложений}, построенных с помощью \textit{\mbox{Операции} присоединения sc.s-предложения*}. В результате этого, благодаря склеиванию\ одинаковых \textit{\mbox{sc-идентификаторов}}, а также склеиванию\ синтаксически эквивалентных \textit{\mbox{sc.s-коннекторов}} с одинаковыми \textit{\mbox{sc.s-модификаторами}} (несмотря на то, что эти склеиваемые\ \textit{sc.s-коннекторы} соответствуют \uline{разным} \mbox{sc-коннекторам}), существенно сокращается число копий используемых \textit{\mbox{sc-идентификаторов}} и \textit{\mbox{sc.s-коннекторов}} с их \textit{\mbox{sc.s-модификаторами}}.}
            
            \newpage\scnheader{Пятое направление расширения Ядра SCs-кода}
            \scntext{принципы}{В \textit{Пятом направлении расширения Ядра SCs-кода} разрешается использование \textit{присоединенных \mbox{sc.s-предложений}}. В результате этого \textit{sc.s-тексты} становятся более компактными и удобными для восприятия за счет снижения числа дублируемых \textit{sc-идентификаторов} и более широких возможностей их структуризации.}
            
            \scnheader{следует отличать*}
            \begin{scnhaselementset}
                \scnitem{sc.s-представление неидентифицируемого sc-узла}
                \scnitem{sc.s-коннектор}
                \begin{scnindent}
                    \scnidtf{sc.s-представление неидентифицируемого sc-коннектора}
                \end{scnindent}
            \end{scnhaselementset}
            \bigskip
            \begin{scnhaselementset}
                \scnitem{sc-коннектор}
                \scnitem{sc.s-коннектор}
            \end{scnhaselementset}
            \bigskip
            \begin{scnhaselementset}
                \scnitem{sc.s-коннектор}
                \scnitem{sc.s-модификатор*}
                \begin{scnindent}
                    \scnidtf{модификатор sc.s-коннектора*}
                    \scniselement{отношение}
                \end{scnindent}
            \end{scnhaselementset}
            \bigskip
            \begin{scnhaselementset}
                \scnitem{sc.s-коннектор}
                \scnitem{Правила построения sc.s-коннекторов}
            \end{scnhaselementset}
            \bigskip
            \begin{scnhaselementset}
                \scnitem{sc.s-предложение}
                \scnitem{Правила построения sc.s-предложений}
            \end{scnhaselementset}
            \bigskip
            \begin{scnhaselementset}
                \scnitem{sc.s-коннектор}
                \scnitem{sc.g-коннектор}
            \end{scnhaselementset}
            \bigskip
            \begin{scnhaselementset}
                \scnitem{sc.s-текст}
                \scnitem{sc.g-текст}
            \end{scnhaselementset}
            \input{Contents/part_kb/intro_lang/intro_scs_transf_examples.tex}
            \bigskip
        \end{scnsubstruct}
        \scnendsegmentcomment
        \bigskip
    \end{scnsubstruct}
\end{scnsubstruct}
\scnendcurrentsectioncomment
\end{SCn}
