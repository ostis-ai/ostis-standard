\begin{SCn}
	
\scnsectionheader{\currentname}

\scnstartsubstruct
/*2.3.4. RDF Schema***********************************/
\scnheader{RDFS}
\scnidtf{RDF Schema}
\scnidtf{RDF/S}
\scnidtf{RDF-S}
\scnidtf{RDF(S)}
\scnidtf{RDF Schema}
\scnidtf{набор классов и свойств для модели представления знаний RDF, составляющий основу для описания онтологий с использованием расширенного RDF-словаря}

\scnnote{RDFS использует кодирование в виде RDF, то есть позволяет описать сами RDF-триплеты подобно описаниям других RDF-ресурсов}

\scntext{особенность}{RDFS является базовых словарем, на основе которого строится большинство других словарей, включая язык OWL}

\scnrelfrom{классы}{Классы RDFS\\
	\scniselement{rdfs:Resource\\
		\scnaddlevel{1}
			\scnidtf{класс, включающий все ресурсы, то есть, всё, что описывает RDF}
		\scnaddlevel{-1}
	}
	\scniselement{rdfs:Class\\
		\scnaddlevel{1}
			\scnidtf{описывает что ресурс является классом (типом) ресурса. Для отнесения ресурса к типу используется свойство \textit{rdf:type}
			}
		\scnaddlevel{-1}
	}
	\scniselement{rdfs:Literal\\
		\scnaddlevel{1}
			\scnidtf{обозначает литерал (строка, смысл которой уточняется отдельно при помощи IRI типа данных}
			\scnnote{Литералы могут быть простыми (plain, например, число) или иметь некоторый тип}
		\scnaddlevel{-1}
	}
	\scniselement{rdfs:Datatype\\
		\scnaddlevel{1}
			\scnidtf{класс типов данных}
			\scntext{особенность}{Является одновременно и подклассом \textit{rdfs:Class}, и экземпляром из \textit{rdfs:Class}. Каждый экземпляр класса \textit{rdfs:Datatype} является подклассом \textit{rdfs:Literal}}	
		\scnaddlevel{-1}
	}
	\scniselement{rdf:XMLLiteral\\
		\scnaddlevel{1}
			\scnidtf{класс XML-литералов, является экземпляром \textit{rdfs:Datatype}
			}
		\scnaddlevel{-1}
	}
	\scniselement{rdf:Property\\
		\scnaddlevel{1}
			\scnidtf{класс свойств (отношений)}
		\scnaddlevel{-1}
	}
}
\scnrelfrom{свойства}{Свойства RDFS\\
	\scnidtf{описывают отношения между ресурсами-субъектами и ресурсами-объектами и являются экземплярами класса \textit{rdf:Property}, и выступают в качестве предикатов в RDF-триплетах}
	\scnrelfrom{включение}{метасвойства RDFS}\\
	\scnaddlevel{1}
	\scntext{особенность}{могут описывать свойства самих предикатов}
	\scniselement{rdfs:domain\\
		\scnaddlevel{1}
			\scnidtf{объявляет класс субъекта (первый домен отношения)}
			\scntext{пример}{ex:employer rdfs:domain foaf:Person\\
				ex:employer rdfs:range foaf:Organization\\
				ex:John ex:employer ex:CompanyX
			}
			\scnaddlevel{1}
				\scnnote{В этом примере пространство имен ex: означает, что это пример}
			\scnaddlevel{-1}
		\scnaddlevel{-1}
	}
	\scniselement{rdfs:range\\
		\scnaddlevel{1}
			\scnidtf{объявляет класс или тип данных объекта (второй домен отношения)}
			\scntext{пример}{ex:employer rdfs:domain foaf:Person\\
				ex:employer rdfs:range foaf:Organization\\
				ex:John ex:employer ex:CompanyX
			}
			\scnaddlevel{1}
				\scnnote{В этом примере пространство имен ex: означает, что это пример}
			\scnaddlevel{-1}
		\scnaddlevel{-1}
	}
	\scniselement{rdf:type\\
		\scnaddlevel{1}
			\scnidtf{декларирует принадлежность ресурса некоторому классу, то есть, тот факт, что ресурс является экземпляром класса}
			\scntext{пример}{ex:John ex:type foaf:Person}
		\scnaddlevel{-1}
	}
	\scniselement{rdfs:subClassOf\\
		\scnaddlevel{1}
			\scnidtf{свойство, позволяющее описать иерархию классов}
			\scntext{пример}{foaf:Person rdfs:subClassOf foaf:Agent}
		\scnaddlevel{-1}
	}
	\scniselement{rdfs:subPropertyOf\\
		\scnaddlevel{1}
			\scnidtf{свойство, которое утверждает, что все ресурсы, связанные некоторым подсвойством (subproperty), связаны также и свойством}
		\scnaddlevel{-1}
	}
	\scniselement{rdfs:label
		\scnaddlevel{1}
			\scnidtf{задает удобные для человека имя и описание ресурса (на естественном языке)}
		\scnaddlevel{-1}
	}
	\scniselement{rdfs:comment
		\scnaddlevel{1}
			\scnidtf{задает удобные для человека имя и описание ресурса (на естественном языке)}
		\scnaddlevel{-1}
	}
	\scnaddlevel{-1}
}
\scnrelfrom{вспомогательные свойства}{Вспомогательные свойства RDFS\\
	\scnnote{К вспомогательным относятся свойства, не имеющие семантики вывода, т.е. семантика этих свойств зависит от конкретных приложений, интерпретирующих RDFS}
	\scniselement{rdfs:seeAlso\\
		\scnaddlevel{1}
			\scnidtf{указывает ресурс, который может служить источников дополнительной информации о ресурсе-субъекте}
		\scnaddlevel{-1}
	}
	\scniselement{rdfs:isDefinedBy\\
		\scnaddlevel{1}
			\scnidtf{указывает на ресурс (например, RDF-словарь), который описывает ресурс-субъект}
		\scnaddlevel{-1}
	}
}
\scnrelto{ключевой знак}{\scncite{RDFSDescription}}
/*2.3.4. RDF Schema***********************************/\\
/*2.6. Языки описания логических высказываний***********************************/
\scnheader{Языки описания логических высказываний}
\scntext{особенность}{Для записи логических высказываний в языках семейства Semantic Web используется соответствующий набор понятий, определяемых соответствующими онтологиями, например в рамках семейства SWAP}
\scnaddlevel{1}
\scnnote{имеются в виду те классы высказываний, которые не накрываются стандартизированными отношениями в рамках соответствующего языка, например OWL 2}
\scnaddlevel{-1}
\scntext{особенность}{Для записи логических переменных используется механизм именования переменных, рассмотренный в разделе Нотация N3. (?x либо \_:x). На переменные могут накладываться кванторы, рассмотренные в том же разделе. Для связи между собой атомарных высказываний может использоваться механизм формул, также рассмотренный в указанном разделе}
\scnnote{Иногда для записи логических высказываний используется менее громоздкий синтаксис языка KIF, особенно в случае, когда сформированный таким образом набор высказываний выкладывается где-либо в открытом источнике как многократно используемый компонент}
\scntext{пример}{
	(subclass RailVehicle LandVehicle) /*ЖД транспорт - подкласс наземного*/\\
	(documentation RailVehicle\\
	"A Vehicle designed to move on \&\%Railways.") /*ЕЯ-формулировка*/\\
	(=>  (instance ?X RailVehicle) /*Если Х - ЖД транспорт, то */\\
	(hasPurpose ?X  /* Х предназначен для случаев когда */\\
	(exists (?EV ?SURF)\\
	(and  (instance ?RAIL Railway) /* существуют рельсы и */\\
	(instance ?EV Transportation) /* существует перемещение */\\
	(holdsDuring (WhenFn ?EV) /* которое происходит */\\
	(meetsSpatially ?X ?RAIL)))))) /* когда Х контактирует с рельсами */
}
\scnaddlevel{1}
\scniselement{префиксная запись KIF}
\scnaddlevel{-1}
\scniselement{SWRL}
\scnaddlevel{1}
\scnidtf{язык SWRL основан на объединении языков OWL DL и OWL Lite с ограниченной версией (подъязыком) языка RuleML, который разрабатывался как язык описания логических правил для различных целей и, в свою очередь, является подъязыком языка логического программирования Datalog, который, в свою очередь, является подъязыком языка Prolog}

\scnnote{SWRL изначально разрабатывался в рамках проекта по разработке языка DAML, который являлся предтечей языков описания онтологий в рамках Semantic Web}

\scntext{особенность}{SWRL дополняет OWL DL возможностью записи логических правил в человеко-читабельном (Хорновском) стиле. При этом SWRL не добавляет каких-либо принципиальных отличий в плане выразительной мощности}
\scntext{пример}{hasParent(?x1,?x2) ∧ hasBrother(?x2,?x3) ⇒ hasUncle(?x1,?x3)}
\scnaddlevel{1}
	\scnexplanation{Данная запись определяет отношение “быть дядей”}
\scnaddlevel{-1}
\scntext{пример}{Student(?x1) ⇒ Person(?x1)}
\scnaddlevel{1}
	\scnexplanation{Данная запись гласит, что каждый студент является персоной. Очевидно, что та же информация может быть записана без явного использования логических правил при помощи отношения owl:subClassOf}
\scnaddlevel{-1}
\scnnote{Тексты на SWRL с точки зрения синтаксиса могут быть записаны в тех же форматах, что и тексты OWL, например OWL XML (на основе RDF$\backslash$XML) и других}
\scnaddlevel{-1}
\scnrelto{ключевой знак}{\scncite{SWRLDescription}}
/*2.6. Языки описания логических высказываний***********************************/\\
/*Выводы к разделу 2/\\
\scntext{выводы к разделу}{\begin{scnitemize}
		\item В рассмотренных языках никак не рассматриваются проблемы представления не-факторов (нечеткости, нестационарности, недостоверности информации)
		\item Возникают проблемы с формальной трактовкой некоторых языковых средств, например, не совсем понятно, как трактуется формула в N3.  Как следствие, механизм формул и вообще средства структуризации баз знаний используются достаточно редко
		\item Не существует простой и однозначной формы записи некоторых языковых средств, таких как формулы и коллекции в N3 на нижнем уровне (например, средствами чистого RDF), что также препятствует их широкому использованию. Например, по этой причине такие конструкции приходится явно учитывать при реализации хранилищ и средств доступа к ним
		\item Несмотря на изначально простой абстрактный синтаксис RDF и языков на его основе, в реальной практике работа как правило ведется на уровне исходного текста, записанного в какой-то из форм представления, например RDF$\backslash$XML. Разработчики каждой конкретной системы сами определяют, каким образом эти тексты преобразуются во внутреннее представление в системе. Соответственно принципы обработки этой информации в общем случае не стандартизируются (см. раздел Обработка информации)
		\item Отсутствует какая-либо строгая и одновременно простая формальная база для представления информации (ядро, инвариант представления), которая была бы универсальной и на основе которой строились бы все остальные средства. В данной роли фактически выступает RDF, но он в полной мере не отвечает ни требованию универсальности, ни требованию формальности
		\item Не выделено каких-либо базовых отношений, которые бы записывались на уровне синтаксиса базового языка. Все отношения приходится указывать явно
		\item Таким образом, рассмотренные стандарты позволяют структурировать информационное пространство, облегчить поиск нужной информации, обеспечить согласованность описания ресурсов различными авторами, т.е. успешно решают те задачи, для которых они создавались, но не могут рассматриваться как универсальные языки представления информации любого рода в базах знаний
	\end{scnitemize}
}
\scnendstruct
	
\end{SCn}