\begin{SCn}
	\ActivateBG
	\section*{§ 3.3.3. Внутренние агенты, выполняющие действия в sc-памяти – sc-агенты }
	\begin{scnrelfromlist}{ключевое понятие}
		\scnitem{sc-агент}
		\scnitem{абстрактный sc-агент}
		\scnitem{атомарный абстрактный sc-агент}
		\scnitem{неатомарный абстрактный sc-агент}
		\scnitem{абстрактный sc-агент, реализуемый на Языке SCP}
		\scnitem{абстрактный sc-агент, не реализуемый на Языке SCP}
	\end{scnrelfromlist}
	\scnheader{решатель задач ostis-системы}
	\scntext{примечание}{Предлагается делить на компоненты, соответствующие
		классам логически атомарных действий в sc-памяти, называемые sc-агентами.}
	\scnheader{sc-агент}
	\scnidtf{Единственный вид субъектов, выполняющих преобразования в sc-памяти}
	\scnidtf{Субъект, способный выполнять действия в sc-памяти, принадлежащие некоторому определенному классу
		логически атомарных действий}
	\begin{scnrelfromset}{функции}
		\scnitem{реагирует на
			соответствующий ему класс ситуаций и/или событий, происходящих в sc-памяти}
		\scnitem{осуществляет определенное
			преобразование sc-текста, находящегося в семантической окрестности обрабатываемой ситуации и/или события}
		
		\scnitem{осуществляет взаимодействие с другими sc-агентами исключительно посредством
			формирования некоторых конструкций в общей sc-памяти}
	\end{scnrelfromset}
	\scntext{свойство}{Не имеет информацию о том, какие еще sc-агенты в данный момент
		присутствуют в системе.}
	\scnheader{абстрактный sc-агент}
	\scnidtf{Некоторый
		класс функционально эквивалентных sc-агентов, разные экземпляры (то есть представители) которого могут быть
		реализованы по-разному}
	\begin{scnrelfromset}{разбиение}
		\scnitem{неатомарный абстрактный sc-агент}
		\begin{scnindent}
			\scnidtf{Абстрактный sc-агент, который декомпозируется на коллектив более простых абстрактных sc-агентов, каждый из которых в свою очередь может быть как атомарным абстрактным sc-агентом, так и неатомарным абстрактным sc-агентом}
			\scntext{примечание}{При этом в каком либо
				варианте декомпозиции абстрактного sc-агента* дочерний неатомарный абстрактный sc-агент может стать
				атомарным абстрактным sc-агентом, и реализовываться соответствующим образом.}
		\end{scnindent}
		\scnitem{атомарный абстрактный sc-агент}
		\begin{scnindent}
			\scnidtf{Абстрактный sc-агент, для которого уточняется способ его реализации, то есть существует соответствующая связка отношения программа sc-агента}
			\scntext{примечание}{При этом, что в рамках конкретной ostis-системы для каждого языка представления методов может существовать
				своя иерархия абстрактных sc-агентов}
		\end{scnindent}
	\end{scnrelfromset}
	\begin{scnrelfromset}{спецификация}
		\scnitem{указание ключевых sc-элементов этого sc-агента}
		\begin{scnindent}
			\scnidtf{Указание тех sc-элементов, хранимых в sc-памяти, которые
				для данного sc-агента являются «точками опоры»}
		\end{scnindent}
		\scnitem{формальное описание условий инициирования данного sc-агента}
		\begin{scnindent}
			\scnidtf{Формальное описание тех ситуаций в sc-памяти, которые
				инициируют деятельность данного sc-агента}
		\end{scnindent}
		\scnitem{формальное описание первичного условия инициирования данного sc-агента}
		\begin{scnindent}
			\scnidtf{Формальное описание такой ситуации в sc-памяти, которая побуждает sc-агента перейти в активное состояние и начать проверку наличия своего
				полного условия инициирования (для внутренних абстрактных sc-агентов)}
		\end{scnindent}
		\scnitem{строгое, полное, однозначно понимаемое описание деятельности данного sc-агента, оформленное при помощи каких-либо понятных, общепринятых средств, не требующих специального изучения, например на
			естественном языке}
		\scnitem{описание результатов выполнения данного sc-агента}
	\end{scnrelfromset}
	\begin{scnrelfromset}{реализация}
		\scnitem{посредством указания конкретного метода (программы sc-агента)}
		\scnitem{посредством декомпозиции абстрактного sc-агента на более простые}
	\end{scnrelfromset}
	\begin{scnrelfromset}{разбиение}
		\scnitem{внутренний абстрактный sc-агент}
		\begin{scnindent}
			\scnidtf{Класс sc-агентов, которые реагируют на события в
				sc-памяти и осуществляют преобразования исключительно в рамках этой же sc-памяти}
		\end{scnindent}
		\scnitem{эффекторный абстрактный sc-агент}
		\begin{scnindent}
			\scnidtf{Класс sc-агентов, которые реагируют на события в
				sc-памяти и осуществляют преобразования во внешней относительно данной ostis-системы среде}
		\end{scnindent}
		\scnitem{рецепторный абстрактный sc-агент}
		\begin{scnindent}
			\scnidtf{Класс sc-агентов, которые реагируют на события во
				внешней относительно данной ostis-системы среде и осуществляют преобразования в памяти данной системы}
		\end{scnindent}
	\end{scnrelfromset}
	\begin{scnrelfromset}{разбиение}
		\scnitem{абстрактный sc-агент, не реализуемый на Языке SCP}
		\scnitem{абстрактный sc-агент, реализуемый на Языке SCP}
	\end{scnrelfromset}
	\begin{scnrelfromset}{разбиение}
		\scnitem{абстрактный sc-агент интерпретации scp-программ}
		\scnitem{абстрактный программный sc-агент}
		\scnitem{абстрактный sc-метаагент}
	\end{scnrelfromset}
	\begin{scnrelfromset}{разбиение}
		\scnitem{платформенно-зависимый абстрактный sc-агент}
		\begin{scnindent}
			\scnsuperset{абстрактный sc-агент, не реализуемый на Языке SCP}
		\end{scnindent}
		\scnitem{платформенно-независимый абстрактный sc-агент}
	\end{scnrelfromset}
	\scnheader{иерархия}
	\scnsuperset{иерархия методов}
	\begin{scnindent}
		\scnidtf{Методы интерпретации других методов}
	\end{scnindent}
	\scnsuperset{иерархия навыков}
	\scnsuperset{иерархия sc-агентов}
	\begin{scnindent}
		\scntext{аспект}{Абстрактные sc-агенты иногда целесообразно объединять в коллективы таких агентов, которые можно рассматривать как один целостный абстрактный sc-агент, с логической точки зрения работающий по тем же
			принципам, что и атомарные абстрактные sc-агенты, то есть реагирующий на события в sc-памяти и описывающий свою деятельность в рамках этой памяти. Такому абстрактному sc-агенту не будет соответствовать
			какой-то конкретный метод, хранимый в sc-памяти, но остальная часть спецификации абстрактного sc-агента (условие инициирования, описание начальной ситуации и результата работы sc-агента и так далее)
			остается такой же, как у атомарного абстрактного sc-агента.}
		\scntext{аспект}{Cоответствующий sc-агенту метод должен интерпретироваться каким-либо другим sc-агентом более низкого уровня, а чаще всего – коллективом таких агентов, каждому из которых ставится
			в соответствие свой метод, описывающий поведение данного агента, но уже на более низком уровне. В общем случае
			такая иерархия тоже может иметь неограниченное число уровней, однако очевидно, что при понижении уровня языка описания методов мы рано или поздно должны подойти к языку описания методов, который будет
			интерпретироваться агентами, реализуемыми на уровне ostis-платформы, а спускаясь еще ниже – на уровень
			языка описания методов, интерпретируемых на аппаратном уровне.}
		\scntext{преимущество}{Обеспечение модифицируемости решателей}
		\scntext{преимущество}{Удобство проектирования решателей и отладки на разных уровнях}
		\scnrelfrom{рисунок}{\scnfileimage[40em]{Contents/part_ps/src/images/6.png}}
	\end{scnindent}
	
	\scnheader{Язык SCP (Semantic Code Programming)}
	\scnidtf{Ассемблер для ассоциативного семантического компьютера}
	\scnheader{абстрактный sc-агент, не реализуемый на Языке SCP}
	\scnidtf{Абстрактный sc-агент, который не может быть реализован на платформенно-независимом уровне}
	\begin{scnrelfromset}{разбиение}
		\scnitem{эффекторный абстрактный sc-агент}
		\scnitem{рецепторный абстрактный sc-агент}
		\scnitem{абстрактный sc-агент интерпретации scp-программ}
	\end{scnrelfromset}
	\scnheader{абстрактный sc-агент, реализуемый на Языке SCP}
	\scnidtf{Абстрактный sc-агент, который может быть реализован на платформенно-независимом уровне}
	\begin{scnrelfromset}{разбиение}
		\scnitem{абстрактный sc-метаагент}
		\begin{scnindent}
			\scntext{задача}{Координация деятельности абстрактных программных sc-агентов, в частности, решение проблемы взаимоблокировок}
			\scntext{примечание}{Агенты данного класса могут быть реализованы
				на Языке SCP, однако для синхронизации их деятельности используются другие принципы, соответственно,
				для реализации таких агентов требуется Язык SCP другого уровня, типология операторов которого полностью
				аналогична типологии scp-операторов, однако эти операторы имеют другую операционную семантику, учитывающую отличия в принципах синхронизации (работы с блокировками*).}
			\scnsuperset{scp-метапрограммы}
			\begin{scnindent}
				\scnidtf{Программы такого языка}
			\end{scnindent}
			\scnsuperset{scp-метапроцессы}
			\begin{scnindent}
				\scnidtf{Соответствующие им процессы в sc-памяти}
			\end{scnindent}
			\scnsuperset{scp-метаоператоры}
			\begin{scnindent}
				\scnidtf{Соответствующие им операторы в sc-памяти}
			\end{scnindent}
		\end{scnindent}
		\scnitem{абстрактный программный sc-агент, реализуемый на Языке SCP}
	\end{scnrelfromset}
	\scnheader{абстрактный программный sc-агент}
	\begin{scnrelfromset}{разбиение}
		\scnitem{эффекторный абстрактный sc-агент}
		\scnitem{рецепторный абстрактный sc-агент}
		\scnitem{абстрактный программный sc-агент, реализуемый на Языке SCP}
	\end{scnrelfromset}
	\scnheader{атомарный абстрактный sc-агент}
	\begin{scnrelfromset}{разбиение}
		\scnitem{платформенно-независимый абстрактный sc-агент}
		\begin{scnindent}
			\scnsuperset{атомарные абстрактные sc-агенты, реализованные на Языке SCP}
		\end{scnindent}
		\scnitem{платформенно-зависимый абстрактный sc-агент}
		\begin{scnindent}
			\scnsuperset{атомарные абстрактные sc-агенты, реализованные ниже уровня sc-моделей, то есть не на Языке SCP, а на каком-либо другом языке описания программ}
		\end{scnindent}
	\end{scnrelfromset}
	\scnheader{платформенная независимость}
	\scnidtf{Реализация на специализированном языке программирования, ориентированном на обработку семантических сетей (Языке SCP), поскольку
		атомарные sc-агенты, реализованные на указанном языке могут свободно переноситься с одной ostis-платформы на другую}
	\scnheader{абстрактный sc-агент интерпретации scp-программ}
	\scnidtf{Не реализуемый на платформенно-независимом уровне абстрактный sc-агент, обеспечивающий интерпретацию scp-программи scp-метапрограмм,
		в том числе создание scp-процессов, собственно интерпретацию scp-операторов, а также другие вспомогательные
		действия}
	\scntext{задача}{Обеспечение работы sc-агентов более высоких уровней (программных
		sc-агентов и sc-метаагентов), реализованных на Языке SCP, в частности, обеспечивают соблюдение указанными
		агентами общих принципов синхронизации}
	\scnheader{абстрактные программные sc-агенты}
	\scnidtf{Все абстрактные sc-агенты, обеспечивающие основной
		функционал системы, то есть ее возможность решать те или иные задачи}
	\scntext{задача}{Обеспечение работы в соответствии с общими принципами синхронизации деятельности субъектов в sc-памяти}
	
	\scnheader{декомпозиция абстрактного sc-агента*}
	\scniselement{отношение декомпозиции}
	\scntext{уточнение}{Трактует неатомарные абстрактные sc-агенты как коллективы более простых абстрактных sc-агентов, взаимодействующих через sc-память.}
	\scntext{уточнение}{На абстрактные sc-агенты более низкого уровня
		уточняет один из возможных подходов к реализации этого абстрактного sc-агента путем построения коллектива
		более простых абстрактных sc-агентов.}
	\scnheader{sc-агент}
	\scnidtf{Конкретный экземпляр (с теоретико-множественной точки зрения - элемент) некоторого атомарного абстрактного sc-агента, работающий в какой-либо конкретной интеллектуальной системе.}
	\scnidtf{Субъект, способный выполнять некоторый класс однотипных действий либо
		только над sc-памятью, либо над sc-памятью и внешней средой (для эффекторных sc-агентов)}
	\scntext{взаимодействие}{Осуществляется только через sc-память.}
	\scntext{результат}{Некоторое изменение состояния sc-памяти, то есть удаление либо генерация каких-либо sc-элементов}
	\scntext{примечание}{В общем случае один sc-агент может явно передать управление другому sc-агенту, если этот sc-агент априори
		известен. Для этого каждый sc-агент в sc-памяти имеет обозначающий его sc-узел, с которым можно связать
		конкретную ситуацию в текущем состоянии базы знаний, которую инициируемый sc-агент должен обработать.}
	\scntext{функция}{Может сам для себя порождать вспомогательные sc-элементы, которые сам же удаляет
		после завершения акта своей деятельности (это вспомогательные структуры, которые используются в качестве
		"информационных лесов" только в ходе выполнения соответствующего акта деятельности и после завершения
		этого акта удаляются).}
	\scnsuperset{активный sc-агент}
	\begin{scnindent}
		\scnidtf{Sc-агент ostis-системы, который реагирует на события, соответствующие
			его условию инициирования, и, как следствие, его первичному условию инициирования*}
		\scntext{примечание}{Не входящие во множество
			активных sc-агентов sc-агенты не реагируют ни на какие события в sc-памяти.}
	\end{scnindent}
	\begin{scnrelfromlist}{первый домен}
		\scnitem{ключевые sc-элементы sc-агента*}
		\begin{scnindent}
			\scntext{функция}{Связывают между собой sc-узел, обозначающий абстрактный sc-агент и sc-узел, обозначающий множество sc-элементов, которые являются ключевыми для данного
				абстрактного sc-агента, то данные sc-элементы явно упоминаются в рамках программ, реализующих данный абстрактный sc-агент.}
		\end{scnindent}
		\scnitem{программа sc-агента*}
		\begin{scnindent}
			\scntext{функция}{Связывают между собой sc-узел, обозначающий атомарный абстрактный sc-агент и sc-узел, обозначающий множество программ, реализующих указанный атомарный абстрактный
				sc-агент.}
		\end{scnindent}
		\scnitem{первичное условие инициирования*}
		\begin{scnindent}
			\scntext{описание}{Связки связывают между собой sc-узел, обозначающий абстрактный sc-агент и бинарную ориентированную пару, описывающую первичное условие инициирования данного абстрактного sc-агента, то есть такую спецификацию ситуации в sc-памяти, возникновение которой побуждает sc-агента перейти в активное состояние и начать проверку наличия своего полного условия инициирования.}
			\scnsuperset{ориентированная пара}
			\begin{scnindent}
				\begin{scnrelfromset}{разбиение}
					\scnitem{первый компонент}
					\begin{scnindent}
						\scnidtf{Знак некоторого класса элементарных событий в
							sc-памяти*.}
					\end{scnindent}
					\scnitem{второй компонент}
					\begin{scnindent}
						\scnidtf{Произвольный sc-элемент, с которым
							непосредственно связан указанный тип события в sc-памяти.}
						\begin{scnrelfromset}{разбиение}
							\scnitem{sc-элемент, из которого выходит
								либо в который входит генерируемая либо удаляемая sc-дуга}
							\scnitem{файл, содержимое которого было изменено}
						\end{scnrelfromset}
					\end{scnindent}
				\end{scnrelfromset}
			\end{scnindent}
		\end{scnindent}
		\scnitem{условие инициирования и результат*}
		\begin{scnindent}
			\scntext{описание}{Связки связывают между собой sc-узел, обозначающий
				абстрактный sc-агент и бинарную ориентированную пару, связывающую условие инициирования данного абстрактного sc-агента и результаты выполнения экземпляров данного sc-агента в какой-либо конкретной
				системе.}
			\scnsuperset{ориентированная пара}
			\begin{scnindent}
				\scnidtf{Логическая связка импликации, при этом на
					sc-переменные, присутствующие в обеих частях связки, неявно накладывается квантор всеобщности, на sc-переменные, присутствующие либо только в посылке, либо только в заключении неявно накладывается квантор
					существования.}
				\begin{scnrelfromset}{разбиение}
					\scnitem{первый компонент}
					\begin{scnindent}
						\scnidtf{Логическая формула, описывающая условие
							инициирования описываемого абстрактного sc-агента, то есть конструкции, наличие которой в sc-памяти побуждает sc-агент начать работу по изменению состояния sc-памяти.}
					\end{scnindent}
					\scnitem{второй компонент}
					\begin{scnindent}
						\scnidtf{Логическая формула, описывающая возможные
							результаты выполнения описываемого абстрактного sc-агента, то есть описание произведенных им изменений
							состояния sc-памяти.}
					\end{scnindent}
				\end{scnrelfromset}
			\end{scnindent}
		\end{scnindent}
	\end{scnrelfromlist}
	
	\begin{scnrelfromset}{разбиение}
		\scnitem{платформенно-независимый абстрактный sc-агент}
		\begin{scnindent}
			\scntext{описание}{Каждая связка отношения программа sc-агента* связывает sc-узел, обозначающий указанный абстрактный sc-агент с множеством scp-программ,
				описывающих деятельность данного абстрактного sc-агента.}
			\scntext{примечание}{Данное множество содержит одну агентную scp-программу, и произвольное количество scp-программ, которые необходимы для выполнения указанной агентной scp-программы.}
		\end{scnindent}
		\scnitem{платформенно-зависимый абстрактный sc-агент}
		\begin{scnindent}
			\scntext{описание}{Каждая связка отношения программа sc-агента*
				связывает sc-узел, обозначающий указанный абстрактный sc-агент с множеством файлов, содержащих исходные тексты программы на некотором внешнем языке программирования, реализующей деятельность данного
				абстрактного sc-агента.}
		\end{scnindent}
	\end{scnrelfromset}
	
	\scnheader{описание поведения sc-агента}
	\scnidtf{Cемантическая окрестность, описывающая деятельность
		sc-агента до какой-либо степени детализации, однако такое описание должно быть строгим, полным и однозначно
		понимаемым.}
	\scntext{примечание}{Может быть протранслировано на естественный язык.}
	
	
	
	
	
	\section*{§ 3.3.4. Принципы синхронизации деятельности sc-агентов}
	\begin{scnrelfromlist}{ключевое понятие}
		\scnitem{действие в sc-памяти}
		\scnitem{блокировка*}
		\scnitem{тип блокировки}
		\scnitem{планируемая блокировка*}
		\scnitem{приоритет блокировки*}
		\scnitem{удаляемые sc-элементы*}
		\scnitem{транзакция в sc-памяти}
	\end{scnrelfromlist}
	\scnheader{многоагентный подход}
	\scntext{особенность}{Возможность параллельного решения различных задач, что в свою очередь, предполагает параллельность выполнения соответствующих
		информационных процессов.}
	\scnheader{действие в sc-памяти}
	\scntext{часто используемый sc-идентификатор}{процесс в sc-памяти}
	\scnheader{процесс в sc-памяти}
	\scnidtf{Информационный процесс, выполняемый агентом в семантической памяти.}
	\begin{scnrelfromset}{разбиение}
		\scnitem{процесс в sc-памяти, соответствующий платформенно-зависимому sc-агенту}
		\begin{scnindent}
			\begin{scnrelfromset}{разбиение}
				\scnitem{процесс в sc-памяти, соответствующий платформенно-зависимому sc-агенту и не являющийся
					действием абстрактной scp-машины}
				\scnitem{действие абстрактной scp-машины}
				\begin{scnindent}
					\scnsuperset{действие интерпретации scp-программы}
				\end{scnindent}
			\end{scnrelfromset} 
		\end{scnindent}
		\scnitem{scp-процесс}
		\begin{scnindent}
			\begin{scnrelfromset}{разбиение}
				\scnitem{scp-процесс, не являющийся scp-метапроцессом}
				\scnitem{scp-метапроцесс}
			\end{scnrelfromset} 
		\end{scnindent}
	\end{scnrelfromset} 
	\scnheader{блокировка*}
	
	\scnidtf{Отношение, связывающее знаки действий в sc-памяти со знаками структур (ситуативных), которые
		содержат элементы, заблокированные на время выполнения данного действия или на какую-то часть этого периода.}
	\begin{scnrelfromset}{разбиение}
		\scnitem{первый компонент}
		\begin{scnindent}
			\scnidtf{Знак действия в sc-памяти.}
		\end{scnindent}
		\scnitem{второй компонент}
		\begin{scnindent}
			\scnidtf{Знак
				заблокированной структуры.}
		\end{scnindent}
	\end{scnrelfromset}
	\scnheader{SCg-текст. Пример использования блокировок}
	\scneq{\scnfileimage[40em]{Contents/part_ps/src/images/5.png}} 
	\scnheader{тип блокировки}
	\scntext{описание}{Множество содержит все возможные классы блокировок, то есть структуры, содержащие sc-элементы, заблокированные каким-либо sc-агентом на время выполнения им некоторого действия в sc-памяти.}
	\begin{scnrelfromset}{разбиение}
		\scnitem{полная блокировка}
		\begin{scnindent}
			\scntext{свойство}{Каждой полной блокировке соответствует петля принадлежности, связывающая ее знак с самим собой.}
			\scnsuperset{структура}
			\begin{scnindent}
				\scnsuperset{sc-элемент}
				\begin{scnindent}
					\begin{scnrelfromlist}{запрещено  всем sc-агентам, кроме собственно sc-агента}
						\scnitem{просмотр sc-элементов}
						\scnitem{удаление инцидентных sc-коннекторов}
						\scnitem{добавление инцидентных sc-коннекторов}
						\scnitem{удаление самих sc-элементов}
						\scnitem{изменение содержимого в случае файла}
					\end{scnrelfromlist}
				\end{scnindent}
			\end{scnindent}
		\end{scnindent}
		
		\scnitem{блокировка на любое изменение}
		\begin{scnindent}
			\scnsuperset{структура}
			\begin{scnindent}
				\scnsuperset{sc-элемент}
				\begin{scnindent}
					\begin{scnrelfromlist}{запрещено   всем sc-агентам, кроме собственно sc-агента}
						\scnitem{физическое удаление sc-коннекторов}
						\scnitem{добавление инцидентных sc-коннекторов}
						\scnitem{физическое удаление самих sc-элементов}
						\scnitem{изменение содержимого в случае файла}
					\end{scnrelfromlist}
					\begin{scnrelfromlist}{разрешено любому sc-агенту}
						\scnitem{просмотр (чтение) sc-элементов }
					\end{scnrelfromlist}
				\end{scnindent}
			\end{scnindent}
		\end{scnindent}
		\scnitem{блокировка на удаление}
		\begin{scnindent}
			\scnsuperset{структура}
			\begin{scnindent}
				\scnsuperset{sc-элемент}
				\begin{scnindent}
					\begin{scnrelfromlist}{запрещено   всем sc-агентам, кроме собственно sc-агента}
						\scnitem{физическое удаление самих sc-элементов}
					\end{scnrelfromlist}
					\begin{scnrelfromlist}{разрешено любому sc-агенту}
						\scnitem{просмотр (чтение) sc-элементов }
						\scnitem{добавление инцидентных sc-коннекторов}
					\end{scnrelfromlist}
				\end{scnindent}
			\end{scnindent}
		\end{scnindent}
	\end{scnrelfromset} 
	
	\scnheader{блокировка}
	\scntext{принцип}{В каждый момент времени одному процессу в sc-памяти может соответствовать только одна блокировка
		каждого типа.}    
	\scntext{принцип}{В каждый момент времени одному процессу в sc-памяти может соответствовать только одна блокировка,
		установленная на некоторый конкретный sc-элемент.}  
	\scntext{принцип}{При завершении выполнения любого процесса в sc-памяти все установленные им блокировки автоматически
		снимаются.}  
	\scntext{принцип}{Для повышения эффективности работы системы в целом каждый процесс должен в каждый момент времени
		блокировать минимально необходимое множество sc-элементов, снимая блокировку с каждого sc-элемента
		сразу же, как это становится возможным (безопасным).}  
	\scntext{принцип}{В случае когда в рамках процесса в sc-памяти явно выделяются более частные подпроцессы (при помощи
		отношений темпоральная часть*, поддействие*, декомпозиция действия* и так далее), то каждый такой подпроцесс с точки зрения синхронизации выполнения рассматривается как самостоятельный процесс, которому
		в соответствие могут быть поставлены все необходимые блокировки.}  
	\begin{scnindent}
		\scntext{принцип}{Все дочерние процессы в sc-памяти имеют доступ к блокировкам родительского процесса так же, как
			если бы это были блокировки соответствующие каждому из таких дочерних процессов.}  
		\scntext{принцип}{В свою очередь, родительский процесс не имеет какого-либо привилегированного доступа к sc-элементам,
			заблокированным дочерними процессами, и работает с ними так же, как любой другой процесс в sc-памяти.}  
		\begin{scnindent}
			\begin{scnrelfromlist}{исключение}
				\scnitem{sc-элементы, обозначающие сами дочерние процессы}
			\end{scnrelfromlist}
		\end{scnindent}
		\scntext{принцип}{Все дочерние процессы по отношению друг к другу работают так же, как и по отношению к любым другим
			процессам.}  
		\scntext{принцип}{В случае, когда родительский процесс приостанавливает выполнение (становится отложенным действием), все его дочерние процессы также приостанавливают выполнение. В свою очередь, приостановка
			одного из дочерних процессов в общем случае не инициирует явно остановку всего родительского процесса и соответственно других дочерних.} 
	\end{scnindent}
	\scnheader{полная блокировка}
	\scntext{принцип}{Если sc-элемент, инцидентный некоторому sc-коннектору, попадает в какую-либо полную блокировку, то сам
		этот sc-коннектор по умолчанию также считается заблокированным этой же блокировкой. Обратное в общем
		случае неверно, так как часть sc-коннекторов, инцидентных некоторому sc-элементу, может быть полностью
		заблокирована, при этом сам этот элемент заблокирован не будет. Такая ситуация типична, например, для
		sc-узлов, обозначающих классы понятий.}  
	\scntext{принцип}{Каждый процесс в sc-памяти может свободно изменять или удалять любые sc-элементы, попадающие в полную
		блокировку, соответствующую этому процессу.}  
	\scntext{преимущество}{Наиболее проста, поскольку все процессы, кроме
		установившего такую блокировку, не имеют доступа к заблокированным sc-элементам и конфликты возникнуть
		не могут.}  
	\scntext{недостаток}{Частое использование блокировок такого типа может привести к тому, что система не
		сможет использовать в полной мере имеющиеся у нее знания и давать неполные или даже некорректные ответы на
		поставленные вопросы.} 
	
	\scnheader{блокировка на любое изменение и блокировка на удаление}
	\scntext{принцип}{На один и тот же sc-элемент в один момент времени может быть установлена только одна блокировка одного
		типа, но разные процессы могут одновременно установить на один и тот же элемент блокировки двух разных
		типов. Это касается случая, когда первый процесс установил на некоторый sc-элемент блокировку на удаление,
		а второй процесс затем устанавливает блокировку на любое изменение. В других случаях возникает конфликт
		блокировок.}  
	\scntext{принцип}{Установка блокировки любого типа также считается изменением, таким образом, если на некоторый sc-элемент
		была установлена блокировка на любое изменение, то другой процесс не сможет установить на этот же sc-элемент блокировку любого типа, пока первый процесс не снимет свою.}  
	\scntext{принцип}{Если блокировка на удаление устанавливается на некоторый sc-коннектор, то по умолчанию та же блокировка устанавливается на инцидентные этому sc-коннектору sc-элементы, поскольку удаление этих элементов
		приведет к удалению этого коннектора.}  
	\scnheader{процесс в sc-памяти}
	\begin{scnrelfromlist}{классификация процессов в sc-памяти с точки зрения синхронизации их выполнения}
		\scnitem{действие поиска sc-элементов}
		\begin{scnindent}
			\scntext{описание}{Все найденные и сохраненные в рамках какого-либо процесса
				sc-элементы попадают в соответствующую данному процессу блокировку на любое изменение. Таким образом,
				гарантируется целостность фрагмента базы знаний, с которым работает некоторый процесс в sc-памяти. При этом
				поиск и автоматическая установка такой блокировки должны быть реализованы как транзакция в sc-памяти.}  
			\scntext{преимущество}{Позволяет избежать ситуации, когда один процесс заблокировал некоторый sc-элемент на
				любое изменение, а второй процесс пытается сгенерировать или удалить sc-коннектор, инцидентный данному sc-элементу.}  
		\end{scnindent}
		\scnitem{действие генерации sc-элементов}
		\begin{scnindent}
			\scntext{описание}{Sc-элемент автоматически попадает в полную блокировку, соответствующую данному процессу. При этом генерация и автоматическая установка такой блокировки
				должны быть реализованы как транзакция в sc-памяти.}  
		\end{scnindent}
		\scnitem{действие удаления sc-элементов}
		\begin{scnindent}
			\scntext{описание}{Может быть осуществлено
				только в случае, когда на данный sc-элемент не установлена (и не планируется) ни одна блокировка каким-либо
				другим процессом. В других случаях необходимо обеспечить корректное завершение выполнения всех процессов, работающих с
				данным sc-элементом, и только потом удалить его физически.}  
		\end{scnindent}
		\scnitem{действие установки блокировки некоторого типа на некоторый sc-элемент}
		\begin{scnindent}
			\scntext{описание}{Блокировка не может быть установлена,
				пока другой процесс не разблокирует указанный sc-элемент; для того чтобы обеспечить возможность поиска и устранения взаимоблокировок, необходимо явно указывать тот факт, что какой-либо процесс
				хочет получить доступ к какому-либо заблокированному другим процессом sc-элементу.}  
		\end{scnindent}
		\scnitem{действие снятия блокировки с некоторого sc-элемента}
		\begin{scnindent}
			\scntext{принцип}{Если на данный sc-элемент установлена одна или несколько планируемых блокировок*, то первая из них
				по приоритету (или единственная) становится блокировкой*, соответствующий ей процесс продолжает выполнение (становится настоящей сущностью); связка отношения приоритет выполнения, соответствовавшая
				удаленной связке отношения планируемая блокировка* также удаляется, то есть приоритет смещается на
				одну позицию.}  
			\scntext{принцип}{Если планируемых блокировок*, установленных на данный sc-элемент, нет, но он попадает во множество
				удаляемых sc-элементов для одного или нескольких процессов, то рассматриваемый sc-элемент физически
				удаляется, а приостановленные до его удаления процессы продолжают свое выполнение (становится настоящими сущностями).}  
			\scntext{принцип}{Если на данный sc-элемент не установлены планируемые блокировки и он не входит во множество удаляемых
				для какого-либо процесса, то блокировка просто снимается без каких-либо дополнительных изменений.}  
		\end{scnindent}
	\end{scnrelfromlist}
	
	\scnheader{транзакция в sc-памяти}
	\scnidtf{Действие, полученное в результате обеспечения синхронизации при объединении нескольких элементарных действий в одно неделимое, для которого гарантируется, что
		ни один сторонний процесс не сможет прочитать или изменить участвующие в этом действии sc-элементы, пока
		действие не завершится}
	\scntext{отличие от полной блокировки}{Процесс, пытающийся получить
		доступ к таким элементам, не продолжает выполнение так, как если бы этих элементов просто не было в sc-памяти,
		а ожидает завершения транзакции, после чего может выполнять с данными элементами любые действия согласно
		общим принципам синхронизации процессов.}  
	\scntext{примечание}{Проблема обеспечения транзакций не может быть решена на уровне
		SC-кода и требует реализации таких неделимых действий на уровне ostis-платформы.}
	
	\begin{scnrelfromset}{разбиение}
		\scnitem{поиск некоторой конструкции в sc-памяти и автоматическая установка блокировки на любое
			изменение на найденные sc-элементы}
		\scnitem{генерация некоторого sc-элемента и автоматическая установка на него полной блокировки}
		\scnitem{проверка наличия на некотором sc-элементе блокировки и в зависимости от результата проверки
			установка блокировки или планируемой блокировки}
		\scnitem{проверка наличия блокировок или планируемых блокировок на удаляемый sc-элемент и собственно его
			удаление или добавление во множество удаляемых sc-элементов для соответствующего процесса}
		\scnitem{снятие блокировки с заданного sc-элемента и при необходимости установка первой по приоритету
			планируемой блокировки или удаление данного sc-элемента, если он входит во множество удаляемых
			sc-элементов для некоторого процесса}
		\scnitem{поиск подпроцессов процесса и добавление их во множество отложенных действий в случае
			добавления самого процесса в данное множество}
		\scnitem{поиск подпроцессов процесса и удаление их из множества отложенных действий в случае удаления
			самого процесса из данного множества}
	\end{scnrelfromset}
	
	
	\scnheader{планируемая блокировка*}
	\scntext{описание}{Процесс, которому в соответствие поставлена планируемая блокировка*, приостанавливает выполнение до тех пор,
		пока уже установленные блокировки не будут сняты, после чего планируемая блокировка* становится реальной
		блокировкой* и процесс продолжает выполнение в соответствии с общими правилами.}    
	\scnheader{приоритет блокировки*}
	\scntext{описание}{Определяется тем, какой из процессов раньше попытался установить блокировку на рассматриваемый sc-элемент, хотя в общем случае приоритет может устанавливаться или меняться в
		зависимости от дополнительных критериев.}  
	\scnheader{абстрактный програмнный sc-агент}
	\scntext{примечание}{При реализации абстрактных программных sc-агентов на Языке SCP, соблюдение всех принципов синхронизации
		соответствующих этим sc-агентам процессов обеспечивается на уровне sc-агентов интерпретации scp-программ,
		то есть средствами ostis-платформы. Так, например, платформа может предоставлять
		доступ к хранимым в sc-памяти элементам через некоторый программный интерфейс, уже учитывающий принципы работы с блокировками, что избавит разработчика агентов от необходимости учитывать все эти принципы
		вручную.
	}  
	\scntext{принцип}{В результате появления в sc-памяти некоторой конструкции, удовлетворяющей условию инициирования
		какого-либо абстрактного sc-агента, реализованного при помощи Языка SCP, в sc-памяти генерируется
		и инициируется scp-процесс. В качестве шаблона для генерации используется агентная scp-программа, соответствующая данному абстрактному sc-агенту.
	}  
	\scntext{принцип}{Каждый такой scp-процесс, соответствующий некоторой агентной scp-программе, может быть связан с набором структур, описывающих блокировки различных типов. Таким образом, синхронизация взаимодействия
		параллельно выполняемых scp-процесcов осуществляется так же, как и в случае любых других действий в
		sc-памяти.} 
	
	\scntext{принцип}{Несмотря на то что каждый scp-оператор представляет собой атомарное действие в sc-памяти, являющееся
		поддействием в рамках всего scp-процесса, блокировки, соответствующие одному оператору, не вводятся,
		чтобы избежать громоздкости и избытка дополнительных системных конструкций, создаваемых при выполнении некоторого scp-процесса. Вместо этого используются блокировки, общие для всего scp-процесса. Таким
		образом, агенты интерпретации scp-программ работают только с учетом блокировок, общих для всего интерпретируемого scp-процесса.} 
	\scntext{принцип}{Процессы, описывающие деятельность агентов интерпретации scp-программ, как правило, не создаются, следовательно, и не вводятся соответствующие им блокировки. Поскольку такие агенты работают с уникальным
		scp-процессом и их число ограничено и известно, то использование блокировок для их синхронизации не
		требуется.} 
	\scntext{принцип}{В случае приостановки scp-процесса (добавления его во множество отложенных действий) в соответствии
		с общими правилами синхронизации все его дочерние процессы также должны быть приостановлены. В
		связи с этим все scp-операторы, которые в этот момент являются настоящими сущностями, становятся
		отложенными действиями} 
	\scntext{принцип}{Во избежание нежелательных изменений в самом теле scp-процесса, вся конструкция, сгенерированная на основе некоторой scp-программы (весь sc-текст, описывающий декомпозицию scp-процесса на scp-операторы),
		должна быть добавлена в полную блокировку, соответствующую данному scp-процессу.} 
	\scntext{принцип}{При необходимости разблокировать или заблокировать некоторую конструкцию каким-либо типом блокировки
		используются соответствующие scp-операторы класса scp-оператор управления блокировками} 
	\scntext{принцип}{После завершения выполнения некоторого scp-процесса его текст, как правило, удаляется из sc-памяти, а все
		заблокированные конструкции освобождаются (разрушаются знаки структур, обозначавших блокировки).} 
	\scntext{принцип}{Как правило, частный класс действий, соответствующий конкретной scp-программе, явно не вводится, а
		используется более общий класс scp-процесс, за исключением тех случаев, когда введение специального
		класса действий необходимо по каким-либо другим соображениям.} 
	\scnheader{блокировка*}
	\scntext{примечание}{В общем случае весь механизм блокировок может описываться как на уровне SC-кода (для повышения уровня
		платформенной независимости), так и при необходимости может быть реализован на уровне ostis-платформы,
		например для повышения производительности. Для этого каждому выполняемому в sc-памяти процессу на нижнем
		уровне может быть поставлена в соответствие некая уникальная таблица, в каждый момент времени содержащая
		перечень заблокированных элементов с указанием типа блокировки.} 
	\scnheader{SCg-текст. Пример использования планируемых блокировок}
	\scneq{\scnfileimage[40em]{Contents/part_ps/src/images/1.png}}
	\begin{scnindent}
		\scntext{описание}{В данном примере Процесс1 непосредственно работает с sc-элементом e1,Процесс2 и Процесс3 планируют установить блокировку на любое изменение и блокировку на удаление соответственно, причем Процесс2 попытался
			установить свою блокировку раньше, чем Процесс3, поэтому согласно направлению связки отношения приоритет
			блокировки*, его блокировка будет установлена раньше. Процесс4 и Процесс5 ожидают снятия всех блокировок и
			планируемых блокировок, после чего e1 будет удален и Процесс1 и Процесс2 продолжат свое выполнение. Никакие
			другие планируемые блокировки установлены быть уже не могут, поскольку e1 попал во множество удаляемых
			sc-элементов как минимум одного процесса и, в соответствии с изложеннымивыше правилами, все остальные
			процессы кроме Процесс1-Процесс5, уже несмогут получить доступ к этому sc-элементу. Выполняемый процесс
			принадлежит множеству настоящая сущность, приостановленные – множеству отложенное действие.} 
	\end{scnindent}
	\scneq{\scnfileimage[40em]{Contents/part_ps/src/images/2.png}}
	\scntext{описание}{После того как Процесс1 разблокировал sc-элемент e1, этот элемент будет заблокирован Процессом2, и Процесс2
		продолжит выполнение. Планируемая блокировка*, установленная Процессом2, становится обычной блокировкой*.}
	\scneq{\scnfileimage[40em]{Contents/part_ps/src/images/3.png}}
	\scntext{описание}{После того как Процесс2 разблокировал sc-элемент e1, этот элемент будет заблокирован Процессом3, и Процесс3
		продолжит выполнение.}
	\scneq{\scnfileimage[40em]{Contents/part_ps/src/images/4.png}}
	\scntext{описание}{Когда все процессы снимут блокировки с sc-элемента e1, он может быть физически удален и Процесс4 и Процесс5
		продолжат выполнение.}
	\scnheader{взаимоблокировка*}
	\scntext{пояснение}{В зависимости от конкретных типов блокировок установленных паралельно выполняемыми процессами на некоторые sc-элементы и того, какие конкретно действия с этими sc-элементами предполагается выполнить далее в
		рамках выполнения этих процессов, возможны ситуации взаимоблокировки, когда каждый из указанных процессов
		будет ожидать снятия блокировки вторым процессом с нужного sc-элемента, не снимая при этом установленной
		им самим блокировки с sc-элемента, доступ к которому необходим второму процессу.}
	\begin{scnrelfromset}{разбиение}
		\scnitem{В случае когда хотя бы одна из блокировок является полной блокировкой, ситуация взаимоблокировки возникнуть не может, поскольку sc-элементы, попавшие в полную блокировку некоторого scp-процесса, не доступны
			другим scp-процессам даже для чтения и, таким образом, остальные scp-процессы будут работать так, как будто
			заблокированные sc-элементы просто отсутствуют в текущем состоянии sc-памяти.
		}
		\scnitem{В случаях, когда ни одна из установленных блокировок не является полной блокировкой, возможно появление
			взаимоблокировок.}
	\end{scnrelfromset}
	\scntext{примечание}{Устранение взаимоблокировки невозможно без вмешательства специализированного sc-метаагента, который имеет право игнорировать блокировки, установленные другими процессами.}
	\begin{scnrelfromset}{решение}
		\scnitem{откат нескольких операций, выполненных одним из участвующих в взаимоблокировке процессов настолько
			шагов назад, насколько это необходимо для того, чтобы второй процесс получил доступ к необходимым
			sc-элементам и смог продолжить выполнение}
		\scnitem{ожидание выполнения второго процесса вплоть до завершения или до снятия им всех блокировок с sc-элементов, доступ к которым необходимо получить первому процессу}
		
		\scnitem{повторное выполнение в рамках первого процесса отмененных операций и продолжение его выполнения, но
			уже с учетом изменений в памяти, внесенных вторым процессом}
	\end{scnrelfromset}
	\scnheader{sc-метаагент}
	\scntext{свойство}{Любой sc-метаагент имеет доступ
		к любым sc-элементам, даже попавшим в полную блокировку для какого-либо другого процесса.}
	\begin{scnrelfromset}{проблема}
		\scnitem{обеспечение синхронизации деятельности sc-метаагентов между собой}
		\begin{scnindent}
			\scntext{решение}{Запрет параллельного выполнения sc-метаагентов.}
			\begin{scnindent}
				\scntext{описание}{В каждый момент времени в рамках одной ostis-системы может существовать только один процесс, соответствующий sc-метаагенту и являющийся настоящей сущностью.}
			\end{scnindent}
		\end{scnindent}
		
		\scnitem{обеспечение синхронизации деятельности sc-метаагентов и программных sc-агентов}
		\begin{scnindent}
			\scntext{решение}{Введение дополнительных привилегий для sc-метаагентов при
				обращении к какому-либо sc-элементу.}
			\begin{scnindent}
				\scntext{правило}{Если некоторый sc-элемент стал использоваться в рамках процесса, соответствующего sc-метаагенту (например,
					стал элементом хотя бы одного scp-оператора, входящего в данный процесс), то все процессы, в блокировки соответствующие которым попадает указанный sc-элемент, становятся отложенными действиями (приостанавливают
					выполнение). Как только указанный sc-элемент перестает использоваться в рамках процесса, соответствующего
					sc-метаагенту, все приостановленные по этой причине процессы продолжают выполнение.}
			\end{scnindent}
		\end{scnindent}
	\end{scnrelfromset}
	\scntext{примечание}{Стоит отметить, что возможна ситуация, при которой выполнение некоторого процесса в sc-памяти прервано по
		причине возникновения какой-либо ошибки. В таком случае существует вероятность того, что блокировка, установленная данным процессом не будет снята до тех пор, пока этого не сделает sc-метаагент, обнаруживший
		подобную ситуацию. Однако указанная проблема на уровне sc-модели может быть решена лишь частично, для случаев, когда ошибка возникает при интерпретации scp-программы, отслеживается scp-интепретатором и в памяти
		формируется соответствующая конструкция, сообщающая о проблеме sc-метаагенту. Случаи, когда возникла
		ошибка на уровне scp-интерпретатора или sc-памяти, должны рассматриваться на уровне ostis-платформы.}
	
	\newpage
\end{SCn}
