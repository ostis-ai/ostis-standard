\begin{SCn}
\scnsectionheader{Предметная область и онтология операционной семантики логических sc-языков}
\scntext{аннотация}{Логические модели решения задач являются основой обработки знаний в интеллектуальных системах. В данной главе рассматривается интеграция различных моделей решения задач, в том числе принципы логического вывода, для решения задач на основе общей формальной модели.}
\begin{scnsubstruct}

\scnheader{Предметная область операционной семантики логических sc-языков}
\scniselement{предметная область}
\begin{scnhaselementrole}{максимальный класс объектов исследования}
    {логический язык}
\end{scnhaselementrole}

\begin{scnrelfromlist}{соавтор}
    \scnitem{Ивашенко В. П.}
    \scnitem{Шункевич Д. В.}
    \scnitem{Василевская А. П.}
    \scnitem{Орлов М. К.}
\end{scnrelfromlist}

\begin{scnrelfromvector}{библиография}
    \scnitem{\scncite{Lawan2019}}
    \scnitem{\scncite{Golenkov1996_2}}
    \scnitem{\scncite{Averin2004}}
    \scnitem{\scncite{Sethy2021}}
    \scnitem{\scncite{Norton2019}}
    \scnitem{\scncite{Yuxuan2022}}
    \scnitem{\scncite{Safawi2015}}
    \scnitem{\scncite{Gungov2018}}
    \scnitem{\scncite{Geramian2017}}
    \scnitem{\scncite{Son2017}}
    \scnitem{\scncite{Uehara2017}}
    \scnitem{\scncite{Lupea2002}}
    \scnitem{\scncite{Weydert2022}}
    \scnitem{\scncite{Chen2021}}
    \scnitem{\scncite{Rybakov2020}}
    \scnitem{\scncite{Orlov2022b}}
    \scnitem{\scncite{Gavrilova2001}}
\end{scnrelfromvector}

\scnheader{логика}
\scnexplanation{Логика решает задачи доказательства высказываний, аргументации того или иного высказывания, задачу генерации и опровержения гипотез. Некоторые гипотезы могут быть опровергнуты, однако извлекая причины того, почему гипотеза опровергнута, можно изменить посылку гипотезы так, чтобы создать новую гипотезу, которая впоследствии может стать теоремой.}
\scnexplanation{Логика не изучает то, как были получены знания, она позволяет представлять знания, а также из существующих знаний вывести новые (то есть из имеющихся формул логики вывести новые формулы этой же логики), установить правильность рассуждений.}

\scnheader{формальный язык}
\scnnote{Современная логика изучает \textit{формальные языки}, служащие для выражения логических рассуждений.}

\scnheader{логический язык}
\scnsubset{формальный язык}
\scndefinition{\textbf{\textit{логический язык}} --- \textit{формальный язык}, предназначенный для воспроизведения логических форм контекстов \textit{естественного языка}, а также выражения логических законов и способов правильных рассуждений в логических теориях, строящихся в данном языке.}

\scnheader{система логического вывода}
\scnnote{На данный момент реализовано много систем \textit{логического вывода}, использующих известные правила прямого заключения и резолюции в различных видах логик.}
\begin{scnrelfromlist}{недостатки текущего состояния}
    \scnfileitem{Проблема совместимости систем логического вывода.}
    \scnfileitem{Проблема коллективного решения задач с использованием различных моделей решения задач.}
\end{scnrelfromlist}

\scnheader{логическая модель решения задач}
\scnsubset{модель решения задач}
\scnexplanation{Логическая модель решения задач может быть задана такими языками, как \textit{Rule Interchange Format} (RIF), Semantic Web Rule Language (SWRL), \textit{SHACL Rules} и \textit{Notation3 Rules}, которые используются в \textit{Semantic Web}.}
\begin{scnindent}
    \scnnote{Языки RIF, SWRL, \textit{SHACL Rules} и \textit{Notation3 Rules} не предусматривают возможность представления формул в различных видах логик, поэтому при помощи них невозможно решить описанные проблемы систем логического вывода. Языки правил специально построены для вывода следствий. Синтаксис и семантика языков онтологий и языков правил довольно сильно отличаются, поэтому возникает вопрос, как их совмещать.}
    \scnrelfrom{изображение}{Рисунок. Запись правил на языке SWRL}
    \begin{scnindent}
        \scneqimage[20em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/swrl_example.png}
    \end{scnindent}
\end{scnindent}
\scnrelfrom{смотрите}{\scncite{Lawan2019}}
\scnnote{\textit{Технология OSTIS} позволяет интегрировать любые принципы логического вывода для решения задач в интеллектуальных системах на основе общей формальной модели. Для того, чтобы использовать какую-либо новую или существующую модель, необходимо привести ее к предлагаемому формализму, что позволит интегрировать и синхронизировать ее с уже имеющимися в соответствующей \textit{библиотеке многократно используемых компонентов ostis-систем}. Формализм \textit{SC-кода} позволяет описывать широкий спектр понятий и отношений между ними, что делает его подходящим вариантом для реализации логического вывода в интеллектуальных компьютерных системах нового поколения. Кроме того, целесообразно воспользоваться принципом наследования, лежащим в основе иерархической структуризации баз знаний ostis-систем.}
\begin{scnindent}
    \scnrelfrom{пример}{Иерархия логических предметных областей}
    \begin{scnindent}
        \begin{scnstruct}
            \scnheader{Предметная область логических формул, высказываний и формальных теорий}
            \begin{scnrelfromlist}{дочерняя предметная область}
                \scnitem{Предметная область логических языков}
                \scnitem{Предметная область логического вывода}
            \end{scnrelfromlist}

            \scnheader{Предметная область логических языков}
            \scnrelfrom{дочерняя предметная область}{Предметная область языка логики высказываний}
            \begin{scnindent}
                \scnrelfrom{дочерняя предметная область}{Предметная область языка логики предикатов}
            \end{scnindent}

            \scnheader{Предметная область логических моделей решения задач}
            \begin{scnreltolist}{дочерняя предметная область}
                \scnitem{Предметная область логических языков}
                \scnitem{Предметная область логического вывода}
            \end{scnreltolist}
        \end{scnstruct}
    	\scnnote{Наследование предметных областей позволяет использовать описанные логики и их компоненты при описании любых логик. Базовые понятия позволяют разработчикам интеллектуальной системы добавлять новые логики. Для реализации конкретной логической модели решения задач необходимо создать предметную область, которая будет дочерней по отношению к \textit{Предметной области логических моделей решения задач} и предметной области некоторого \textit{логического языка}, например, языка логики высказываний, языка логики предикатов, языка нечеткой логики и других.}
    \end{scnindent}
\end{scnindent}

\scnheader{Язык Пролог}
\scniselement{язык программирования}

\scnheader{система программирования Пролог}
\scnsubset{система логического программирования}
\scnnote{\textit{база знаний} каждой \textit{системы программирования Пролог} содержит информацию в виде предикатов. В логическом программировании, реализованном в \textit{системе программирования Пролог}, используется только одно \textit{правило вывода} --- правило резолюции. Задача пролог-программы заключается в том, чтобы доказать, является ли заданное целевое высказывание следствием из имеющихся формул и, если является, то каким образом был получен такой вывод. Когда пользователь задает вопрос \textit{системе программирования Пролог}, система ищет соответствующие предикаты в базе знаний и, если они найдены, сравнивает их с заданными условиями. \textit{система программирования Пролог} хорошо справляется с нетрудными задачами, однако ограничена лишь одним принципом логического вывода и не позволяет учитывать сложноструктурированные знания в различных видах логик.}

\scnheader{Предметная область логических формул, высказываний и формальных теорий}
\scnexplanation{\textit{Предметная область логических формул, высказываний и формальных теорий} задает денотационную семантику логических формул, высказываний и формальных теорий и содержит формальную спецификацию понятий, необходимых для формирования логических формул и высказываний любых логик.}

\scnheader{Предметная область логических моделей решения задач}
\scnnote{Логические формулы и высказывания интерпретируется с помощью понятий, описанных в \textit{Предметной области логических моделей решения задач}, включающую модель и реализацию абстрактных агентов, необходимых для решения логических задач.}
\begin{scnhaselementrolelist}{исследуемое понятие}
    \scnitem{логический вывод}
    \scnitem{правило вывода}
    \scnitem{равносильное преобразование}
    \scnitem{аксиомная схема}
\end{scnhaselementrolelist}

\scnheader{Язык SCL}
\scnrelto{подъязык}{SC-код}
\scnexplanation{\textit{\textbf{Язык SCL}} — подъязык \textit{SC-кода} для записи логических утверждений. Над высказываниями \textit{Языка SCL} можно проводить \textit{логический вывод}.}
\scnrelfrom{смотрите}{Предметная область и онтология знаний и баз знаний ostis-систем}
\scnrelfrom{смотрите}{\scncite{Golenkov1996_2}}

\scnheader{логический вывод}
\scnidtf{вывод}
\scndefinition{\textbf{\textit{логический вывод}} --- любая последовательность формул такая, что любая формула либо аксиома этой формальной системы, либо непосредственное следствие каких-либо предыдущих формул по одному из правил вывода.}
\scnnote{Правильность умозаключений вводится и проверяется совершенно формально, без какой-либо связи с истинностью входящих в него посылок, то есть исключительно с точки зрения структуры рассуждения. С практической точки зрения самое важное свойство такой формальной правильности рассуждений заключается в следующем: если удалось доказать, пользуясь методами формальной логики, правильность рассуждения, и известно из опыта, что все используемые посылки истинны, то можно быть уверенным в истинности заключения. Истинность используемых посылок задается состоянием базы знаний.}
\scnrelfrom{смотрите}{\scncite{Averin2004}}
\scnnote{Доказательство вывода формулы равносильно доказательству противоречивости вывода отрицания этой формулы. При использовании правила резолюции это особенно удобно использовать.}

\scnheader{классический дедуктивный вывод}
\scnnote{Некоторые операции, необходимые в одной предметной области будут избыточными в другой. Например, в системе, решающей задачи по геометрии, химии и другим естественным наукам обоснованным будет использование дедуктивных методов вывода, поскольку решение задач в таких предметных областях основывается только на достоверных правилах. В системах же медицинской диагностики, к примеру, постоянно возникает ситуация, когда диагноз может быть поставлен только с некоторой долей уверенности и абсолютно достоверным ответ на поставленный вопрос быть не может. В связи с этим возникает необходимость использования различных \textit{решателей задач} в различных системах, при этом их состав и возможности в конкретной системе определяется не только непосредственно разработчиком, а требует консультаций с экспертами в данной предметной области. Тем не менее основой для всех видов логик является классическая логика и наиболее общие ее методы распространяются на другие логики с некоторыми модификациями, уточнениями и ограничениями.}
\begin{scnindent}
    \scnrelfrom{смотрите}{\scncite{Golenkov2004}}
\end{scnindent}

\scnheader{логический метод решения задач}
\scnsuperset{классический дедуктивный вывод}
\begin{scnindent}
    \scnexplanation{Классический дедуктивный вывод является наиболее популярным при построении автоматических решателей задач, так как всегда дает достоверный результат. Дедуктивный вывод включает в себя прямой и обратный и логический вывод (принцип резолюции, процедуру Эрбрана и так далее), все виды силлогизмов и так далее.}
    \scntext{преимущество}{Всегда дает достоверный результат.}
    \scntext{недостаток}{Невозможность использования, когда отсутствуют достоверные знания.}
    \begin{scnrelfromlist}{библиографический источник}
        \scnitem{\scncite{Averin2004}}
        \scnitem{\scncite{Sethy2021}}
    \end{scnrelfromlist}
\end{scnindent}
\scnsuperset{индуктивный вывод}
\begin{scnindent}
    \scntext{преимущество}{Предоставляет возможность в процессе решения использовать различные предположения, что делает его удобным для использования в слабоформализованных и трудноформализуемых предметных областях, например при построении систем медицинской диагностики.}
    \begin{scnrelfromlist}{библиографический источник}
        \scnitem{\scncite{Norton2019}}
        \scnitem{\scncite{Yuxuan2022}}
    \end{scnrelfromlist}
\end{scnindent}
\scnsuperset{абдуктивный вывод}
\begin{scnindent}
    \scndefinition{\textbf{\textit{абдуктивный вывод}} --- в искусственном интеллекте, вывод наилучшего абдуктивного объяснения, то есть объяснения некоторого события, ставшего неожиданным для системы.}
    \scnnote{Наилучшим считается такое объяснение, которое удовлетворяет специальным критериям, определяемым в зависимости от решаемой задачи и используемой формализации.}
    \begin{scnrelfromlist}{библиографический источник}
        \scnitem{\scncite{Safawi2015}}
        \scnitem{\scncite{Gungov2018}}
    \end{scnrelfromlist}
\end{scnindent}
\scnsuperset{нечеткий вывод}
\begin{scnindent}
    \scnnote{Импликативные высказывания могут рассматриваться как "если истинна посылка"{}, то с некоторой вероятностью (часто или редко) истинно заключение, в отличие от классической логики, где зачастую используются статические предметные области и выражение "часто или редко"{} не применимо (корректно использовать только наречие "всегда"{}).}
    \begin{scnrelfromlist}{библиографический источник}
        \scnitem{\scncite{Geramian2017}}
        \scnitem{\scncite{Son2017}}
        \scnitem{\scncite{Uehara2017}}
    \end{scnrelfromlist}
\end{scnindent}
\scnsuperset{вывод с умолчаниями}
\begin{scnindent}
    \scnnote{Вывод с умолчаниями применяется, в том числе, для того, чтобы оптимизировать процесс рассуждений, дополняя процесс достоверного вывода вероятностными предположениями в тех случаях, когда вероятность ошибки крайне мала.}
    \begin{scnrelfromlist}{библиографический источник}
        \scnitem{\scncite{Lupea2002}}
        \scnitem{\scncite{Weydert2022}}
    \end{scnrelfromlist}
\end{scnindent}
\scnsuperset{темпоральный вывод}
\begin{scnindent}
    \scnnote{Применение темпорального вывода является очень актуальным для нестатичных предметных областей, в которых истинность того или иного утверждения меняется со временем, что существенно влияет на ход решения какой-либо задачи. Следует отметить, что Язык SCL предоставляет все необходимые возможности для описания таких динамических предметных областей.}
    \begin{scnrelfromlist}{библиографический источник}
        \scnitem{\scncite{Chen2021}}
        \scnitem{\scncite{Rybakov2020}}
    \end{scnrelfromlist}
\end{scnindent}

\scnheader{база знаний}
\scnexplanation{База знаний интеллектуальной системы включает в себя как модель фактографических знаний о предметной области, для которой предназначена система, так и модель знаний, включающая в себя логические формулы об этой предметной области (аксиомы, теоремы и правила вывода).}

\scnheader{Абстрактная scl-машина}
\scnidtf{scl-машина}
\scniselement{машина логического вывода}
\scniselement{абстрактная sc-машина}
\scnnote{Операции \textit{scl-машины} соответствуют правилам \textit{логического вывода}.}
\scnrelfrom{внутренний язык}{Язык SCL}
\scnnote{Семейство специализированных абстрактных графодинамических машин обработки знаний является формальным уточнением операционной семантики специализированных графовых языков представления знаний, каждому из которых соответствует одна или несколько абстрактных машин. Эти абстрактные машины соответствуют различным моделям решения задач, различным логикам, различным моделям правдоподобных рассуждений.}
\scnnote{Агент из семейства агентов логического вывода может представлять собой какое-либо правило вывода, которое можно применять для решения логической задачи. Кроме того, необходимы агенты для выполнения равносильных преобразований логической формулы (например, записать формулу эквиваленции как конъюнкцию двух дизъюнкций) и другие агенты, помогающие применять правила вывода на множестве формул языка логики.}
\begin{scnindent}
    \scnrelfrom{смотрите}{\scncite{Orlov2022b}}
\end{scnindent}
\scnrelfrom{смотрите}{\scncite{Golenkov1996_2}}

\scnheader{Абстрактная scl-машина}
\begin{scnrelfromset}{декомпозиция абстрактного sc-агента}
    \scnitem{Абстрактный sc-агент применения правила вывода}
    \begin{scnindent}
        \scnnote{Задачей \textit{Абстрактного sc-агента применения правила вывода} является применение заданного правила вывода с заданными логическими формулами.}
        \scnrelfrom{класс действий агента}{действие. применить правило вывода}
        \scnrelfrom{первичное условие инициирования}{событие добавления sc-дуги, выходящей из множества \textit{инициированное действие}}
        \begin{scnrelfromvector}{алгоритм реализации}
            \scnfileitem{Проверка условия инициирования.}
            \scnfileitem{Применение правила вывода.}
            \begin{scnindent}
                \scnexplanation{Применение правила вывода заключается в проверке, существуют ли в sc-памяти структуры, соответствующие условию применения данного правила, и генерации sc-конструкций в соответствии с применяемым правилом.}
            \end{scnindent}
        \end{scnrelfromvector}
        \scnnote{В ходе работы агента автоматически выполняется процедура унификации: переменные соответствуют константам, константы соответствуют самим себе. Агент применения правила вывода зачастую используется в процессе работы агентов прямого логического вывода, обратного логического вывода и других агентов.}
        \scnrelfrom{изображение}{SCg-текст. Формализация правила вывода Modus ponens}
        \begin{scnindent}
            \scneqimage[30em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/Modus_ponens.png}
            \scnnote{Можно привести еще целый ряд высказываний, которые описывают общие свойства всевозможных формальных теорий, каждая из которых описывает ту или иную предметную область. Свойства всевозможных формальных теорий описываются в рамках специальной метатеории для которой совокупность всевозможных формальных теорий является описываемой предметной областью.}
        \end{scnindent}
    \end{scnindent}
    \scnitem{Абстрактный sc-агент эквивалентных преобразований логической формулы}
    \begin{scnindent}
        \scnnote{Задачей \textit{Абстрактного sc-агента эквивалентных преобразований логической формулы} является применение некоторых правил, которые приводят логическую формулу в определенный вид.}
        \scnrelfrom{класс действий агента}{действие. выполнить эквивалентное преобразование логической формулы}
        \scnrelfrom{первичное условие инициирования}{событие добавления sc-дуги, выходящей из множества \textit{инициированное действие}}
        \begin{scnrelfromvector}{алгоритм реализации}
            \scnfileitem{Проверка условия инициирования.}
            \scnfileitem{Преобразование формулы из одной формы в другую.}
            \begin{scnindent}
                \scnnote{При преобразовании никакие новые знания в sc-памяти с точки зрения исследуемой предметной области не генерируются.}
            \end{scnindent}
        \end{scnrelfromvector}
        \scnnote{Ответом данного агента является множество формул, эквивалентных по смыслу, но различных по форме представления. Такими формами могут быть, например, конъюнктивная нормальная форма или дизъюнктивная нормальная форма.}
        \scntext{решаемая проблема}{Логическая формула не всегда находится в той форме, которая доступна для применения того или иного правила вывода, однако может быть приведена к нужной форме}
    \end{scnindent}
    \scnitem{Абстрактный sc-агент прямого логического вывода}
    \begin{scnindent}
        \scnnote{Задачей \textit{Абстрактного sc-агента прямого логического вывода} является генерации новых знаний на основе некоторых логических утверждений.}
        \scnrelfrom{класс действий агента}{действие. выполнить прямой логический вывод}
        \scnrelfrom{первичное условие инициирования}{событие добавления sc-дуги, выходящей из множества \textit{инициированное действие}}
        \begin{scnrelfromvector}{алгоритм реализации}
            \scnfileitem{Проверка условия инициирования.}
            \scnfileitem{Процесс прямого логического вывода.}
            \begin{scnindent}
                \begin{scnrelfromset}{декомпозиция}
                    \scnfileitem{Применение правил вывода.}
                    \scnfileitem{Генерация новых знаний в sc-памяти.}
                    \scnfileitem{Проверка некоторого условия.}
                    \begin{scnindent}
                        \scntext{пример}{Появление в sc-памяти sc-элементов из целевой sc-структуры.}
                    \end{scnindent}
                \end{scnrelfromset}
                \scnrelfrom{смотрите}{\scncite{Gavrilova2001}}
            \end{scnindent}
        \end{scnrelfromvector}
        \scnnote{Входными аргументами такого агента является целевая структура, множество формул, которые используются в ходе вывода агентом применения правил вывода, множество правил вывода, входная структура и выходная структура. В результате выполнения агентом логического вывода действия, в sc-памяти формируется sc-структура, представляющая собой дерево решения. Это дерево состоит из последовательности узлов, представляющих собой примененные правила, которые привели к появлению в sc-памяти требуемых знаний. Такое дерево может быть пустым в случае, если требуемую структуру не удалось сгенерировать в ходе логического вывода.}
        \scnrelfrom{изображение}{SCg-текст. Спецификация агента прямого логического вывода}
        \begin{scnindent}
            \scneqimage[40em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/direct_inference_agent.png}
        \end{scnindent}
    \end{scnindent}
    \scnitem{Абстрактный sc-агент обратного логического вывода}
    \begin{scnindent}
        \scnnote{Задачей \textit{Абстрактного sc-агента обратного логического вывода} является проверка гипотез. Некоторые гипотезы могут быть опровергнуты, однако извлекая причины того, почему гипотеза опровергнута, можно изменить посылку гипотезы так, чтобы создать новую гипотезу, которая впоследствии может стать полезной теоремой.}
        \scnrelfrom{класс действий агента}{действие. выполнить обратный логический вывод}
        \scnrelfrom{первичное условие инициирования}{событие добавления sc-дуги, выходящей из множества \textit{инициированное действие}}
        \begin{scnrelfromvector}{алгоритм реализации}
            \scnfileitem{Проверка условия инициирования.}
            \scnfileitem{Процесс обратного логического вывода.}
            \begin{scnindent}
                \scnexplanation{Процесс \textit{обратного логического вывода}, схож с процессом \textit{прямого логического вывода} за исключением того, что поиск правил основывается не на посылках формул, а на их следствиях.}
                \scnrelfrom{смотрите}{\scncite{Gavrilova2001}}
            \end{scnindent}
        \end{scnrelfromvector}
        \scnnote{Ответом данного агента будет дерево вывода, которое показывает, с использованием каких правил можно доказать или опровергнуть выдвинутую гипотезу.}
    \end{scnindent}
\end{scnrelfromset}
\scnhaselement{Реализации интерпретатора логических моделей решения задач}
\begin{scnindent}
    \scnidtf{Реализация scl-машины}
    \scntext{адрес компонента}{https://github.com/ostis-ai/scl-machine}
\end{scnindent}

\scnheader{Абстрактный sc-агент эквивалентных преобразований логической формулы}
\begin{scnrelfromset}{декомпозиция абстрактного sc-агента}
    \scnitem{Абстрактный sc-агент преобразования формулы в конъюнктивную нормальную форму}
    \scnitem{Абстрактный sc-агент преобразования формулы в дизъюнктивную нормальную форму}
    \scnitem{Абстрактный sc-агент применения законов Де Моргана}
    \scnitem{Абстрактный sc-агент эквивалентных преобразований логической формулы по определению}
    \scnitem{Абстрактный sc-агент применения свойств отрицания логических формул}
    \scnitem{Абстрактный sc-агент применения закона идемпотентности логических формул}
    \scnitem{Абстрактный sc-агент применения закона коммутативности логических формул}
    \scnitem{Абстрактный sc-агент применения закона ассоциативности логических формул}
    \scnitem{Абстрактный sc-агент применения закона поглощения логических формул}
    \scnitem{Абстрактный sc-агент применения закона противоречия логических формул}
    \scnitem{Абстрактный sc-агент применения закона двойного отрицания логических формул}
    \scnitem{Абстрактный sc-агент применения закона расщепления логических формул}
\end{scnrelfromset}

\scnheader{правило резолюции}
\scntext{преимущество}{Любая формула семантически эквивалентна некоторой формуле в конъюнктивной нормальной форме, в связи с этим иногда удобно применять правило резолюции.}
\scnnote{Используя законы Де Моргана можно получить формулы, пригодные для использования правила резолюции. С помощью правила резолюции можно эффективно доказывать формулы \textit{Языка логики высказываний}.}
\scntext{недостаток}{Ничего принципиально нового правило резолюции не привносит, поскольку формула $A \Rightarrow B$  равносильно $\neg A \lor B$ и из выводимости A и $A \rightarrow B$ следует выводимость B.}
\scntext{пример}{Если в любых двух дизъюнктах $C_1$ и $C_2$ имеется пара формул $A$ и $\neg A$, то можно сформировать новый дизъюнкт из оставшихся частей изначальных дизъюнктов.}
\scnrelfrom{пример}{SCg-текст. Формализация правила резолюции}
\begin{scnindent}
    \scneqimage[30em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/resolution.png}
\end{scnindent}

\scnheader{Абстрактная scl-машина}
\scnrelfrom{пример использования}{Задача с футбольными командами}
\begin{scnindent}
    \scneqfile{Если команда A выигрывает в футбол, то город A' торжествует, а если выигрывает команда B, то торжествовать будет город B'. Выиграть может или только город A', или только город B'. Однако, если выигрывает команда A, то город B' не торжествует, а если выигрывает команда B, то не торжествует город A'. Следовательно, город B' торжествует тогда и только тогда, когда не будет торжествовать город A'. Цель логического вывода - удостовериться, что город B' торжествует тогда и только тогда, когда не будет торжествовать город A'.}
    \scnrelfrom{изображение}{SCg-текст. Формализация правил для применения правила резолюции}
    \begin{scnindent}
        \scneqimage[30em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/resolution_formulas_example.png}
        \scnnote{Каждая неатомарная формула на рисунке принадлежит некоторой формальной теории, то есть считается истинной.}
        \scnnote{Структура A представляет собой атомарную логическую формулу, которая обозначает победу команды A, структура A' представляет формулу, обозначающую торжество города A'. Соответственно, то же самое для структур B и B'.}
    \end{scnindent}
    \begin{scnrelfromvector}{решение}
        \scnfileitem{Привести импликацию в конъюнктивную нормальную форму по формуле \textit{Конъюнктивная нормальная форма для импликации} и эквиваленцию по определению.}
        \begin{scnindent}
            \scnrelfrom{изображение}{SCg-текст. Формализация конъюнктивной нормальной формы для импликации}
            \begin{scnindent}
                \scneqimage[35em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/conjunction_implication_rule.png}
            \end{scnindent}
        \end{scnindent}
        \scnfileitem{Применить отрицание к формуле, которую необходимо вывести (эквиваленция).}
        \begin{scnindent}
            \scnrelfrom{изображение}{SCg-текст. Формализация правил для применения правила резолюции после преобразования в конъюнктивную нормальную форму}
            \begin{scnindent}
                \scneqimage[35em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/resolution_prepared_formulas_example.png}
            \end{scnindent}
        \end{scnindent}
        \scnfileitem{Применяя правило резолюции для преобразованных формул получается пустой дизъюнкт, что говорит о противоречивости множества формул и доказывает формулу эквиваленции о том, что город B' торжествует тогда и только тогда, когда не будет торжествовать город A'.}
    \end{scnrelfromvector}
    \begin{scnindent}
        \scnrelfrom{изображение}{SCg-текст. Применение принципа резолюции}
        \begin{scnindent}
            \scneqimage[40em]{Contents/part_ps/src/images/sd_operat_sem_sc_logical_lang/resolution_inference.png}
        \end{scnindent}
    \end{scnindent}
\end{scnindent}

\bigskip
\end{scnsubstruct}
\scnendsegmentcomment{Предметная область и онтология операционной семантики логических sc-языков}
    
\end{SCn}
