\begin{SCn}

\scnsectionheader{Предметная область и онтология действий и методик проектирования решателей задач ostis-систем}

\scnstartsubstruct

\scnheader{Предметная область и онтология действий и методик проектирования решателей задач ostis-систем}
\scniselement{предметная область}
\scnsdmainclasssingle{...}
\scnsdclass{...}
\scnsdrelation{...}

\scnheader{методика разработки решателей задач ostis-систем}
\scnnote{Все платформенно-независимые компоненты решателя задач ostis-системы могут быть представлены при помощи SC-кода, при этом речь идет как о спецификациях sc-агентов, так и о полных текстах scp-программ, описывающих алгоритмы работы указанных агентов.

Таким образом, разработка решателя задач некоторой ostis-системы сводится к разработке особого рода фрагмента базы знаний такой системы. В связи с этим, для проектирования и модификации решателей могут использоваться методики и средства автоматизации процесса построения и модификации баз знаний ostis-систем, рассмотренные в \textit{Разделе. \nameref{sd_methods_kb}}.
}
\scnexplanation{Предлагаемая методика построения и модификации гибридных решателей задач включает несколько этапов. Рассматриваемая методика может быть применена как при разработке объединенных решателей, так и при разработке решателей частного вида, поскольку с формальной точки зрения все они трактуются как неатомарный абстрактный sc-агент. 

Рассмотрим подробнее каждый из этапов на примере разработки решателя задач интеллектуальной справочной системы (ИСС) по геометрии Евклида.

\begin{scnitemize}
\item Этап1. Формирование требований и спецификация  решателя задач

На данном этапе необходимо четко выделить задачи, решение которых должен обеспечивать решатель задач, продумать предполагаемые способы их решения и на основе данного анализа определить место будущего решателя в общей иерархии решателей, рассмотренной выше. Важность данного этапа заключается с в том, что при правильной классификации существует вероятность того, что в составе библиотеки компонентов уже есть реализованный вариант требуемого решателя. В противном случае, тем не менее, у разработчика появляется возможность включить разработанный решатель в библиотеку компонентов для последующего использования. Данные факты обусловлены тем, что структура библиотеки компонентов решателей задач основана на семантической классификации таких решателей и, соответственно, их компонентов.

При недостаточно четкой спецификации и классификации разрабатываемого решателя повышается вероятность того, что подходящий решатель не будет найден в библиотеке компонентов даже в случае, если он там есть, а вновь разработанный решатель не сможет быть включен в библиотеку. Таким образом, идея многократного использования уже разработанных компонентов будет нарушена, что существенно повысит затраты на разработку такого решателя. 

Например, для первой версии разрабатываемого решателя по геометрии можно выделить такие классы задач, как:

\begin{scnenumerate}
 \item базовый поиск по базе знаний (поиск элементов заданного множества; поиск классов, которым принадлежит заданная сущность; поиск идентификаторов для заданной сущности; поиск декомпозиции заданной сущности; поиск семантической окрестности заданной сущности; поиск всех сущностей, являющихся частными/общими для заданной сущности);
 \item поиск по базе знаний, актуальный для интеллектуальных справочных систем (поиск иллюстраций для заданной сущности; поиск аксиом/теорем заданной формальной теории; поиск понятий, на основе которых определяется заданное понятие; поиск понятий, которые определяются на основе заданного понятия; поиск доказательства заданного логического утверждения, заранее представленного в базе знаний; поиск решения заданной задачи, заранее представленной в базе знаний и др.);
 \item поиск значения заданной величины с использованием простых механизмов логического вывода и стратегии поиска в глубину;
\end{scnenumerate}

\item Этап2. Формирование коллектива sc-агентов, входящих в состав разрабатываемого решателя

В случае, когда найти в библиотеке готовый решатель, удовлетворяющий всем предъявляемым требованиям, не представляется возможным, необходимо выделить и специфицировать все компоненты такого решателя.

Результатом данного этапа является перечень полностью специфицированных \textit{sc-агентов}, которые войдут в состав разрабатываемого решателя, с их иерархией вплоть до \textit{атомарных sc-агентов}. В рамках данного этапа очень важно проектировать коллектив агентов таким образом, чтобы максимально задействовать уже имеющиеся в библиотеке многократно используемые компоненты, а при отсутствии нужного компонента – иметь возможность включить его в библиотеку после реализации. В качестве таких компонентов, в зависимости от сложности разрабатываемого решателя, могут выступать как \textit{атомарные sc-агенты}, так и целые коллективы sc-агентов (\textit{неатомарные \mbox{sc-агенты}}).

При разработке перечня агентов (в том числе их спецификаций) необходимо соблюдать ряд принципов:

\begin{scnitemizeii}
\item каждый разрабатываемый sc-агент должен быть по возможности предметно независим, т. е. во множество ключевых узлов данного sc-агента не должны входить понятия, имеющие отношение непосредственно к рассматриваемой предметной области. Исключение составляют понятия из общих предметных областей, которые носят междисциплинарный характер (например, отношение \textit{включение*} или понятие \textit{действие}). Данное правило также может быть нарушено в случае, если sc-агент является вспомогательным и ориентирован на обработку какого-либо конкретного класса объектов (например, sc-агенты, выполняющие арифметические вычисления, могут напрямую работать с конкретными отношениями \textit{сложение*} и \textit{умножение*} и т. п.). Всю необходимую для решения задачи информацию sc-агент должен извлекать из семантической окрестности соответствующего инициированного действия. Очевидно, что sc-агент, разработанный с учетом указанных требований, может быть использован при проектировании большего числа ostis-систем, чем в случае, если бы он был реализован с ориентацией на конкретную частную предметную область. После завершения разработки и отладки такой sc-агент должен быть включен в \textit{Библиотеку многократно используемых абстрактных sc-агентов};

\item не стоит путать понятия sc-агент и агентная программа (в том числе агентная scp-программа). Взаимодействие sc-агентов осуществляется исключительно посредством спецификации информационных процессов в общей памяти, каждый sc-агент реагирует на некоторый класс событий в sc-памяти. Таким образом, каждому sc-агенту соответствует некоторое условие инициирования и одна агентная программа, которая запускается автоматически при возникновении в sc-памяти соответствующего условия инициирования. При этом в рамках данной программы могут сколько угодно раз вызываться различные подпрограммы. Однако не стоит путать инициирование sc-агента, которое осуществляется при появлении в sc-памяти соответствующей конструкции, и вызов подпрограммы другой программой, который предполагает явное указание вызываемой подпрограммы и перечня ее параметров;

\item каждый sc-агент должен самостоятельно проверять полноту соответствия своего условия инициирования текущему состоянию sc-памяти. В процессе решения какой-либо задачи может возникнуть ситуация, когда на появление одной и той же структуры среагировали несколько sc-агентов. В таком случае выполнение продолжают только те из них, условие инициирования которых полностью соответствует сложившейся ситуации. Остальные sc-агенты в данном случае прекращают выполнение и возвращаются в режим ожидания. Выполнение данного принципа достигается за счет тщательного уточнения спецификаций разрабатываемых sc-агентов. В общем случае условия инициирования у нескольких sc-агентов могут совпадать, например, в случае, когда одна и та же задача может быть решена разными способами и заранее неизвестно, какой из них приведет к желаемому результату;

\item необходимо помнить, что неатомарный sc-агент с точки зрения других sc-агентов, не входящих в его состав, должен функционировать как целостный sc-агент (выполнять логически атомарные действия), что накладывает определенные требования на спецификации атомарных sc-агентов, входящих в его состав: как минимум, необходимо, чтобы в составе неатомарного sc-агента присутствовал хотя бы один атомарный sc-агент, условие инициирования которого полностью совпадает с условием инициирования данного неатомарного sc-агента;

\item при необходимости реализации нового sc-агента следует руководствоваться следующими принципами выделения атомарных абстрактных \mbox{sc-агентов}:

\begin{scnenumerate}

\item проектируемый sc-агент должен быть максимально независим от предметной области, что позволит в дальшейшем использовать его при разработке решателей максимально возможного числа ostis-систем. При этом универсальность предполагает не только минимизацию числа ключевых узлов sc-агента, но и выделение класса действий, выполняемых данным sc-агентом таким образом, чтобы имело смысл включить данный sc-агент в \textit{Библиотеку многократно используемых абстрактных sc-агентов} и использовать его при разработке решателей других ostis-систем. Не следует искусственно увязывать ряд действий в один sc-агент и, наоборот, расчленять одно самодостаточное действие на поддействия: это вызовет сложности восприятия принципов работы sc-агента разработчиками и не позволит использовать sc-агент в ряде систем (например, в обучающих системах, которые должны объяснять ход решения пользователю);

\item акт деятельности каждого sc-агента (выполняемое данным sc-агентом действие) должен быть логически целостным и завершенным. Следует помнить, что все sc-агенты взаимодействуют исключительно через общую память и избегать ситуаций, в которых инициирование одного sc-агента осуществляется путем явной генерации известного условия инициирования другим \mbox{sc-агентом} (т. е., по сути, явным непосредственным вызовом одного sc-агента другим);

\item имеет смысл выделять в отдельные sc-агенты те относительно крупные фрагменты реализации некоторого общего алгоритма, которые могут выполняться независимо друг от друга;
\end{scnenumerate}

\item при объединении sc-агентов в коллективы рекомендуется проектировать их таким образом, чтобы они могли быть использованы не только как часть рассматриваемого неатомарного абстрактного sc-агента. В случае, если это не представляется возможным и некоторые sc-агенты, будучи отделенными от коллектива, теряют смысл, необходимо указать данный факт при документировании рассматриваемых sc-агентов;

\item фактическим инициатором запуска sc-агента посредством общей памяти (автором соответствующей конструкции) может быть как непосредственно пользователь системы, так и другой sc-агент, что никак не должно отражаться в работе самого sc-агента.
\end{scnitemizeii}

Рассмотрим подробнее процесс выделения агентов в составе разрабатываемого решателя по геометрии. Для реализации каждого из поисковых запросов, представленных в пункте 1 и пункте 2 представленного выше списка задач, решаемых таким решателем, выделяется соответствующий поисковый агент.

Для выделения коллектива агентов, реализующих поиск неизвестного значения величины рассмотрим общий алгоритм решения задачи, который предполагается реализовывать в рамках данного решателя:

\begin{scnenumerate}
    \item осуществляется проверка, вычислено ли искомое значение величины, если это так, то процесс решения завершается, в противном случае - переход к шагу 2.
    \item анализируются связи искомой величины с другими сущностями. Для каждой сущности, связанной с величиной каким-либо отношением, осуществляется поиск классов, которым она принадлежит. Для каждого найденного класса осуществляется поиск логических утверждений, справедливых для данного класса. Для каждого найденного утверждения выполняются шаги:
    \begin{scnitemizeii}
        \item осуществляется попытка применения найденного логического утверждения с учетом информации, известной на данный момент. Если утверждение может быть применено (информации достаточно, посылки истинны) то генерируются новые знания, и алгоритм возвращается к шагу 1 и повторяется уже с учетом новых знаний. При необходимости осуществляется расчет математических выражений. Если для применения утверждения текущей информации недостаточно, то осуществляется переход к следующему утверждению для текущего рассматриваемого класса;
        \item если все утверждения для данного класса просмотрены, то осуществляется переход к следующему классу для текущей сущности, и утверждения просматриваются аналогичным образом;
    \end{scnitemizeii}

\item Если все классы для данной сущности рассмотрены, то осуществляется поиск непросмотренных сущностей, связанных с текущей по принципу <<поиска в глубину>>.
\end{scnenumerate}

На основании данного алгоритма целесообразно выделить следующие классы логически атомарных действий:
\begin{scnitemizeii}
    \item поиск значения заданной величины;
    \item поиск утверждения, которое может быть применено к текущей рассматриваемой сущности или переход к другим сущностям (реализация стратегии поиска пути решения задачи в глубину);
    \item применение заданного логического утверждения в рамках заданного контекста. В текущей реализации рассматриваются простые логические утверждения об импликации (вида ЕСЛИ--ТО) и эквиваленции;
    \item расчет математического выражения. В рамках прототипа предполагается использование таких операций как сложение/вычитание, умножение/деление, возведение в степень/извлечение корня/логарифмирование, сравнение. Каждой из перечисленных операций также соответствует класс логически атомарных действий.
\end{scnitemizeii}

Можно заметить, что выделение таких классов действий позволяет, с одной стороны, сделать агенты достаточно универсальными для их последующего использования в других системах, с другой стороны -- обеспечить возможность расширения функциональности решателя таким образом, чтобы вносимые изменения были локализованы. Так, агенты применения логических утверждений могут быть использованы самостоятельно без агента реализации стратегии, а перечень таких агентов может быть легко расширен, что позволит использовать для решения задачи утверждения более сложного вида, при этом нет необходимости вносить какие-либо изменения в агент реализации стратегии. В свою очередь, неатомарный агент расчета математических выражений может быть использован в других системах, при этом состав атомарных агентов в его составе может легко меняться, не затрагивая при этом общий принцип расчета.

\item Этап3. Разработка алгоритмов атомарных sc-агентов

В рамках данного этапа необходимо продумать алгоритм работы каждого разрабатываемого \textit{атомарного sc-агента}. Разработка алгоритма подразумевает выделение в нем логически целостных фрагментов, которые могут быть реализованы как отдельные \textit{scp-программы}, в том числе выполняемые параллельно. Таким образом, появляется необходимость говорить не только о \textit{Библиотеке многократно используемых абстрактных sc-агентов}, но и о \textit{Библиотеке многократно используемых программ обработки sc-текстов} на различных языках программирования, в том числе \textit{Библиотеке многократно используемых scp-программ}. Благодаря этому часть scp-программ, реализующих алгоритм работы некоторого sc-агента, может быть заимствована из соответствующей библиотеки.

Следует помнить, что если в процессе работы \textit{sc-агент} генерирует в памяти какие-либо временные структуры, то при завершении работы он обязан удалять всю информацию, использование которой в системе более нецелесообразно (убрать за собой информационный мусор). Исключение составляют ситуации, когда подобная информация необходима нескольким \textit{sc-агентам} для решения одной задачи, однако после решения задачи информация становится бесполезной или избыточной и требует удаления. В данном случае может возникнуть ситуация, когда ни один из \textit{sc-агентов} не в состоянии удалить информационный мусор. В таком случае возникает необходимость говорить о включении в состав решателя специализированных \textit{sc-агентов}, задачей которых является выявление и уничтожение информационного мусора.

\item Этап4. Реализация scp-программ

Конечным этапом непосредственно разработки является реализация специфицированных ранее \textit{scp-программ} или при необходимости программ, реализуемых на уровне платформы.

\item Этап5. Верификация разработанных компонентов

Верификация разработанных компонентов может осуществляться как вручную, так и с использованием специфицированных средств, входящих в состав системы автоматизации процесса построения и модификации гибридных решателей задач по технологии OSTIS.

\item Этап6. Отладка разработанных компонентов. Исправление ошибок

Этап отладки разработанных компонентов, в свою очередь, можно также условно разделить на более частные этапы:

\begin{scnitemizeii}
\item отладка отдельных scp-программ или программ, реализуемых на уровне платформы;

\item отладка отдельных атомарных sc-агентов;

\item отладка неатомарных sc-агентов, входящих в состав решателя задач;

\item отладка всего решателя задач.
\end{scnitemizeii}

\end{scnitemize}

Заметим, что \textit{Этап5} и \textit{Этап6} могут выполняться параллельно и повторяются до тех пор, пока разработанные компоненты не будут удовлетворять необходимым требованиям.
}

\scnheader{действие. разработать решатель задач ostis-системы}
\scnidtf{действие. разработать абстрактный sc-агент}
\scnsubdividing{действие. разработать атомарный абстрактный sc-агент\\
    \scnaddlevel{1}
    \scnrelfrom{включение}{действие. разработать платформенно-независимый атомарный абстрактный sc-агент}
    \scnaddlevel{-1}
    ;действие. разработать неатомарный абстрактный sc-агент}
\scnrelfromlist{абстрактное поддействие}{действие. специфицировать абстрактный sc-агент;действие. найти в библиотеке абстрактный sc-агент, удовлетворяющий заданной спецификации;действие. верифицировать sc-агент;действие. отладить sc-агент}

\scnheader{действие. разработать платформенно-независимый атомарный абстрактный sc-агент}
\scnrelfromlist{абстрактное поддействие}{действие. декомпозировать платформенно-независимый атомарный абстрактный sc-агент на scp-программы;действие. разработать scp-программу}

\scnheader{действие. разработать неатомарный абстрактный sc-агент}
\scnrelfromlist{абстрактное поддействие}{действие. декомпозировать неатомарный абстрактный sc-агент на более частные;действие. разработать абстрактный sc-агент}

\scnheader{действие. разработать scp-программу}
\scnrelfromlist{абстрактное поддействие}{действие. специфицировать scp-программу;действие. найти в библиотеке scp-программу, удовлетворяющую заданной спецификации;действие. реализовать специфицированную scp-программу;действие. верифицировать scp-программу;действие. отладить scp-программу}

\scnheader{действие. верифицировать sc-агент}
\scnsubdividing{действие. верифицировать атомарный sc-агент;действие. верифицировать неатомарный sc-агент}

\scnheader{действие. отладить sc-агент}
\scnsubdividing{действие. отладить атомарный sc-агент;действие. отладить неатомарный sc-агент}

\scnendstruct

\end{SCn}